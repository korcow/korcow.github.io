<!DOCTYPE html><html lang="ko"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="테스트"><title>내부명령어 | KORCOW</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">내부명령어</h1><a id="logo" href="/.">KORCOW</a><p class="description">HANS</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 홈</i></a><a href="/archives/"><i class="fa fa-archive"> 아카이브</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">내부명령어</h1><div class="post-meta">Oct 29, 2017<span> | </span><span class="category"><a href="/categories/Centos/">Centos</a></span></div><a data-disqus-identifier="2017/10/29/centos-내부명령어/" href="/2017/10/29/centos-내부명령어/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><div class="video-container"><iframe src="//www.youtube.com/embed/SSu822Lgta8" frameborder="0" allowfullscreen></iframe></div>
<hr>
<h2 id="내부명령어"><a href="#내부명령어" class="headerlink" title="내부명령어"></a>내부명령어</h2><p>내부명령은 Shell에 들어있고 별도 파일로 존재 하지 않는다고 했습니다. 내부명령어는 프로그램 언어 이기 때문에 당연히 변수, 상수, 조건문, 반복문, 배열,등이 있겠죠. 그걸 내부 명령어라고 합니다.</p>
<p>컴퓨터는 명령을 내리면 결과를 돌려 줍니다. 받은 결과를 다른 명령령의 인자로 돌려 줄 수 있다는 것도 꼭 기억하시기 바랍니다.</p>
<p>Terminal에서</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># enable</span></div></pre></td></tr></table></figure>
<p>위와 같이 입력하면 현재 사용자가 쓸수 있는 내부 명령어를 보여 줍니다.<br>권한과 옵션에 따라 더많이 보일 수도 있고 적게 보일 수도 있습니다.</p>
<table>
<thead>
<tr>
<th>.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>.</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>:</td>
<td>[</td>
<td>alias</td>
<td>bg</td>
<td>bind</td>
</tr>
<tr>
<td>break</td>
<td>builtin</td>
<td>caller</td>
<td>cd</td>
<td>command</td>
<td>compgen</td>
</tr>
<tr>
<td>complete</td>
<td>compopt</td>
<td>continue</td>
<td>declare</td>
<td>dirs</td>
<td>disown</td>
</tr>
<tr>
<td>echo</td>
<td>enable</td>
<td>eval</td>
<td>exec</td>
<td>exit</td>
<td>export</td>
</tr>
<tr>
<td>fc</td>
<td>fg</td>
<td>getopts</td>
<td>hash</td>
<td>help</td>
<td>history</td>
</tr>
<tr>
<td>jobs</td>
<td>kill</td>
<td>let</td>
<td>local</td>
<td>logout</td>
<td>mapfile</td>
</tr>
<tr>
<td>popd</td>
<td>printf</td>
<td>pushd</td>
<td>pwd</td>
<td>read</td>
<td>readarray</td>
</tr>
<tr>
<td>readonly</td>
<td>return</td>
<td>set</td>
<td>shift</td>
<td>shopt</td>
<td>source</td>
</tr>
<tr>
<td>suspend</td>
<td>test</td>
<td>times</td>
<td>trap</td>
<td>true</td>
<td>type</td>
</tr>
<tr>
<td>typeset</td>
<td>ulimit</td>
<td>umask</td>
<td>unalias</td>
<td>unset</td>
<td>wait</td>
</tr>
<tr>
<td>false</td>
<td></td>
</tr>
</tbody>
</table>
<p>맨 마지막에 위 명령어의 설명이 있습니다. </p>
<p>bash script 명령은 파이프라인과 리다이렉션만 설명하고 bash script를 설명할 때 다루도록 하겠습니다.</p>
<p><strong>cd, pwd, bg, fg, fc, echo, exec, kill, umask, export, source, logout, times, type</strong> 이 정도가 많이 쓰입니다.</p>
<table>
<thead>
<tr>
<th>명령어</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>cd</td>
<td>경로를 이동합니다.</td>
</tr>
<tr>
<td>pwd</td>
<td>현재 위치한 경로를 알려줍니다.</td>
</tr>
<tr>
<td>bg</td>
<td>&amp;를 붙여 실행시 백그라운드로 보냅니다.</td>
</tr>
<tr>
<td></td>
<td>인수가 없으면 백그라운드로 실행되고 있는 프로그램을 포그라운드로 실행합니다.</td>
</tr>
<tr>
<td>fg</td>
<td>백그라운드에서 실행되는 프로그램을 포그라운드로 가져옵니다.</td>
</tr>
<tr>
<td>echo</td>
<td>문자를 출력합니다.</td>
</tr>
<tr>
<td>exec</td>
<td>프로그램을 실행합니다.</td>
</tr>
<tr>
<td>kill</td>
<td>실행되고 있는 프로세스를 종료합니다.</td>
</tr>
<tr>
<td>umask</td>
<td>사용자가 생성하는 파일을 mode로 설정합니다.</td>
</tr>
<tr>
<td>export</td>
<td>환경변수를 등록합니다.</td>
</tr>
<tr>
<td>source</td>
<td>bash script가 있는 파일을 실행합니다.</td>
</tr>
<tr>
<td>logout</td>
<td>현재 사용자를 로그아웃 시킵니다.</td>
</tr>
</tbody>
</table>
<h3 id="파이프라인과-리다이렉션"><a href="#파이프라인과-리다이렉션" class="headerlink" title="파이프라인과 리다이렉션"></a>파이프라인과 리다이렉션</h3><h4 id="파이프라인"><a href="#파이프라인" class="headerlink" title="파이프라인"></a>파이프라인</h4><p><code>|</code> 파이프라인 : 파이프라인을 기준으로 좌측 명령의 결과를 우측의 명령에 인자로 전달합니다.</p>
<h4 id="리다이렉션"><a href="#리다이렉션" class="headerlink" title="리다이렉션"></a>리다이렉션</h4><p><code>&gt;</code> 리다이렉션 : 왼쪽 명령 출력 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일 또는 장치(장치도 파일)<br><code>&lt;</code> 리다이렉션 : 왼쪽 명령 입력 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일 또는 장치(장치도 파일)<br><code>&gt;&gt;</code> 리다이렉션 : 왼쪽 명령 출력 방향을 오른쪽 옵션으로 바꾸어 추가해 줍니다. 옵션은 파일 또는 장치<br><code>&lt;&lt;</code> 리다이렉션 : 왼쪽 명령 입력 방향을 오른쪽 옵션으로 바꾸어 추가해 줍니다. 옵션은 파일 또는 장치</p>
<ul>
<li><p>처음엔 무슨 뜻인지 햇갈릴 겁니다.<br>  프로그램은 순차적으로 실행됩니다. 왼쪽에서 오른쪽으로.<br>  처음 실행되는 프로그램이 출력을 한다면 출력방향을 바꾸어 줍니다.<br>  처음 실행되는 프로그램 입력을 대기한다면 입력방향을 바꾸어 줍니다.</p>
</li>
<li><p>기본 출력방향은 모니터 입니다.</p>
</li>
<li>기본 입력방향은 키보드 입니다.<br><code>0&lt;</code> 표준입력: /dev/stdin 생략가능<br><code>1&gt;</code> 표준출력: /dev/stdout 생략가능<br><code>2&gt;</code> 표준에러출력: /dev/stderr 에러를 출력하기 위해서는 필수.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$echo</span> <span class="string">"hello"</span></div><div class="line"><span class="variable">$echo</span> <span class="string">"hello"</span> &gt; aaa.txt</div><div class="line"><span class="variable">$cat</span> aaa.txt</div><div class="line">hello</div><div class="line"><span class="variable">$cat</span> &lt; /dev/stdin</div><div class="line">hello world</div><div class="line">hello world</div><div class="line">^C</div></pre></td></tr></table></figure>
<ul>
<li><p>echo는 문자 또는 문자열을 출력해주는 프로그램입니다.<br>기본 방향이 모니터이기 때문에 모니터에 문자열을 출력해 주겠죠.<br>출력 방향을 aaa.txt(파일)로 바꾸면 화면에는 아무것도 출력되지 않고 aaa.txt을 생성해서 파일안에 hello라고 써 넣습니다.</p>
</li>
<li><p>cat이라는 프로그램은 파일을 출력해 주는 외부 명령어 입니다.<br>사용법은 cat 파일명 하면 파일명을 화면으로 출력해 줍니다.<br>입력을 파일로부터 받는다는 겁니다.<br>위 예제는 cat의 입력방향을 표준입력인 키보드로 바꾸어 준겁니다.<br>종료하려면 <code>Ctrl + C</code> 를 입력합니다.</p>
</li>
<li><p>옵션이 파일명이면 파일로 만들어 주거나 파일에 덧붙여 줍니다. xNIX는 장치도 파일입니다. 파이프라인과 리다이렉션은 무척 중요합니다. 지금은 가볍게 이해 정도만 해주세요. 이해가 안되도 넘어 가도 됩니다. </p>
</li>
</ul>
<h3 id="와일드카드"><a href="#와일드카드" class="headerlink" title="와일드카드"></a>와일드카드</h3><table>
<thead>
<tr>
<th>문자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>모든 문자</td>
</tr>
<tr>
<td><code>?</code></td>
<td>문자하나</td>
</tr>
<tr>
<td><code>[characters]</code></td>
<td>characters 문자 집합에 포함된 문자</td>
</tr>
<tr>
<td><code>[!characters]</code></td>
<td>characters 문자 집합에 포함 되지 않은 문자</td>
</tr>
<tr>
<td><code>[[:class:]]</code></td>
<td>아래 클래스를 사용</td>
</tr>
<tr>
<td><code>[:alnum:]</code></td>
<td>알파벳과 숫자를 지정</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>알파벳 지정</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>숫자를 지정</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>소문자</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>대문자</td>
</tr>
</tbody>
</table>
<p>와일드 카드도 너무 중요한 명령입니다. 지금은 이런것이 있다는 것만 너무 중요한데 그냥 넘어 가는구나 생각만 하세요. ls 명령에서 다시 알아 보겠습니다. </p>
<h3 id="man-page-도움말-보기"><a href="#man-page-도움말-보기" class="headerlink" title="man page 도움말 보기"></a>man page 도움말 보기</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># man cd</span></div><div class="line"><span class="comment"># man pwd</span></div><div class="line"><span class="comment"># man bash</span></div></pre></td></tr></table></figure>
<p>man 명령을 이용해 도움말을 볼 수 있습니다.<br>man 도움말에서 h-key를 누르면 사용법을 볼수 있습니다.<br>q-key를 누르면 종료됩니다. 커서키를 이용해서 위, 아래로 이동하며 스크롤도 할 수 있고, 찾기도 할 수 있습니다.</p>
<hr>
<h1 id="BASH-BUILTIN-명령어-설명"><a href="#BASH-BUILTIN-명령어-설명" class="headerlink" title="BASH BUILTIN 명령어 설명"></a>BASH BUILTIN 명령어 설명</h1><ul>
<li><code>: [인수들]</code> <ul>
<li>아무런 효과도 없다; 인수들을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다. 종료 상태값 0 을 반환한다.</li>
</ul>
</li>
<li><code>.</code> <ul>
<li>파일명 [인수들] | 현재의 디렉토리를 나타낸다. 인수로는 디렉토리와 파일명이 올수 있다.</li>
</ul>
</li>
<li><code>source 파일명 [인수들]</code> <ul>
<li>파일명 으로부터 명령을 읽어 현재 쉘 환경 안에서 실행한다. 파일명 에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다. 파일명 에 슬래쉬가 없으면 PATH 변수에 들어있는 경로명을 사용하여 파일명 을 검색한다. PATH 변수에서 찾는 파일이 실행 파일일 필요는 없다. PATH 에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다. 인수들을 적으면 파일을 실행할 때 위치 매개변수로 사용한다. 그렇지 않으면 위치 매개변수는 변하지 않는다. 스크립트 내에서 종료한 마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0) 파일명 을 찾을 수 없으면 거짓을 반환한다.</li>
</ul>
</li>
<li><p><code>alias [이름[=값] ...]</code> </p>
<ul>
<li>아무런 인수 없이 <code>Alias</code>를 실행하면 표준 출력에 이름=값의 형식으로 앨리어스 목록을 출력해준다. 인수를 제공하면 각각의 이름에 대하여 값을 앨리어스로 정의한다. 값 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도 앨리어스 확장이 가능한지 점검하도록 할 수 있다. 인수 목록에서 값을 주지 않은 이름에 대해서는 앨리어스의 이름과 값을 출력한다. 주어진 이름에 대한 앨리어스가 정의되어 있지 않은 경우가 아니라면 참값을 반환한다.</li>
</ul>
</li>
<li><p><code>bg [작업명세]</code></p>
<ul>
<li><code>&amp;</code> 를 붙여 실행한 것처럼 작업명세가 가리키는 작업을 백그라운드로 보낸다. 작업명세가 없으면 현재 작업에 해당하는 작업이 사용된다. <code>bg</code> 작업명세 는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만 작업명세를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고 0 을 반환한다.</li>
</ul>
</li>
<li><p><code>bind [-m 키맵] [-lvd] [-q 이름]</code></p>
</li>
<li><code>bind [-m 키맵] -f 파일명</code> </li>
<li><p><code>bind [-m 키맵] 키시퀀스:함수이름</code> </p>
<ul>
<li>readline 의 현재 키, 함수 바인딩을 표시하거나 readline 함수나 매크로에 키 시퀀스를 결합한다. 바인딩 문법은 .inputrc 의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다; 예를 들어, ‘“\C-x\C-r”: re-read-init-file’. 옵션을 적는 경우에는 다음과 같은 의미를 가진다:<pre><code>- ``-m`` 키맵 뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로 키맵 을 사용한다. 가능하 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, 그리고 vi-insert 이 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다.
- -l 모든 readline 함수의 이름을 나열한다.
- -v 현재 함수 이름과 바인딩을 나열한다.
- -d 다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다.
- -f 파일명 filename으로부터 키 바인딩을 읽는다.
- -q 함수 함수를 실행시키는 키에 대하여 알아본다. 알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다.
</code></pre></li>
</ul>
</li>
<li><p><code>break [n]</code> </p>
<ul>
<li>for, while, until 루프 안에서 탈출한다. n을 명시하면 n 레벨을 탈출한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다. break 이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다.</li>
</ul>
</li>
<li><p><code>builtin 쉘-내부명령 [인수들]</code> </p>
<ul>
<li>명시한 쉘 내부 명령에 인수들 을 주어 실행하고 종료 상태값을 반환한다. 쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의 기능을 활용하고자 할 때 유용하다. 보통 cd 내부 명령을 이런 식으로 재정의하곤 한다. 쉘-내부명령 이 쉘 내부 명령이 아닐 때 거짓을 반환한다.</li>
</ul>
</li>
<li><p><code>cd [디렉토리]</code> </p>
<ul>
<li>현재 디렉토리를 디렉토리로 변경한다. HOME 변수 값이 기본 디렉토리 값이다. CDPATH 변수는 디렉토리 를 포함하는 디렉토리에 대한 검색 경로를 정의한다. 서로 다른 디렉토리는 콜론(:)으로 구분한다. CDPATH 에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 <code>.</code>와 같다. 디렉토리 가 슬래쉬(/)로 시작하면 CDPATH 는 사용되지 않는다. 전달인수로 - 를 사용하면 <code>$OLDPWD</code> 와 같다. 성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다.</li>
</ul>
</li>
<li><p><code>command [-pVv] 명령 [인수 ...]</code></p>
<ul>
<li>보통의 쉘 함수 찾아보기를 하지 않고 명령 을 인수 와 함께 실행한다. 내부 명령 또는 PATH 에서 찾을 수 있는 명령만을 실행한다. are executed. If the </li>
<li>-p 옵션을 주면 PATH 의 기본값을 사용하여 명령 에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다. </li>
<li>-V 또는 -v 옵션을 주면 명령 에 대한 설명을 출력한다. -v 옵션은 명령 을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다; -V 옵션은 좀 더 자세한 설명을 출력한다. – 를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다. -V 또는 -v 옵션을 주었을 때 종료 상태값은 명령 이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나 명령 을 찾을 수 없으면 종료 상태값은 127 이 된다. 그렇지 않을 때 command 내부 명령의 종료 상태값은 명령 의 종료 상태값이다.</li>
</ul>
</li>
<li><p><code>continue [n]</code> </p>
<ul>
<li>둘러 싸고 있는 <code>for, while, until</code> 루프의 다음 순차 작업을 재개한다. <code>n</code> 을 명시하면, <code>n</code> 번째 루프를 재개한다. <code>n 은 ≥ 1</code> 여야 한다. <code>n</code> 이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(<code>최상위 레벨</code> 루프)를 재개한다. <code>continue</code> 명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은 0 이다.</li>
</ul>
</li>
<li><p><code>declare [-frxi] [이름[=값]]</code></p>
</li>
<li><p><code>typeset [-frxi] [이름[=값]]</code></p>
<ul>
<li>변수를 선언하거나 변수에 속성을 부여한다.    아무런 이름도 주어지지 않았을 때에는 변수의 값을 표시한다. 옵션을 사용하여 특정 속성의 변수에 대해서만 출력하도록 제한할 수 있다.<ul>
<li>-f | 함수 이름만 사용</li>
<li>-r | 이름을 읽기 전용으로 만든다. 그 뒤에는 지정문을 사용하여 값을 지정할 수 없다.</li>
<li>-x | 이름을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다.</li>
<li>-i | 변수를 정수처럼 취급한다; 변수에 값을 지정하면 산술 평가( 산 이 옵션을 끄려면 <code>-</code> 대신 <code>+</code>를 사용한다. 함수 안에서 사용하면 local 명령처럼 이름을 지역적으로 만든다. 잘못된 옵션을 만났다든지, <code>&quot;-f foo=bar&quot;</code>를 사용하여 함수를 정의하려고 시도했다든지, 이름이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용 상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를 표시하려 한 경우가 아니라면 반환값은 0 이다.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>dirs [-l] [+/-n]</code></p>
<ul>
<li>현재까지 기억하고 있는 디렉토리 목록을 표시한다. 디렉토리를 목록에 추가할 때에는 pushd 명령을 사용한다; popd 명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다.<br>  옵션 | 설명<br>  —|—<br>  <code>+n</code> | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 왼쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다.<br>  <code>-n</code> | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 오른쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다.<br>  <code>-l</code> | 긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼 때 틸드를 사용한다. 틀린 옵션을 주거나 n 이 디렉토리 스택 범위를 넘어서는 경우가 아니라면 반환값은 0 이 된다.</li>
</ul>
</li>
<li><p><code>echo [-neE] [인수 ...]</code></p>
<ul>
<li><p>스페이스로 구분되어 있는 인수들을 출력한다. 반환값은 항상 0 이다.</p>
<ul>
<li>-n을 명시하면 마지막의 개행문자를 출력하지 않는다.</li>
<li>-e 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다.</li>
<li><p>-E 옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도 이스케이프 문자를 해석하지 않도록 지시한다.</p>
<p>escape 문자| 설명<br>—|—<br><code>\a</code>   |경 고 (벨)<br><code>\b</code>   |백스페이스<br><code>\c</code>   |마지막 개행문자를 생략함<br><code>\f</code>   |폼 피드<br><code>\n</code>   |개행문자<br><code>\r</code>   |캐리지 리턴<br><code>\t</code>   |수평 탭<br><code>\v</code>   |수직 탭<br><code>\\</code>   |백슬래쉬<br><code>\nnn</code> |ASCII 코드가 nnn (8진수)인 문자</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>enable [-n] [|-all] [이름 ...]</code></p>
<ul>
<li>쉘 내부 명령을 켜거나 끈다. 이 기능을 사용하면 쉘 내부 명령과 같은 이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수 있다. -n을 사용하면 각 이름의 사용을 끈다; 그렇지 않으면 이름의 사용을 켠다. 예를 들어, 쉘 내부 명령 버전 대신 PATH 에서 찾을 수 있는 test 바이너리를 사용하려면 <code>enable -n test</code> 라고 실행한다. 인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다. -n만 주면 사용 불능 상태의 내부 명령 목록을 출력한다. -all만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여 출력해준다. enable 명령은 -all 대신 -a 도 받아들인다. 이름 이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다.</li>
</ul>
</li>
<li><p><code>eval [인수 ...]</code></p>
<ul>
<li>모든 인수를 읽어 하나의 명령으로 결합한다. 그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을 eval 명령의 반환값으로 돌려준다. 인수가 하나도 없거나 널 인수이면 eval 은 참을 반환한다.</li>
</ul>
</li>
<li><p><code>exec [[-] 명령 [인수]]</code></p>
<ul>
<li>명령 을 명시하면 그 명령으로 쉘 프로세스를 교체한다. 새로운 프로세스는 만들어지지 않는다. 인수 는 명령의 인수가 된다. 첫번째 인수가 - 이면 쉘은 명령 에 전달하는 0 번째 인수에 대쉬를 넣는다. 이 과정은 로그인이 하는 일과 같다. 어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수 no_exit_on_failed_exec가 존재하여 거짓을 반환하는 경우를 제외하고 비대화형 쉘은 종료한다. 파일을 실행할 수 없을 때 대화형 쉘은 거짓을 반환한다. 명령 을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은 0 이 된다.</li>
</ul>
</li>
<li><p><code>exit [n]</code></p>
<ul>
<li>상태값 n을 가지고 쉘을 종료한다. n 을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다. 쉘을 종료하기 전에 EXIT 에 대한 트랩(trap) 루틴이 실행된다.</li>
</ul>
</li>
<li><p><code>export [-nf] [이름[=단어]] ...</code></p>
</li>
<li><p><code>export -p</code></p>
<ul>
<li>나열한 이름 을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다.<br>  -f 옵션을 주면 이름 은 함수를 가리킨다. 아무런 이름 도 적지 않거나 또는<br>  -p 옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다.<br>  -n 옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다.<br>  – 인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다. 잘못된 옵션을 만나거나 이름이 적법한 쉘 변수 이름이 아니거나 또는 함수가 아닌 이 상태값 0 을 반환한다.</li>
</ul>
</li>
<li><p><code>fc [-e 편집기이름] [-nlr] [처음] [마지막]</code></p>
</li>
<li><p><code>fc -s [패턴=치환텍스트] [명령]</code></p>
<ul>
<li>명령을 수정한다. 첫번째 형식에서, 명령의 범위는 처음 부터 마지막 범위에 있는 명령을 히스토리 목록에서 선택한다. 처음 과 마지막 은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자 (히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터 떨어진 만큼을 뜻한다)로 명시할 수 있다. 마지막 을 명시하지 않으면 현재 명령으로 설정되고(따라서 fc -l -10 은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면 처음 까지 출력한다. If 처음 을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해 -16 을 설정한다.<br>-n 플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다.<br>-r 플래그는 명령의 표시 순서를 반대로 한다.<br>-l 플래그가 있으면 명령을 표준 출력에 나열한다. 그렇지 않을 때에는 편집기이름 이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다. 편집기이름 이 없으면 FCEDIT 변수의 값을 사용하며 FCEDIT 가 설정되어 있지 않을 때에는 EDITOR 값을 사용한다. 둘 다 설정되어 있지 않으면 를 사용한다. 편집을 마친 후에는 편집한 명령들이 화면에 표시되고 실행된다.<br>두번째 형태에서, 명령은 패턴이 치환텍스트로 교체된 후에 다시 실행된다. 유용한 앨리어스로는 <code>r=fc -s</code>가 있다. 앨리어스 적용 후 <code>r cc</code> 라고 치면 <code>cc</code>로 시작하는 최근 명령을 실행하고 <code>r</code>이라고 치면 마지막 명령을 다시 실행하게 된다.<br>첫번째 형태를 사용하면 잘못된 옵션이 있거나 처음 또는 마지막 이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다. -e 옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서 오류가 발생하는 경우 실패 값을 가진다. 두번째 형태를 사용하면 명령 이 유효한 히스토리 행을 가리키지 못하여 fc 가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로 사용한다.</li>
</ul>
</li>
<li><p><code>fg [작업스펙]</code> </p>
<ul>
<li>작업스펙 이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다. 작업스펙 이 존재하지 않으면 쉘에서 현재 작업이라고 부르는 것을 사용한다. 반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서 실행된 경우에는 실패이다. 그리고 작업 제어 가능한 상태에서도 작업스펙 이 유효한 작업을 가리키지 않거나 작업스펙 이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다.</li>
</ul>
</li>
<li><p><code>getopts 옵션문자열 이름 [인수]</code> </p>
<ul>
<li>getopts 는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다.    옵션문자열 은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에 화이트스페이스로 분리된 인수가 온다는 뜻이다. 매번 실행될 때마다, getopts 는 다음 옵션을 쉘 변수 이름 에 넣는다. 이름 이 존재하지 않을 때에는 초기화한다. 그리고 처리할 다음 인수의 인덱스는 OPTIND 변수에 넣는다. OPTIND 는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다. 옵션에서 인수를 필요로 할 때에는 getopts 에서 그 인수를 OPTARG 변수에 넣는다. 쉘이 자동으로 OPTIND 변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을 사용하려면 getopts 를 부를 때마다 수동으로 재설정해 주어야 한다.<br>getopts 는 두 가지 방식으로 오류를 보고할 수 있다. 옵션문자열 의 첫번째 문자가 콜론이면 조용한 오류 보고가 사용된다. 정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의 경우 증상을 설명하는 메시지가 출력된다. OPTERR 변수를 0 으로 설정하면 옵션문자열 의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다.<br>잘못된 옵션을 만나면, getopts 는 이름 에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우, 오류 메시지를 출력하고 OPTARG 를 unset 한다. getopts 이 조용한 모드에 있는 경우 찾아낸 옵션 문자를 OPTARG 에 넣고 증상 설명 메시지를 출력하지 않는다.<br>필요한 인수를 찾을 수 없으며 getopts 가 조용한 모드에 있지 않을 때에는 물음표를 (?) 이름 에 넣고 OPTARG 를 unset 하며 증상 설명 메시지를 출력한다. getopts 가 조용한 모드에 있으면 콜론을 (:) 이름 에 넣고 OPTARG 을 찾아낸 옵션 문자로 설정한다.<br>getopts 는 보통 위치 매개변수를 파싱하지만 인수 부분에 더 많은 인수를 주면 getopts 는 대신 그 인수를 파싱한다. getopts 는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다. 옵션의 끝이거나 에러가 발생하면 거짓을 반환한다.</li>
</ul>
</li>
<li><p><code>hash [-r] [이름]</code><br>  각 이름 에 대하여, 그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다.<br>  -r 옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다. 아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다.<br>  – 라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다. 이름 이 없거나 잘못된 옵션이<br>   주어진 경우가 아닌 경우에는 참을 반환한다.</p>
</li>
<li><p><code>help [패턴]</code><br>  내부명령에 대한 도움말을 출력한다. 패턴 을 적으면, help 는 패턴과 일치하는 모든 명령에 대하여 자세한 도움말을 준다; 패턴을 적지 않으면 모든 내부명령 목록을 출력한다. 패턴과 일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다.</p>
</li>
<li><p><code>history [n]</code></p>
</li>
<li><p><code>history -rwan [filename]</code><br>  옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. <code>*</code> 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다 ;없으면 HISTFILE 변수의 값을 사용한다.<br>   옵션이 있는 경우 다음과 같은 뜻을 갖는다:<br>   -a     히스토리 파일에 <code>새로운</code> 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다.<br>   -n     히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다.<br>   -r     히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다.<br>   -w     현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다.</p>
</li>
<li><p><code>jobs [-lnp] [ 작업스펙 ... ]</code></p>
</li>
<li><p><code>jobs -x 명령 [ 인수 ... ]</code><br>  첫번째 형태는 활동 중인 작업을 나열한다. -l 옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다; -p 옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다. -n 옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다. 작업스펙 을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다. 잘못된 옵션을 적거나 잘못된 작업스펙 을 적은 경우가 아니라면 반환값은 0 이다.<br>  -x 옵션을 붙이면, jobs 명령은 명령 또는 인수 안 에서 작업스펙 을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고 명령 에 인수 를 주어 실행하고 그 종료 상태값을 반환한다.</p>
</li>
<li><p><code>kill [-s 시</code></p>
</li>
<li><p><code>kill -l [시그널번호]</code><br>  pid 또는 작업스펙이 가리키는 프로세스에게 시그널스펙 이 가리키는 시그널을 보낸다. 시그널스펙 은 SIGKILL 과 같은 시그널 이름 또는 시그널 번호이다. 시그널스펙 이 시그널 이름인 경우, 대소문자는 구별하지 않으며 SIG 라는 접두어를 써도 되고 쓰지 않아도 된다. 시그널스펙 이 없으면, SIGTERM 이라고 가정한다.<br>  -l 인수를 적으면 시그널 이름을 나열해 준다. -l 이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고 반환값은 0 이다.<br>  – 인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다. kill 최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다. 오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다.</p>
</li>
<li><p><code>let 인수 [인수 ...]</code></p>
<ul>
<li>각각의 인수 는 계산한 수치 표현식이다.( 산 마지막 인수 를 평가하여 그 결과가 0 이면, let 은 1 을 반환한다; 나머지 경우에는 0 을 반환한다.</li>
</ul>
</li>
<li><p><code>local [이름[=값] ...]</code></p>
<ul>
<li>각 인수에 대하여 이름 이라는 지역 변수를 만들고 값 을 할당한다. local 을 함수 안에서 사용하면, 이름 변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다. 피연산자가 없으면, local 은 지역변수 목록을 표준 출력으로 출력한다. local 를 함수 안에서 사용하지 않는 것은 오류이다. local 을 함수 외부에서 사용했거나 잘못된 이름 을 적은 경우가 아니라면 반환 상태값은 0 이다.</li>
</ul>
</li>
<li><p><code>logout</code> </p>
<ul>
<li>로그인 쉘을 마친다.</li>
</ul>
</li>
<li><p><code>popd [+/-n]</code></p>
<ul>
<li>디렉토리 스택에서 항목을 제거한다. 인수가 없으면 스택의 최상위 디렉토리를 제거하고 그 새로운 상위 디렉토리로 cd 한다.</li>
<li><code>+n</code> dirs 명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, <code>popd +0</code>는 첫번째 디렉토리를, <code>popd +1</code>는 두번째 디렉토리를 제거한다.</li>
<li><code>-n</code> dirs 명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, <code>popd -0</code>는 맨 마지막 디렉토리를, <code>popd -1</code>는 맨 마지막 바로 전 디렉토리를 제거한다.</li>
<li>popd 명령이 성공적이면, dirs 명령도 실행하며 반환 상태값은 0 이다. popd 는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다.</li>
</ul>
</li>
<li><p><code>pushd [디렉토리]</code></p>
</li>
<li><p><code>pushd +/-n</code></p>
<ul>
<li>디렉토리를 디렉토리 스택의 맨 위에 추가하거나, 스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다. 인수가 없으면, 최상위 두 디렉토리를 교환한다. 디렉토리 스택이 비어 있지 않으면 0을 반환한다.</li>
<li><code>+n</code> n번째 디렉토리( dirs 명령이 보여주는 목록의 맨 왼쪽부터 센다) 이 맨 위에 놓이도록 스택을 회전시킨다. )</li>
<li><code>-n</code> n번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록 스택을 회전시킨다. 디렉토리를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다. </li>
<li>pushd 명령이 성공적이면, dirs 명령도 수행한다. 첫번째 형식을 사용하면, pushd 는 디렉토리 로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다. 두번째 형식을 사용하면, pushd 는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면 0을 반환한다.</li>
</ul>
</li>
<li><p><code>pwd</code></p>
<ul>
<li>현재 디레토리의 절대 경로명을 출력한다. set 내부명령의 -P 옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다. ( 쉘 현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은 0이다.</li>
</ul>
</li>
<li><p><code>read [-r] [이름 ...]</code> </p>
<ul>
<li>표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 첫번째 이름 에 할당하고 두번째 단어를 두번째 이름 에 할당하고 나머지 남은 단어들을 마지막 이름 에 할당한다. IFS 에 있는 단어만을 단어 구분자로 인식한다. 아무런 이름 도 적지 않으면 읽어들인 행을 REPLY 변수에 할당한다. 파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다. </li>
<li>-r 옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로 인식한다.</li>
</ul>
</li>
<li><p><code>readonly [-f] [이름 ...]</code></p>
</li>
<li><p><code>readonly -p</code> </p>
<ul>
<li>주어진 이름들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해 이름들의 값이 바뀌지 않도록 해 준다. </li>
<li>-f 옵션을 더하면, 이름에 해당하는 함수를 읽기 전용으로 표기한다. 아무런 인수도 없거나 </li>
<li>-p 옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다. – 인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다. 잘못된 옵션이 있거나 이름들 중 하나라도 적접한 쉘 변수 이름이 아닌 경우 또는 -f 다음에 나온 이름 이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다.</li>
</ul>
</li>
<li><p><code>return [n]</code><br>  함수를 상태 반환값 n 을 갖고 종료하도록 한다. n 을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다. 함수 밖에서 사용했지만 . (source) 명령으로 실행한 스크립트에서 사용하면, 쉘은 그 스크립트 실행을 멈추고 n 또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로 반환한다. 함수 밖에서 사용했으며 .[uB85C] 실행한 스크립트가 아니라면 반환 상태값은 거짓이 된다.</p>
</li>
<li><p><code>set [--abefhkmnptuvxldCHP] [-o 옵션] [인수 ...]</code><br>  -a     뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로 표기한다.<br>  -b     종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이 아니라 즉시 보여 주도록 한다. ( 쉘 섹션에서 notify 참고)<br>  -e     간단한-명령 ( 쉘 종료하면 즉시 종료한다. 만약 실패한 명령이 until 또는 while 루프의 일부, if 문의 일부, <code>&amp;&amp;</code> 의 일부, or <code>⎪⎪</code> 목록의 일부이거나 또는 명령의 반환값이 <code>!</code> 으로 반전되면 종료하지 않는다.<br>  -f     경로명 확장을 하지 않는다.<br>  -h     함수를 정의할 때 함수 명령을 찾아 기억해 둔다. 함수를 실행할 때 함수 명령을 정상적으로 찾아 본다.<br>  -k     명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에 둔다.<br>  -m     모니터(감시) 모드. 작업 제어를 사용한다. 지원하는 시스템에서 실행하는 대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다. ( 작 별도의 프로세스 그룹 안에서 실행되며 실행을 완료하면 종료 상태값을 포함하는 행을 출력한다.<br>  -n     명령을 읽지만 실행하지는 않는다. 쉘 스크립트 문법 오류를 점검할 때 사용할 수 있다. 대화형 쉘에서는 무시한다.<br>  -o 옵션-이름<br>  옵션-이름은 다음 중 한 가지이다:<br>  allexport -a 와 같다.<br>  braceexpand 쉘이 중괄호 확장을 행한다. ( 앞서 나온 중 확 emacs 이맥스 스타일의 명령행 편집 인터페이스를 사용한다. 쉘을 시작할 때 -nolineediting 옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다.<br>   errexit -e와 같다.<br>   histexpand -H와 같다.<br>   ignoreeof 마치 쉘 명령 <code>IGNOREEOF=10</code>을 실행한 것과 같은 효과를 발휘한다. (앞서 나온 쉘 interactive-comments<br>   어떤 단어를 # 로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다. (앞서 나온 주 monitor -m와 같다.<br>   noclobber -C와 같다.<br>   noexec -n와 같다.<br>   noglob -f와 같다.<br>   nohash -d와 같다.<br>   notify -b와 같다.<br>   nounset -u와 같다.<br>   physical -P와 같다.<br>   posix POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을 따르도록 만든다.<br>   privileged -p와 같다.<br>   verbose -v와 같다.<br>   vi     vi 스타일의 명령행 편집 인터페이스를 사용한다.<br>   xtrace -x와 같다.<br>   옵션-이름을 적지 않으면 현재 옵션값을 출력한다.<br>   -p     privileged 모드를 켠다. 이 모드에서는 <code>$ENV</code> 파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다. 유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때 자동으로 작동한다. 이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자, 그룹 ID로 설정한다.<br>   -t     명령 하나를 읽어 실행한 후 종료한다.<br>   -u     매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다. 미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고 대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다.<br>   -v     쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다.<br>   -x     각각의 간단한-명령 을 확장한 후, bash PS4, 의 확장값을 표시하고 명령과 확장된 인수를 표시한다.<br>   -l     for 이름 [in 단 복원한다. (앞서 나온 쉘<br>   -d     실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다. 보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할 필요 없다.<br>   -C     쉘 명령 <code>noclobber=</code>을 실행한 것과 같은 효력을 발휘한다. (앞서 나온 쉘<br>   -H     ! 스타일의 히스토리 치환을 사용한다. 쉘이 대화형 모드이면 기본으로 켜지는 플래그이다.<br>   -P     설정하면, 현재 디렉토리를 변경하는 cd 와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다.    대신 물리적인 디렉토리를 사용한다.<br>   –     이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다. 만약 나오면, - 로 시작하는 것이 있다 할 지라도 위치 매개변수를 인수로 설정한다.<br>   <code>-</code>     옵션의 끝을 나타내며, 그 뒤에 나오는 모든 인수들을 위치 매개변수로 설정한다. -x 와 -v 옵션이 꺼진다. 만약 아무런 인수도 없다면, 위치 매개변수는 그대로이다.<br>   다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다. - 대신 + 를 사용하면 플래그를 끈다. 쉘을 실행할 때 옵션으로 적을 수 있다. 현재 플래그 상태는 <code>$-</code> 를 보면 알 수 있다. 옵션 인수를 처리한 후, 나머지 n 개의 인수는 위 매개변수의 값으로 간주하고 차례대로 <code>$1, $2, ... $n</code> 에 할당한다. 아무런 옵션도 없고 인수도 없으면 모든 쉘 변수를 출력한다. 잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다.</p>
</li>
<li><p><code>shift [n]</code><br>  n+1 부터의 위치 매개변수 이름을 <code>$1 ....</code> 로 변경한다. <code>$#</code>부터 <code>$#-n+1</code>까지의 매개변수는 unset된다. n 이 0 이면, 매개변수의 변화는 없다. n 이 주어지지 않으면 1 로 간주한다. n 은 <code>$#</code>보다 작거나 같은 음수 아닌 숫자여야 한다. n 이 <code>$#</code>보다 크면, 위치 매개변수의 변화는 없다. n 이 <code>$#</code> 보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다; 그렇지 않으면 0 이다.</p>
</li>
<li><p><code>suspend [-f]</code><br>  SIGCONT 시그널을 받을 때까지 쉘의 실행을 정지시킨다. -f 옵션은 로그인 쉘이라 할 지라도 불평 메시지를 출력하지 않도록 한다; 어찌 되었든 일시 정지한다. 쉘이 로그인 쉘이면서도 -f 이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은 0 이 된다.</p>
</li>
<li><p><code>test 표현식</code><br><code>[ 표현식 ]</code><br>  조건 표현식을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다. 표현식은 일항 또는 이항 표현식일 수 있다. 일항 표현식은 주로 파일의 상태를 점검할 때 사용한다. 문자열 연산자와 수치 비교 연산자도 있다. 각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다. 파일이 /dev/fd/n의 형태일 때에는, 파일 기술자 n를 점검한다.<br>  -b 파일: 파일이 존재하고 블럭 특수 파일이면 참.<br>  -c 파일: 파일이 존재하고 문자 특수 파일이면 참.<br>  -d 파일: 파일이 존재하고 디렉토리이면 참.<br>  -e 파일: 파일이 존재하면 참.<br>  -f 파일: 파일이 존재하고 일반 파일이면 참.<br>  -g 파일: 파일이 존재하고 set-group-id이면 참.<br>  -k 파일: 파일에 <code>스틱키(sticky)</code>비트가 설정되어 있으면 참.<br>  -L f파일: 파일이 존재하고 심볼릭 링크이면 참.<br>  -p 파일: 파일이 존재하고 명명된(named) 파이프이면 참.<br>  -r 파일: 파일이 존재하고 읽을 수 있으면 참.<br>  -s 파일: 파일이 존재하고 그 크기가 0 보다 크면 참.<br>  -S 파일: 파일이 존재하고 소켓이면 참.<br>  -t fd fd (파일 기술자)가 열린 상태이고 터미널이면 참.<br>  -u 파일: 파일이 존재하고 set-user-id 비트가 설정되어 있으면 참.<br>  -w 파일: 파일이 존재하고 쓸 수 있으면 참.<br>  -x 파일: 파일이 존재하고 실행 가능하면 참.<br>  -O 파일: 파일이 존재하고 유효(effective) 사용자 ID의 소유이면 참.<br>  -G 파일: 파일이 존재하고 유효 그룹 ID의 소유이면 참.<br>  파일1 -nt 파일2: 파일1이 (수정 일시에 의거하여) 파일2보다 새로운 파일이면 참.<br>  파일1 -ot 파일2: 파일1이 파일2보다 오래 된 파일이면 참.<br>  파일1 -ef 파일2: 파일1과 파일2가 같은 장치이며 아이노드 번호가 같으면 참.<br>  -z 문자열: 문자열의 길이가 0이면 참.<br>  -n 문자열: 문자열 문자열 의 길이가 0이 아니면 참.<br>  문자열1 = 문자열2: 두 문자열이 같으면 참.<br>  문자열1 != 문자열2: 두 문자열이 같지 않으면 참.<br>  ! 표현식: 표현식 이 거짓이면 참.<br>  표현식1 -a 표현식2: 표현식1 과 표현식2 둘 다 참이면 참.<br>  표현식1 -o 표현식2: 표현식1 또는 표현식2 둘 중 하나가 참이면 참.<br>  인수1 연산자: 위와 같은 수치 이항 연산자는 각각 인수1이 인수2와 같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다. 인수1 과 인수2 는 양의 정수, 음의 정수 또는 -l 문자열과 같이 문자열 의 길이로 평가되는 특별한 표현식이 될 수 있다.</p>
</li>
<li><p><code>times</code> </p>
<ul>
<li>쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간, 시스템 영역에서의 소모 시간을 출력한다. 반환값은 0 이다.</li>
</ul>
</li>
<li><p><code>trap [-l] [인수] [시그널스펙]</code><br>  쉘이 시그널스펙 이 가리키고 있는 시그널을 받으면 인수로 주어진 명령을 읽어 실행하도록 한다. 인수 가 없거나 - 이면, 제시한 모든 시그널에 대하여 원래의 값으로 돌아간다. (즉 쉘을 시작했을 때의 값) 인수가 널 문자열이면 쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다. 시그널스펙은 <signal.h>에 정의되어 있으면 시그널 이름이거나, 시그널 번호이다. 시그널스펙 이 EXIT (0) 이면 인수로 주어진 명령을 쉘 종료시에 실행한다. 아무런 인수도 없으면, trap 은 각 시그널 번호와 연관된 명령 목록을 출력한다. -l 옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. 쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다. 가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다. 가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 trap 은 참을 반환한다.</signal.h></p>
</li>
<li><p><code>type [-all] [-type | -path] 이름 [이름 ...]</code><br>  옵션없이 사용하면, 이름 이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다. -type 플래그를 사용하면, type 은 이름 이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때, alias, keyword, function, builtin, 그리고 file 중 하나를 출력한다. 이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다. -path 플래그를 사용하면, type 은 이름 이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나, -type 이 file 을 반환하지 않을 때에는 아무 것도 반환하지 않는다. 명령이 해쉬된 상태이면, -path 는 PATH 상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다. -all 플래그를 사용하면, type 은 이름 이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다. -path 플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다. -all 을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다. type 은 -all, -type, 과 -path 대신 각각 -a, -t, 과 -p 를 받아들인다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. type 은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을 반환한다.</p>
</li>
<li><p><code>ulimit [-SHacdfmstpnuv [제한]]</code><br>  Ulimit 은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여 사용 자원을 제한할 수 있도록 해 준다. 제한 값은 각 자원에 대한 단위 값이거나 unlimited 라는 값을 가질 수 있다.    H와 S 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다. 하드 제한은 일단 설정되면 더 이상 늘릴 수 없다; 한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다. H 와 S 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고 간주한다. 제한을 생략하면 H 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다. 여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다. 기타 다른 옵션은 다음과 같이 해석한다:<br>  -d     프로세스의 데이터 세그먼트의 최대 크기<br>  -f     쉘이 만들 수 있는 파일의 최대 크기<br>  -m     상주 설정(resident size) 최대 크기<br>  -s     최대 스택 크기<br>  -t     초 단위의 최대 CPU 시간<br>  -p     512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음)<br>  -n     열 수 있는 파일 기술자의 최대 크기 (대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.)<br>  -u     단일 사용자에게 허용하는 프로세스 최대 갯수<br>  -v     쉘에 허용하는 가상 메모리의 최대량<br>  – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다. 제한 이 주어지면, 명시한 자원에 대한 새로운 값이 된다.( -a 옵션은 표시할 때만 사용한다.) 아무런 옵션도 없으면 -f 로 간주한다. 값은 초 단위의 -t, 512 바이트의 블럭 단위인 -p, 그리고 단위가 없는 -n 과 -u 를 제외하고, 1024 바이트 단위로 생각한다. 잘못된 옵션이 있거나, 제한 값에 unlimited 이외의 수치 아닌 인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고 반환 상태값은 0 이다.</p>
</li>
<li><p><code>umask [-S] [모드]</code><br>  사용자 파일 생성 매스크를 모드로 설정한다. 모드가 숫자로 시작하면 8 진수로 해석한다. 그렇지 않으면 chmod(1) 와 비슷한 심볼릭 매스크로 해석한다. 모드 를 생략하거나, -S 옵션을 적으면, 현재의 매스크 값을 출력한다. -S 옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다; 기본 출력 형태는 8 진수이다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. 모드를 성공적으로 변경하거나 아무런 모드 값도 적지 않으면 반환 상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다.</p>
</li>
<li><p><code>unalias [-a] [이름 ...]</code><br>  정의된 앨리어스 목록에서 이름을 제거한다. -a 를 적으면 모든 앨리어스 정의를 제거한다. 적은 이름 이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다.</p>
</li>
<li><p><code>unset [-fv] [이름 ...]</code><br>  각각의 이름 에 대하여, 해당하는 변수를 제거하거나, -f 옵션의 경우 함수를 제거한다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. PATH, IFS, PPID, PS1, PS2, UID, 그리고 EUID 는 unset할 수 없다. RANDOM, SECONDS, LINENO, 또는 HISTCMD 중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을 잃게 된다. 이름 이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다.</p>
</li>
<li><p><code>wait [n]</code><br>  특정 프로세스를 기다리다가 종료값을 반환한다. n 은 프로세스 ID이거나 작업 스펙이다; 작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다. n 을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다. n 이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다. 그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이 된다.</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/cd/">cd</a><a href="/tags/pwd/">pwd</a><a href="/tags/bg/">bg</a><a href="/tags/fg/">fg</a><a href="/tags/fc/">fc</a><a href="/tags/echo/">echo</a><a href="/tags/exec/">exec</a><a href="/tags/kill/">kill</a><a href="/tags/umask/">umask</a><a href="/tags/export/">export</a><a href="/tags/source/">source</a><a href="/tags/logout/">logout</a><a href="/tags/리다이렉션/">리다이렉션</a><a href="/tags/파이프라인/">파이프라인</a></div><div class="post-nav"><a href="/2017/10/29/centos-외부명령어/" class="pre">외부명령어</a><a href="/2017/10/29/centos-내부명령어와-외부명령어/" class="next">내부명령어와 외부명령어</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'korcow-github-io';
var disqus_identifier = '2017/10/29/centos-내부명령어/';
var disqus_title = '내부명령어';
var disqus_url = 'http://korcow.github.io/2017/10/29/centos-내부명령어/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//korcow-github-io.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 카테고리</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Centos/">Centos</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C언어기초/">C언어기초</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 태그</i></div><div class="tagcloud"><a href="/tags/cat/" style="font-size: 15px;">cat</a> <a href="/tags/Centos/" style="font-size: 15px;">Centos</a> <a href="/tags/외부명령어/" style="font-size: 15px;">외부명령어</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/cd/" style="font-size: 15px;">cd</a> <a href="/tags/pushd/" style="font-size: 15px;">pushd</a> <a href="/tags/popd/" style="font-size: 15px;">popd</a> <a href="/tags/pwd/" style="font-size: 15px;">pwd</a> <a href="/tags/bg/" style="font-size: 15px;">bg</a> <a href="/tags/fg/" style="font-size: 15px;">fg</a> <a href="/tags/fc/" style="font-size: 15px;">fc</a> <a href="/tags/echo/" style="font-size: 15px;">echo</a> <a href="/tags/exec/" style="font-size: 15px;">exec</a> <a href="/tags/kill/" style="font-size: 15px;">kill</a> <a href="/tags/umask/" style="font-size: 15px;">umask</a> <a href="/tags/export/" style="font-size: 15px;">export</a> <a href="/tags/source/" style="font-size: 15px;">source</a> <a href="/tags/logout/" style="font-size: 15px;">logout</a> <a href="/tags/리다이렉션/" style="font-size: 15px;">리다이렉션</a> <a href="/tags/파이프라인/" style="font-size: 15px;">파이프라인</a> <a href="/tags/내부명령어/" style="font-size: 15px;">내부명령어</a> <a href="/tags/directory/" style="font-size: 15px;">directory</a> <a href="/tags/디렉토리/" style="font-size: 15px;">디렉토리</a> <a href="/tags/cp/" style="font-size: 15px;">cp</a> <a href="/tags/centos/" style="font-size: 15px;">centos</a> <a href="/tags/virtualbox/" style="font-size: 15px;">virtualbox</a> <a href="/tags/리눅스설치/" style="font-size: 15px;">리눅스설치</a> <a href="/tags/와일드카드/" style="font-size: 15px;">와일드카드</a> <a href="/tags/terminal/" style="font-size: 15px;">terminal</a> <a href="/tags/ls/" style="font-size: 15px;">ls</a> <a href="/tags/head/" style="font-size: 15px;">head</a> <a href="/tags/tail/" style="font-size: 15px;">tail</a> <a href="/tags/rm/" style="font-size: 15px;">rm</a> <a href="/tags/rmdir/" style="font-size: 15px;">rmdir</a> <a href="/tags/history/" style="font-size: 15px;">history</a> <a href="/tags/Vim/" style="font-size: 15px;">Vim</a> <a href="/tags/vundle/" style="font-size: 15px;">vundle</a> <a href="/tags/ctrlp/" style="font-size: 15px;">ctrlp</a> <a href="/tags/solarized/" style="font-size: 15px;">solarized</a> <a href="/tags/theme/" style="font-size: 15px;">theme</a> <a href="/tags/bundle/" style="font-size: 15px;">bundle</a> <a href="/tags/Vundle/" style="font-size: 15px;">Vundle</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/bash/" style="font-size: 15px;">bash</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/font/" style="font-size: 15px;">font</a> <a href="/tags/less/" style="font-size: 15px;">less</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/사칙연산/" style="font-size: 15px;">사칙연산</a> <a href="/tags/자료형/" style="font-size: 15px;">자료형</a> <a href="/tags/변수/" style="font-size: 15px;">변수</a> <a href="/tags/상수/" style="font-size: 15px;">상수</a> <a href="/tags/printf/" style="font-size: 15px;">printf</a> <a href="/tags/주석/" style="font-size: 15px;">주석</a> <a href="/tags/컴파일/" style="font-size: 15px;">컴파일</a> <a href="/tags/이스케이프문자/" style="font-size: 15px;">이스케이프문자</a> <a href="/tags/puts/" style="font-size: 15px;">puts</a> <a href="/tags/putchar/" style="font-size: 15px;">putchar</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 과거</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/c-c언어를-시작하며/">c언어를 시작하며</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/c-간단한-계산하기/">간단한 계산하기</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/c-목차/">C언어 목차</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/c-화면에-글자-출력하기/">화면에 글자 출력하기</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/hexo-d2coding/">d2coding font</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/hexo-한글파일명/">Hexo 한글파일명 문제점</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/centos-파일내용보기/">파일내용보기</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/centos-파일및디렉토리삭제/">파일및디렉토리삭제</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/centos-bash/">Bash</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/centos-외부명령어-요약/">외부명령어 요약</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 최근 댓글</i></div><script type="text/javascript" src="//korcow-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 블로그롤</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">KORCOW.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>