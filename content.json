{"meta":{"title":"KORCOW","subtitle":"HANS","description":"테스트","author":"woo-seok Han","url":"http://korcow.github.io"},"pages":[{"title":"","date":"2017-11-03T18:04:58.115Z","updated":"2016-11-30T14:44:46.000Z","comments":true,"path":"font/d2coding.css","permalink":"http://korcow.github.io/font/d2coding.css","excerpt":"","text":"/* * D2 coding (Korean) http://dev.naver.com/projects/d2coding/ */ @font-face { font-family: 'D2 coding'; font-style: normal; font-weight: 700; src: url('d2codingbold.eot'); src: local('※'), local('D2Coding Bold'), url('d2codingbold.eot?#iefix') format('embedded-opentype'), url('d2codingbold.woff2') format('x-woff2'), url('d2codingbold.woff') format('woff'), url('d2codingbold.ttf') format('truetype'), url('d2codingbold.svg') format('svg'); } @font-face { font-family: 'D2 coding'; font-style: normal; font-weight: 400; src: url('d2coding.eot'); src: local('※'), local('D2Coding'), url('d2coding.eot?#iefix') format('embedded-opentype'), url('d2coding.woff2') format('x-woff2'), url('d2coding.woff') format('woff'), url('d2coding.ttf') format('truetype'), url('d2coding.svg') format('svg'); }"},{"title":"","date":"2017-11-03T18:04:58.141Z","updated":"2016-11-30T14:44:46.000Z","comments":true,"path":"font/readme.html","permalink":"http://korcow.github.io/font/readme.html","excerpt":"","text":"D2Coding Web Fonts D2Coding Web Font who careted by NAVER Corp. LicenseCopyright &copy; NAVER Copr. All Rights Reserved. OFL(Open Font License) THE FONT SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENTOF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THECOPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIALDAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROMOTHER DEALINGS IN THE FONT SOFTWARE. Font informationWeights Bold (700) Normal (400) Support type eot woff woff2 ttf InstallationInsert d2coding.css or create @font-face css to HTML: 1&lt;link href=\"/path/d2coding.css\" rel=\"stylesheet\" type=\"text/css\"&gt; or 123456789101112131415161718192021222324@font-face &#123; font-family: 'D2 coding'; font-style: normal; font-weight: 700; src: url('/path/d2codingbold.eot'); src: local('※'), local('D2Coding Bold'), url('/path/d2codingbold.eot?#iefix') format('embedded-opentype'), url('/path/d2codingbold.woff2') format('x-woff2'), url('/path/d2codingbold.woff') format('woff'), url('/path/d2codingbold.ttf') format('truetype'), url('/path/d2codingbold.svg') format('svg');&#125;@font-face &#123; font-family: 'D2 coding'; font-style: normal; font-weight: 400; src: url('/path/d2coding.eot'); src: local('※'), local('D2Coding'), url('/path/d2coding.eot?#iefix') format('embedded-opentype'), url('/path/d2coding.woff2') format('x-woff2'), url('/path/d2coding.woff') format('woff'), url('/path/d2coding.ttf') format('truetype'), url('/path/d2coding.svg') format('svg');&#125; Adding to CSS: 123body &#123; font-family: D2Coding, 'D2 coding', monosapce;&#125; first, search local D2Coding font and next call D2 conding web font, and last load monospace"}],"posts":[{"title":"Hexo 한글파일명 문제점","slug":"hexo-한글파일명","date":"2017-11-07T03:23:58.568Z","updated":"2017-11-07T03:23:58.568Z","comments":true,"path":"2017/11/07/hexo-한글파일명/","link":"","permalink":"http://korcow.github.io/2017/11/07/hexo-한글파일명/","excerpt":"","text":"Hexo 한글오류이하 내용은 Hexo를 커스텀하다 꼬여서 발생한 문제를 해결하면서 얻은 경험입니다.( 정확하게 소스분석을 하지 않았다는 겁니다.) Hexo에서 _Post의 관리는 generator가 md파일을 감시하고 있다 변경이 되면 변경 상태에 따라 html, category, tag, archives 다시 만들어주고 deploy는 .deploy디렉토리에 add, commit, push 동작을 하는것 같습니다. 추측이지만 generator가 한글파일의 감시를 제대로 못해주는 것 같습니다. 감시는 파일명, 내용수정에 따라 동작이 달라지는것 같습니다. 요점: 404오류, archives, Tag, Category, Search, index.html에서 링크오류가 나온다면 파일명과 내용을 수정하면 100% 해결 되었습니다. 변경내용이 반영되지 않을 경우, 간혹 github이 바빠서 그럴 수 있으니 새로고침 몇번 해보고, 조금 기다려 보고 github에 해당 post가 업로드되었는지 확인. 업로드가 안됐을 경우 hexo clean 후 hexo g -d 하면 99%는 해결 됩니다. 1%는 삽질이 필요합니다. 1%의 빈도수는 거의 없으니 안심하시길… github.io는 무료이고 조금 느림을 항상 명심. 삽질 경험담: archive가 반영이 안될때는 파일명을 변경하면 된다. Post의 변경 반영이 안되는 경우hexo n &quot;포스트명&quot; 또는 hexo new &quot;포스트명&quot; 으로 포스트를 생성해서 사용하다 수정을 했음에도 반영이 안되는 경우가 종종 있다.이때는 git의 캐시 때문일 수 있으니 5분 정도 기다려 보고, 그래도 안되면 아래처럼 적용을 해준다.hexo clean /blog/Public 디렉토리 삭제hexo g -d하면 문제가 해결된다그래도 안되는 경우 파일명을 바꾸어 준다. 탐색기나 finder에서 바꾸면 안됨(내 경험상)mv 한글.md 한글x.mdhexo g -d변경을 확인하고 변경이 잘 되면 원래대로 이름을 바꾸고 hexo g -d그래도 안되면 내용을 수정hexo g -d여기 까지 했는데도 안되면 최후의 수단.deploy로 이동후git rm -rf *git commit -m &quot;삭제&quot;git push화일명을 변경, 내용도 수정hexo g -d영어의 대소문자가 혼재(윈도우와 맥에서는 오류가 날 수 있음) 소문자로 바꾸길… Post가 2개로 보일때이증상은 대부분 로컬서버에서 생기는 것 같다.hexo cleanhexo g -dhexo server -s 오류없이 사용하려면 Post명을 영어로 사용을 권장. Hexo의 단점은 post가 많아 지면 관리가 힘듬. Hexo의 단점을 조금이라도 보완 하려면 vim과 ctrlP 사용이 정답. 또는 파일명 앞에 카테고리 이름을 붙여주면 그나마 쓸만함. 참고 : windows와 macos는 기본적으로 대소문자를 구분하지 않습니다. linux와 Unix는 대소문자를 구분합니다. 한글파일명은 공백없이 사용하는 것이 원칙, 공백을 사용하면 공백앞에 \\가 자동으로 붙고 파일 시스템에서 \\처리 때문에 문제가 발생할 수 있습니다. 설마 개발자가 파일명에 공백을 넣는 다면 os 공부가 필요 전산 전공을 하지 않은 개발자 일 수 있겠네요. 개발자가 아니라면 가능한 파일명에는 공백을 넣지 말고 - 또는 _를 넣으세요. 파일명에는 특수문자를 넣지 마세요. 한글 파일명을 사용해야 한다면 “한글파일명.md” 처럼 따옴표 안에 넣으세요.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://korcow.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://korcow.github.io/tags/hexo/"}]},{"title":"if문 사용하기","slug":"c-if문","date":"2017-11-07T03:07:08.049Z","updated":"2017-11-07T03:07:08.049Z","comments":true,"path":"2017/11/07/c-if문/","link":"","permalink":"http://korcow.github.io/2017/11/07/c-if문/","excerpt":"","text":"if문if 명령은 조건을 판단해서 참일 경우 또는 거짓 일경우 분기를 하기 위해 사용하는 명령입니다. 123// 실행 명령이 1줄일 경우if (조건) 참인 경우 실행 명령1; 조건을 판단해서 참인 경우 다음 문장을 수행합니다. 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char *argv[]) &#123; int iNum1 = 10; int inum2 = 20; if (iNum1 &gt; iNum2) printf(\"%d은 %d보다 큽니다.\\n\", iNum1, iNum2); printf(\"%d은 %d보다 작습니다.\\n\", iNum1, iNum2); return 0;&#125; 1234567891011#include &lt;stdio.h&gt;int main(int argc, const char *argv[]) &#123; int iNum1 = 10; int inum2 = 20; if (iNum1 &gt; iNum2) printf(\"%d은 %d보다 큽니다.\", iNum1, iNum2); // if문이 참인경우 실행 printf(\"%d은 %d보다 작습니다.\", iNum1, iNum2); return 0;&#125; 위와 같이 같은 줄에 붙여 써도 됩니다. 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char *argv[]) &#123; int iNum1 = 10; int inum2 = 20; if (iNum1 &gt; iNum2) printf(\"%d은 %d보다 큽니다.\", iNum1, iNum2); //if문이 참인경우 실행 printf(\"%d은 %d보다 작습니다.\", iNum1, iNum2); //if문과 관계없이 실행 return 0;&#125; 위와 같이 사용해도 결과는 문제 없이 나옵니다. 문법적으로 오류가 없기 때문이죠. 참인 경우 다음 한줄을 실행한 다고 했습니다. 하지만 절대 위와 같이 사용하면 프로그램 분석 하는데 불편합니다. 들여쓰기를 잘해야 소스를 읽기가 편합니다. 오류를 찾기도 쉽구요. 아래와 같이 써도 전혀 문제 없습니다.123#include &lt;stdio.h&gt; int main(int argc, const char *argv[]) &#123; int iNum1 = 10; int inum2 = 20; if (iNum1 &gt; iNum2) printf(\"%d은 %d보다 큽니다.\", iNum1, iNum2); printf (\"%d은 %d보다 작습니다.\", iNum1, iNum2); return 0; &#125; 읽기가 매우 힘들죠. ^^ 12345// 실행 명령이 여러줄 일 경우if (조건)&#123; 명령1; 명령2;&#125; 조건이 참일 경우 여러줄을 실행해야 한다면 위와 같이 사용할 수 있습니다.12345678910111213#include &lt;stdio.h&gt;int main(int argc, const char *argv[]) &#123; int iNum1 = 30; int inum2 = 20; if (iNum1 &gt; iNum2)&#123; printf(\"30과 20을 비교하면: \"); printf(\"%d은 %d보다 큽니다.\", iNum1, iNum2); &#125; return 0;&#125; 123456789// 조건이 참이 아닐 경우 else를 실행if (조건)&#123; //참인경우 실행 명령1; 명령2;&#125;else&#123; // 참인 아닌경우 실행 명령1; 명령2;&#125; 위 문장은 if 조건이 참이 아닌경우 else문을 실행하도록 할 때 사용합니다. 123456789101112// 다중 if ~ elseif (조건)&#123; 명령1; 명령2;&#125;else if(조건)&#123; 명령1; 명령2;&#125;else&#123; 명령1; 명령2;&#125;","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c","slug":"c","permalink":"http://korcow.github.io/tags/c/"},{"name":"if","slug":"if","permalink":"http://korcow.github.io/tags/if/"},{"name":"else","slug":"else","permalink":"http://korcow.github.io/tags/else/"},{"name":"if~else","slug":"if-else","permalink":"http://korcow.github.io/tags/if-else/"}]},{"title":"C언어 목차","slug":"c-목차","date":"2017-11-06T14:53:46.848Z","updated":"2017-11-06T14:53:46.849Z","comments":true,"path":"2017/11/06/c-목차/","link":"","permalink":"http://korcow.github.io/2017/11/06/c-목차/","excerpt":"","text":"목차c언어 기초c언어는 가장 기초가 되는 프로그래밍 언어로 c++, objective c, java, python등의 언어로 접근하기 위한 필수 프로그램입니다. 가장 쉬운 언어 이면서, 가장 어려운 언어 기기도 합니다. 어렵다는 것은 시스템 제어를 새로 만들거나, os, 프로그램 language를 새로 만들때 해당 됩니다. 그외는 전혀 어렵지 않습니다. 이미 만들어져 있는 것을 응용해서 사용하면 됩니다. shell 프로그래밍으로도 프로그램 작성이 가능하지만 c언어가 더 강력하고 빠릅니다. c언어가 빠르고 강력하지만 라이브러리가 많이 부족한 편입니다. 직접 만들어야 하죠. 그래서 python, c++, java를 선호하는 겁니다. 필요하다고 생각되는건 누군가 이미 만들어 놨기 때문이죠. 이번에 진행하는 c언어는 linux에서 gcc, vim, bash shell을 이용해 진행됩니다. 조금 산만 할 수도 있지만 난이도를 낮추고 모두를 설명하는 것이 프로그래밍의 숲을 볼 수 있는 방법인것 같습니다. 프로그래밍의 특성상 문법을 강조하면 무엇을 하는건지, 어디에 써야 하는건지, 무조건 외워야 하는건지, 종잡을 수 없습니다. 쉽게 흥미를 잃어버릴 수 있습니다. 앏고 넓게 학습하는 것이 목표입니다. 실습환경 설정 virtualbox에 centos설치 - Centos참조 gvim 설치및 vimrc 세팅 - vim참조 vim 기본 사용법 - vim참조 c언어를 시작하며 기본적으로 알아 두면 좋은 내용들을 정리 했습니다. 화면에 글자 출력하기 putchar() puts() printf() 간단한 계산하기 printf 함수를 이용한 사칙연산 변수와 상수를 사용. 자료형, 연산자 키보드로 입력 받기 getchar() gets() scanf() getch() if문 사용하기while 문for 문배열인자로 입력 받기파일 입출력switch case 문 사용하기do while 문loop 문함수 만들기표준 라이브러리구조체 사용하기포인터유니온maloccursesoracle 연결주소록 만들기학사관리 만들기","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c","slug":"c","permalink":"http://korcow.github.io/tags/c/"}]},{"title":"실습 환경 설정","slug":"c-실습-환경-설정","date":"2017-11-06T14:49:36.952Z","updated":"2017-11-06T14:49:36.952Z","comments":true,"path":"2017/11/06/c-실습-환경-설정/","link":"","permalink":"http://korcow.github.io/2017/11/06/c-실습-환경-설정/","excerpt":"","text":"실습 환경 설정 virtualbox에 centos설치 - Centos참조 gvim 설치및 vimrc 세팅 - vim참조 vim 기본 사용법 - vim참조","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c,","slug":"c","permalink":"http://korcow.github.io/tags/c/"}]},{"title":"c언어를 시작하며","slug":"c-c언어를-시작하며","date":"2017-11-06T08:10:26.717Z","updated":"2017-11-06T08:10:26.717Z","comments":true,"path":"2017/11/06/c-c언어를-시작하며/","link":"","permalink":"http://korcow.github.io/2017/11/06/c-c언어를-시작하며/","excerpt":"","text":"기본적으로 알아두어야 할 것을 정리 해봤습니다. C언어의 역사 1963년 - ALGOL 60에서 CPL이 파생 1969년 - BCPL 개발 1970년 - B 언어 개발 1972년 - 벨 연구소 (Bell Laboratories) 에 있는 Dennis Ritchie가 B의 후속으로 C 개발 1983년 - 미국 국가 표준 협회(ANSI, American National Standards Institute) 에서 짐 브로디(Jim Brodie) 주축으로 X3J11 위원회 소집 1983년 12월 14일 - ANSI X3.159-1989 라는 공식명칭으로 C 언어 표준 지정 1999년 - C99 표준안이 ISO/IEC 9899:1999라는 명칭으로 출간됨 2000년 5월 - ANSI의 표준으로 C99가 채택됨 2011년 - 12월 8일 C11 표준안이 ISO/IEC 9899:2011라는 명칭으로 출간됨 C언어는 모든 프로그램의 기본 c언어는 Asambler로 뼈대를 만들었습니다. 만들어진 기본 c언어로 각종 명령과 라이브러리를 만들었습니다. 모든 프로그래밍 언어는 c언어로 만듭니다. python은 c언어로 기본 뼈대를 만들고 만들어진 python 프로그램으로 각종 함수 및 라이브러리를 만듭니다. 만들어진 python으로 python을 만듭니다. 이름를 pypy라고 붙였습니다. c++, java, rube, 모든 언어가 똑같습니다. 모든 os는 Asambler로 뼈대를 만들고 c언어로 만듭니다. 저급언어기계어12345677F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00 02 00 03 00 01 00 00 00 35 40 B3 04 2C 00 00 00 00 00 00 00 00 00 00 00 34 00 20 00 01 00 00 00 00 00 00 00 00 40 B3 04 B2 0C EB 1C 62 00 00 00 62 00 00 00 05 00 00 00 00 10 00 00 48 65 6C 6C 6F 20 77 6F 72 6C 64 0A B9 4C 40 B3 04 93 CD 80 EB FB 위 소스는 리눅스x86 16bit cpu에서 hello world를 찍는 기계어입니다.64bit cpu에서는 코딩 불가 위에처럼 528줄 이나 써야 되네요. ^^; 8bit apple computer에서 기계어 코딩하는 동영상 입니다.ascii와 hello world를 힘들게 찍네요.appleII는 롬베이직이 바로 뜨는데… 어셈블리어 어셈블리어 123456789101112131415161718section .textglobal _start ;must be declared for linker (ld)_start: ;tell linker entry point mov edx,len ;message length mov ecx,msg ;message to write mov ebx,1 ;file descriptor (stdout) mov eax,4 ;system call number (sys_write) int 0x80 ;call kernel mov eax,1 ;system call number (sys_exit) int 0x80 ;call kernelsection .datamsg db &apos;Hello, world!&apos;,0xa ;our dear stringlen equ $ - msg ;length of our dear string 위 소스는 hello world를 찍는 어셈블리어 소스 입니다. 고급언어algolcperlc++javapython 123456789#include &lt;stdio.h&gt; //전처리 표준 출력을 위해 호출 //구조체는 사용안하므로 안썼음. //함수선언 사용자 함수가 없으므로 안썼음.int main(void) // 메인함수&#123; printf(\"%s\", \"hello world!\\n\"); //프로그램 작성 // 위 함수도 약속에 의해 작성함. return 0; // 리턴값&#125; c 언어로 hello world를 출력하는 소스1print(\"hello world\") python으로 hello world를 출력하는 소스 발전된 고급언어 일수록 사용하기가 훨씬 쉽습니다. 컴파일러와 인터프리터컴파일러는 소스 전체를 실행 가능한 기계어로 바꾸줍니다.assmbly, c, java, c++ 등 인터프리터는 소스를 실행시 인터프리터가 한줄씩 기계어로 번역하며 실행합니다.perl, python, ruby, html, javascript 등 인간의 언어인간의 언어는 단어와 문장이 있습니다.문장을 구성하는 요소도 있고 형식도 있습니다.형식이란 말하는 순서를 뜻하죠.순서를 틀리게 말해도 대부분은 무슨 뜻인지 이해 할 수 있습니다.인간이기 때문에 상황을 파악하고, 오류를 수정해서 듣기 때문입니다. 단어 명사 동사 사과 먹다 apple eat 나 오다 I 입다 문장의 형식12345678한국어 : 주어 + 목적어 + 동사형식 나(는) 사과(를) 먹(는)다(비형식) 나 먹다 사과(비형식) 몸짓으로 전달영어 : 주어 + 동사 + 목적어 형식 I (am) eat(ing) (a) apple(비형식) I apple eat 인간은 위와 같이 단어와 형식을 지키지 않은 비형식으로 말해도 이해 할 수 있습니다. 하지만 프로그래밍 언어는 철저하게 형식과 문법을 지키지 않으면 오류가 납니다. C 언어C 언어도 형식과 단어가 있습니다.일반적으로 형식은 스트럭쳐(structure), 단어는 토큰(Token)라고 부릅니다. 형식12345678910111213전처리구조체함수선언반환형 main(인자)&#123; 프로그램 기술 반환값;&#125;반환형 함수명()&#123; 반환값;&#125; 형식은 위와 같이 쓰자고 약속 했습니다. 처음에 전처리, 구조체, 함수선언, 메인함수, 선언한 함수 본체를 기술하자고 약속한 겁니다. 다른것은 필요 없으면 안써도 되지만 메인함수는 반드시 쓰자. 함수를 쓸때는 함수명 앞에 반환자료형을 꼭 쓰자. 메인함수안에 인자가 필요하면 인자를 쓰고, 없으면 안써도 되지만 void를 넣자. 프로그램은 중괄호 안에 기술하자. 함수가 끝나기 전에 반환값이 있다면 반환값을 쓰자. 명령이 끝나면 반드시 ;를 쓰자. 이렇게 약속을 했는데 안지키면 안되겠죠. 아래는 약속에 맞춰서 최소한의 코딩을 한겁니다. c언어123456789#include &lt;stdio.h&gt; //전처리 표준 출력을 위해 호출 //구조체는 사용안하므로 안썼음. //함수선언 사용자 함수가 없으므로 안썼음.int main(void) // 메인함수&#123; printf(\"%s\", \"hello world!\\n\"); //프로그램 작성 // 위 함수도 약속에 의해 작성함. return 0; // 리턴값&#125; 토큰토큰은 표식(징표, 표시)이라고 할 수 있습니다.버스, 지하철을 탈때 토큰을 내고 타죠? (현금, 카드찍는 행위, 탑승티켓등…)상품을 구매할때 화패, 카드, 쿠폰을 내고 구매를 합니다. 이렇게 의미(가치)가 표시된 것들을 통틀어 영어로 토큰이라고 부릅니다. C언어의 토큰은 keyword(예약어), 연산자, 구두점(부호), 식별자, 상수가 있습니다.32개의 예약어, 40여개의 연산자, 10개의 구두점, 여러분이 생성하는 함수명, 변수명, 상수명이 다 입니다.외울 필요도 없습니다. 쓰다 보면 저절로 외워집니다.어떤것이 있는지 한번 훑어 보세요. 예약어 no keyword 설명 1 auto 기본적인 변수의 저장방식을 나타내는 키워드 2 break for, while, switch, do…while문을 조건없이 마치는 명령 3 case switch문 내에서 사용되는 명령 4 char 문자를 저항하는 데이터형 5 const 상수 지정자 6 continue for, while, switch, do…while문을 다음 반복동작으로 진행시키는 명령 7 default case문에 일치하지 않는 경우를 처리하기 위해 switch문에서 사용되는 명령 8 do while문과 함께 사용되는 순환명령. 순환문은 최소한 한번 실행됨. 9 double 배정도 부동 소수형값을 저장할 수 있는 데이터형 10 else if문이 FALSE 때 실행되는 선택적인 문장을 나타내는 명령 11 enum 변수가 특정값만을 받아들이도록 해주는 데이터형 12 extern 변수가 프로그램의 다른 부분에서 선언된다는 것을 알려주는 데이터 지정자 13 float 부동 소수형 숫자값을 저장하기 위해 사용되는 데이터형 14 for 초기화,증가,조건 부분을 가지는 순환명령 15 goto 정의되어 있는 레이블로 이동시키는 명령 16 if TRUE/FALSE의 결과에 따라 프로그램의 제어를 변경하는데 사용되는 명령 17 int 정수형 값을 저장하는 데 사용되는 데이터형 18 long int형보다 큰 정수형 값을 저장하는 데 사용되는 데이터형 19 register 가능하다면 변수를 레지스터에 저장하도록 지정하는 저장형태 지정자 20 return 함수를 종료후 호출한함수로 프로그램의 제어와 값을 반환 하는 명령. 21 short short 정수형 값을 저장하는 데 사용되는 데이터형. 22 signed 변수가 양수와 음수값을 모두 저장할 수 있음. 23 sizeof 항목의 크기를 바이트 단위로 알려주는 연산자 24 static 컴파일러가 변수의 값을 보존해야 한다는 것을 지정하는 지정자 25 struct C에서 어떤 데이터형의 변수를 함께 결합시키는 데 사용되는 키워드 26 switch 여러 조건을 통해서 프로그램의 흐름을 변경하는 데 사용되는 명령. 27 typedef 이미 존재하는 변수와 함수의 형태를 새로운 변경하는 지정자 28 union 여러 개의 변수가 동일한 메모리 영역을 공유하도록 해주는 키워드 29 unsigned 변수가 양수값만 저장할 수 있다는 것을 지정하는 데 사용되는 지정자. 30 void 함수의 반환값이 없는 것을 지정하는 데 사용되는 키워드 31 volatile 변수가 변경될 수 없다는 것을 지정하는 지정자. 32 while 지정된 조건이 TRUE 한 계속해서 포함된 문장을 실행하는 순환문 연산자 우선 순위 결합 방향 연산자(기호) 연산자종류/명 1 → ( ), [ ], ., -&gt; 소괄호, 대괄호, 도트, 포인터 2 ← (형), sizeof, *(참조), &amp; 주소, ++, --, +(부호), -(부호),~, ! 단항연산자 3 → *(곱셈), /, % 산술연산자 4 → +, - 산술연산자 5 → &lt;&lt;, &gt;&gt; shift연산자 6 → &lt;, &lt;=, &gt;, &gt;= 관계연산자 7 → ==, != 관계연산자 8 → &amp; 비트연산자 9 → ^ 비트연산자 10 → &#124; 비트연산자 11 → &amp;&amp; 논리연산자 12 → &#124;&#124; 논리연산자 13 ← ?: 조건연산자 14 ← =, +-, -=, *=, /=, %=, &lt;&lt;=,&gt;&gt;=,&amp;=,^=,=&#124; 할당/복합 할당연산자 15 → , 콤마연산자 산술연산자, 논리연사자, 대입연산자, 관계연산자, 비트연산자, 조건연산자, cast연산자, 증감연산자, 기타연산자 구두점 구두점 명칭 [] bracket, 대괄호 {} brace, 중괄호 () parenthesis, 소괄호 * asterisk, 별표 , comma, 쉼표 ; semicolon, 세미콜론 = equal sign : colon, 콜론 ... ellipsis, 생략부호 # sharp, 샵 주석주석은 프로그램 소스내에 간단한 설명을 적을 수 있습니다. 자신, 또는 타인이 소스를 분석할 때 도움이 되겠죠. 처음에 프로그램의 설명을 적는것은 프로그래머들 간의 약속 입니다.리눅스에서 head 명령어가 있는 이유 이기도 합니다.주석은 실행 되지 않으며 프로그램 중간중간에 넣어서 사용할 수 있습니다. 한줄 주석123456789101112// 프로그램명: helloworld// 작성자 : 홍길동, abc@google.com// 작성일 : 2016-11-04// 수정일 : 2017-11-04// 사용법 : helloworld [옵션] // 설명 : 이 프로그램은 hello wrld를 화면에 출력해주는 프로그램입니다.int main(int argc, const char *argv[])&#123; // 이곳에 프로그램을 입력 return 0;&#125; 한줄 주석은 위와 같이 사용합니다.줄 맨앞에 // 를 붙이면 됩니다. 여러줄주석1234567891011121314/* 프로그램명: helloworld작성자 : 홍길동, abc@google.com작성일 : 2016-11-04수정일 : 2017-11-04사용법 : helloworld [옵션] 설명 : 이 프로그램은 hello wrld를 화면에 출력해주는 프로그램입니다.*/int main(int argc, const char *argv[])&#123; // 이곳에 프로그램을 입력 return 0;&#125; 여러줄 주석은 위와 같이 사용합니다.주석의 시작과 종료 부분에 /* 와 */ 을 써주면 됩니다.주석의 중간에 설명을 추가하기는 편합니다만 한줄 주석을 권장합니다. vim 에디터를 실행합니다. 1$ vi print01.c","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c","slug":"c","permalink":"http://korcow.github.io/tags/c/"},{"name":"주석","slug":"주석","permalink":"http://korcow.github.io/tags/주석/"}]},{"title":"간단한 계산하기","slug":"c-간단한-계산하기","date":"2017-11-06T07:43:10.782Z","updated":"2017-11-06T07:43:10.782Z","comments":true,"path":"2017/11/06/c-간단한-계산하기/","link":"","permalink":"http://korcow.github.io/2017/11/06/c-간단한-계산하기/","excerpt":"","text":"간단한 계산하기 이번에는 printf 문을 이용해서 간단한 계산을 해보겠습니다. 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; printf(\"10 + 3 = %d\\n\", 10 + 3); printf(\"10 - 3 = %d\\n\", 10 - 3); printf(\"10 / 3 = %d\\n\", 10 / 3); // 정수 / 정수 = 정수 printf(\"10 / 3.0 = %.2f\\n\", 10 / 3.0); // 정수 / 실수 = 실수 printf(\"10 * 3 = %d\\n\", 10 * 3); printf(\"10 \\% 3 = %d\\n\", 10 % 3); //나머지 연산 printf(\"2 + 10 * 3 = %d\\n\", 2 + 10 * 3); // 우선순위 printf(\"(2 + 10) * 3 = %d\\n\", (2 + 10) * 3); // 우선순위 return 0;&#125; 우리가 알고 있는 간단한 수학 계산을 해보았습니다. 3을 2로 고쳐보세요.복붙을 사용해도 됩니다. 불편하지 않나요. 그럼 변수라는 것을 사용해 봅시다. 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; int a, b, d; // 정수형 변수 선언 float c // 실수형 변수 선언 // 초기값 입력 a = 10; b = 3; c = 3.0; d = 2; printf(\"%d + %d = %d\\n\", a, b, a + b); printf(\"%d - %d = %d\\n\", a, b, a - b); printf(\"%d / %d = %d\\n\", a, b, a / b); // 정수 / 정수 = 정수 printf(\"%d / %.2f = %.2f\\n\" a, c, a / c); // 정수 / 실수 = 실수 printf(\"%d * %d = %d\\n\" a, b, a * b); printf(\"%d \\% %d = %d\\n\" a, b, a % b); //나머지 연산 printf(\"%d + %d * %d = %d\\n\" a, b, d + a * b); // 우선순위 printf(\"(%d + %d) * %d = %d\\n\" a, b, (d + a) * b); // 우선순위 return 0;&#125; 변수를 이용해서 프로그램을 고쳤습니다. 이제 값을 바꾸어 보세요.값을 바꿀때는 일일히 printf문에서 고치지 않아도 됩니다.초기값 설정한 것을 고치면 됩니다. 훨씬 변경하기가 수월해 졌습니다. shell에서도 계산을 할 수 있습니다.1234$ echo $((2 + 3))$ echo $((2 / 3))$ echo $((2 - 3))$ echo $((2 * 3)) bc라는 계산기도 있습니다 복잡한 수학, 과학용 계산이 가능합니다.없다면 설치1234567891011#Centos$ sudo yum install bc#ubuntu$ sudo apt-get install bc#macos$ brew install bc$ echo \" 1 + 2\" | bc$ man bc vim도 인터프리터 입니다. 계산이 가능합니다. bc를 사용할 수도 있습니다.1234:echo 1+12 + 3 #계산식에 커서를 두고 :.!bc 상수일반적인 수를 상수라고 합니다. 변수명 작성변수명을 작성하는 규칙이 있습니다._를 제외한 특수문자가 있으면 안됩니다.공백이 있으면 안됩니다.의미 있는 단어로 작성해야 합니다.위와 같이 a, b, c, 이런식으로 작성하면 안됩니다.의미를 부여하기 힘들어도 최소한 iNum 정로로 만들어 줍니다.소문자 i는 int를 의미 합니다. 정수형 숫자라는 것을 알 수 있습니다.aNum은 배열 숫자, dNum은 더블형, fNum은 실수형 이런식으로 작성하면 좋습니다.그럼 변수명을 바꾸어 보세요. iNum1, iNum2, iNum3, fNum1 프로그램 작성을 편하게 하려고 변수를 사용합니다.변수는 몇가지 종류가 있습니다. 문자1자를 담을 수 있는 변수 정수를 담을 수 있는 정수형 변수 실수를 담을 수 있는 실수형 변수 변수형 설명 크기 문자형 char 1byte 정수형 boolean 1bit 정수형 int 4byte 정수형 long 8byte 실수형 float 4byte 실수형 double 8byte 자료형은 각각 다른 크기를 가집니다. 변수를 선언 할때 자료형을 먼저 정하고 변수명을 써줍니다.변수의 크기를 생각해서 자료형을 사용해야 합니다. 자주 사용하지 않는 자료형은 제외 했습니다. 배열과 포인터 변수는 뒤에 설명합니다. 다음은 정수형 자료가 표현 할 수 있는 크기를 확인 할 수 있는 프로그램입니다.123456789101112131415#include &lt;stdio.h&gt;#include &lt;limits.h&gt; int main()&#123; char cNum = CHAR_MIN; short shNum = SHRT_MIN; int iNum = INT_MIN; long lNum = LONG_MIN; long long llNum5 = LLONG_MIN; printf(\"%d %d %d %ld %lld\\n\", cNum, shNum, iNum, lNum, llNum); return 0;&#125; 다음은 실수형 자료가 표현 할 수 있는 크기를 확인하는 프로그램입니다. 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;float.h&gt;int main()&#123; float fNum1 = FLT_MIN; float fNum2 = FLT_MAX; double dNum3 = DBL_MIN; double dNum4 = DBL_MAX; long double ldNum5 = LDBL_MIN; long double ldNum6 = LDBL_MAX; printf(\"%.40f %.2f\\n\", fNum1); printf(\"%.40f %.2f\\n\", fNum2); printf(\"%e %e\\n\", dNum3, dNum4); printf(\"%Le %Le\\n\", ldNum5, ldNum6); return 0;&#125; 자료형은 시스템과 운영체제에 따라 크기가 다를 수 있습니다.꼭 사용할 수 있는 크기를 확인하고 사용해야 합니다. 오버플로우/언더플로우정수형 int 자료형은 -2,147,483,648 ~ 2,147,483,647 까지 표현가능 했습니다.2,147,483,647 에 1을 더하면 어떻게 될까요. 반대로 -2,147,483,648에서 -1을 하면 어떻게 되는지 확인해 보세요.","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c","slug":"c","permalink":"http://korcow.github.io/tags/c/"},{"name":"사칙연산","slug":"사칙연산","permalink":"http://korcow.github.io/tags/사칙연산/"},{"name":"자료형","slug":"자료형","permalink":"http://korcow.github.io/tags/자료형/"},{"name":"변수","slug":"변수","permalink":"http://korcow.github.io/tags/변수/"},{"name":"상수","slug":"상수","permalink":"http://korcow.github.io/tags/상수/"}]},{"title":"화면에 글자 출력하기","slug":"c-화면에-글자-출력하기","date":"2017-11-05T11:45:39.228Z","updated":"2017-11-05T11:45:39.228Z","comments":true,"path":"2017/11/05/c-화면에-글자-출력하기/","link":"","permalink":"http://korcow.github.io/2017/11/05/c-화면에-글자-출력하기/","excerpt":"","text":"화면에 글자 출력하기c언어는 함수로 시작해서 함수로 끝납니다. 모든 부품들이 함수로 만들어 져있습니다. c언어에서 화면에 출력을 하는 함수는 다음과 같습니다. putchar() 영문 1문자를 출력(한글 1문자는 영어 3문자와 같음. ms-windows는 2문자) puts() 문자열을 출력 prinf() 문자열을 출력(출력포맷을 정할 수 있음) 1문자 출력1234567#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; putchar('a'); // 한문자를 출력합니다. return 0;&#125; 1행은 선언문이라고 하는데 무언가를 화면에 출력할때, 입력받을때 반드시 사용한다고 알고 있으면 됩니다.위와 같이 프로그램을 작성했으면 저장을 하고 실행이 되도록 컴파일을 합니다.&lt;Esc&gt;:w&lt;Enter&gt; 저장&lt;Esc&gt;:q&lt;Enter&gt; vim종료 컴파일하고 실행하기12$ gcc print01.c -o print01.o # 컴파일$ ./print01.o # 실행 터미널에서 1행 처럼 컴파일 하고2행 처럼 실행을 하는 겁니다. 우리가 원하는데로 a가 잘 출력 되었습니다만 마지막에 %가 붙었습니다. 실제로 %가 붙은건 아니고 프롬프트와 겹쳐서 그렇게 보이는것 뿐입니다. 흔히 깨져 보인다고 하죠. 출력하고 줄바꾸기12345678#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; putchar('a'); putchar('\\n'); // 줄을 바꾸어주는 문자입니다. return 0;&#125; 12$gcc 01_a.c -o 01_a.o$./01_a.o 이번에는 6행을 보면 \\n을 추가했습니다. putchar는 1문자만 출력한다고 했는데. 두글자를 입력했습니다. \\n은 c언어가 1문자로 인식합니다. 줄을 바꾸어 주는 역할을 합니다. 이런 문자가 몇가지 더있는데 이를 이스케이프문자 라고 합니다. esc문자 설명 \\a beep음 \\b 백스페이스 \\f 폼 피드 \\n 줄바꿈 \\r 리턴(커서를 맨앞으로 이동) \\t 수평탭 \\v 수직탭 \\\\ \\출력 \\&#39; 작은따옴표(‘) \\&quot; 큰타옴표(“) \\? 물음표(?) 프로그래밍언어는 외우는게 아닙니다. 익히는 겁니다. 한번 봤으니 잊으세요.많이 쓰면 익혀 지니 걱정하지 마세요. Hello World 출력하기이번에는 putchar()를 가지고 Hello World를 출력해 볼까요.?복사와 붙여넣기는 코딩의 필수우리는 vim을 사용하니까 vim의 신공으로i&#39;h&#39;&lt;Esc&gt;yy15p커서를 맨앞에 놓고 &lt;C-v&gt;15jIputchar(&lt;Esc&gt;커서를 첫줄 p에 놓고 &lt;S-v&gt;15j:s/$/);/g&lt;Enter&gt; 이런 신공이 불편하다면 yy15p 하고 문자를 수정설마 블로그에서 복사를… ^^; 해도 됩니다. 코딩은 그렇게 편하게 하는 겁니다.123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; putchar('H'); putchar('e'); putchar('l'); putchar('l'); putchar('o'); putchar(' '); putchar('W'); putchar('o'); putchar('r'); putchar('l'); putchar('d'); putchar('\\n'); return 0;&#125; 스스로 컴파일하고 실행해 보세요.vim에서 컴파일 하고 실행하기123:w 파일명.c:!gcc 파일명.c -o 파일명.o:!./파일명.o vim 세팅을 했다면 &lt;F5&gt; 누르면 자동으로 컴파일하고 실행하도록 했습니다. putsputchar()를 갖이고 문장을 입력하려면 무척 불편합니다. 그래서 문장을 출력하기 위해서 puts() 함수를 사용합니다. puts함수는 putchar() 함수로 만들어졌습니다. 1234567#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; puts(\"Hello World\"); return 0;&#125; puts()는 명령이 끝나면 자동으로 줄을 바꾸어 줍니다. \\n을 넣을 필요가 없습니다. 줄을 바꾸지 않고 싶을 때는 printf()를 사용합니다. printfprintf()는 출력형식을 사용자가 자유롭게 지정할 수 있습니다. 12345678910111213#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; printf(\"%s\", \"Hello World\\n\"); printf(\"%c\", 65); printf(\"%c%c\", 'A', '\\n'); printf(\"%d\", 65); printf(\"%f\", 3.14); printf(\"Hello World\\n\"); printf(\"내이름은 %s이고 나이는 %d살 입니다.\\n\", \"홍길동\", 16); return 0;&#125; 위 프로그램에서 6행에 문자를 출력하는데 65란 숫자를 써도 문자가 출력되는 것을 볼 수 있습니다.컴퓨터는 문자를 인식 하지 못합니다. 오직 0, 1의 2진수만 알죠.ASCII 문자라는 것이 있습니다. 숫자를 문자로 표현 하는 약속이죠. 모호스 부호처럼요.%c 는 숫자를 문자로 변경해서 출력해 주는 기능을 가지고 있습니다.당연히 문자는 문자로 출력합니다. 오직 1문자만. 한글은 문자가 될수 없습니다. 한글은 3byte 초성,중성,종성으로 된 문자열 입니다. 출력형식 문자 설명 %c 문자하나를 출력, 상수가 숫자일경우 ascii로 문자로 대체 %s 문자열을 출력 %Nf 10진 실수를 N안에 출력 예)10.2f 전체소수점 포함 10자리, 소수점이하 2자리 %Nd 10진 정수를 N안에 출력 출력형식은 위에 있는것 말고도 조금 더있지만 자료형에서 다루겠습니다. 박스 그리기123456789#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; printf(\"================\"); printf(\"| |\"); printf(\"================\"); return 0;&#125; 선문자를 이용하면 더 예쁘게 그릴수 있습니다.이걸 왜 만들었을 까요?vim에서 :r!./box.o 해보세요.printf까지 출력되도록 만들어도 보세요.응용해서 자신의 명함도 만들어 보세요.1234회사명 : (주)대한민국 이름 : 홍길동 직책 : 사원주소: 서울시 뭐뭐구 뭐뭐동Tel : 000.0000.0000 H.P 000.0000.0000 어디에 사용할지 생각도 해보구요. 저는 메일과 문서에 사용합니다.텍스트 리더인 macos용 say나 google tts와 연동해서 사용할 수 있습니다.1234#macos$ 프로그램명 | say$ say \"안녕 say 야!\"$ man say google tts가 궁금하면 https://github.com/glutanimate/simple-google-ttslinux에서는 fastival이 있는데 한글이 안됨. 코미디언 이름 출력하기1234567#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; printf(\"유재석, 강호동, 박명수, 신동엽, 박미선\"); return 0;&#125; 이건 나중에 배열 배울때 써먹을 겁니다. 우선 연습 삼아 만들어 놓으세요. 아래 색상도vim에 snippet에 등록해서 사용해도 되지만 우리는 c언어 연습중… 색상 이름 출력하기1234567#include &lt;stdio.h&gt;int main(int argc, const char *argv[])&#123; printf(\"빨강, 주황, 노랑, 초록, 파랑, 남, 보라\"); return 0;&#125; 컴퓨터를 사용하는 이유는 복사와 붙여넣기가 가능하기 때문입니다.많이 할수록 컴퓨터를 잘 쓰는 겁니다. 참고로 cowsay, figlet, boxes란 프로그램을 설치해서 사용 해보세요.지금배운 출력문에 살을 조금만 붙이면 만들 수 있습니다. 1234567891011121314# Centos$sudo yum install cowsay$sudo yum install figlet$sudo yum install boxes# macos$brew install cowsay$brew install figlet$brew install boxes#ubuntu$sudo apt-get install cowsay$sudo apt-get install figlet$sudo apt-get install boxes ####printf() 함수만 쓰면 안되나? puts(), putchar()는 기능도 없고, 불편한데…문제되지 않습니다. printf()는 프로그램 크기가 커서 상대적으로 컴파일 속도가 느립니다.아두이노, 라즈베리파이나 arm 등 모바일 cpu에서는 컴파일 속도가 더 느려지겠죠.하지만 무시해도 됩니다. 체감하기 힘듭니다. 텍스트 파일을 하나 만들어서 hello world 저장하세요.크기를 확인해 보세요. 12$ echo \"hello world\" &gt; abc.txt$ ls -al abc.txt 그리고 putchar(), puts(), printf()로 hello world를 출력하는 프로그램을 각각 만들어서 파일의 크기를 비교해 보세요. 텍스트 파일보다 실행파일이 크기가 큰 이유는 뭘까요. 또 컴파일 된 실행파일의 크기가 같은 이유는 뭘까요. 이유를 인터넷 검색해 보세요. 실행파일은 기본 출력 명령을 포함하고 있고 똑같은 hello world 11자+ 줄바꿈(1자) 총12자를 출력합니다. 영문1글자는 1바이트 총12자 니까 12바이트 또 100번씩 출력하게 만들어서 크기를 비교해 보세요. 복사 붙여 넣기 신공을 사용해서 200번 출력하게 만드세요. 실행파일은 기본 출력 버퍼 사이즈를 가집니다. 실행 파일내 출력버퍼가 다차면 일정 크기만큼 자동으로 버퍼를 확장합니다. 출력문을 여러번 사용해도 실행파일의 크기가 갑자기 커지지는 않는다는 것을 확인 했습니다. 그러나 프로그램의 규모가 크다면 메뉴나, 설명등의 출력은 data파일에 저장한후 불러오는 구조로 많이 만듭니다. 64비트운영체제는 4메가, 32비트는 2메가, 16비트는 1메가바이트, 처리 비트가 클수록 낭비되는 부분도 커집니다. 임베디드 개발이 아닌 이상은 모두 무시하고 printf() 쓰세요. 컴퓨터 성능과 자원은 남아 돕니다.","categories":[{"name":"C언어기초","slug":"C언어기초","permalink":"http://korcow.github.io/categories/C언어기초/"}],"tags":[{"name":"c","slug":"c","permalink":"http://korcow.github.io/tags/c/"},{"name":"printf","slug":"printf","permalink":"http://korcow.github.io/tags/printf/"},{"name":"컴파일","slug":"컴파일","permalink":"http://korcow.github.io/tags/컴파일/"},{"name":"이스케이프문자","slug":"이스케이프문자","permalink":"http://korcow.github.io/tags/이스케이프문자/"},{"name":"puts","slug":"puts","permalink":"http://korcow.github.io/tags/puts/"},{"name":"putchar","slug":"putchar","permalink":"http://korcow.github.io/tags/putchar/"}]},{"title":"d2coding font","slug":"hexo-d2coding","date":"2017-11-03T18:36:37.486Z","updated":"2017-11-03T18:36:37.486Z","comments":true,"path":"2017/11/04/hexo-d2coding/","link":"","permalink":"http://korcow.github.io/2017/11/04/hexo-d2coding/","excerpt":"","text":"naver d2coding webfont 다운로드https://github.com/Joungkyun/font-d2coding","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://korcow.github.io/categories/Hexo/"}],"tags":[{"name":"font","slug":"font","permalink":"http://korcow.github.io/tags/font/"}]},{"title":"파일내용보기","slug":"centos-파일내용보기","date":"2017-11-02T13:43:13.000Z","updated":"2017-11-03T19:32:15.471Z","comments":true,"path":"2017/11/02/centos-파일내용보기/","link":"","permalink":"http://korcow.github.io/2017/11/02/centos-파일내용보기/","excerpt":"","text":"파일 내용 보기파일의 내용을 볼 수 있는 방법은 많이 있지만cat, head, tail, less 를 많이 사용합니다. 1$ man ls &gt; abc.txt 연습용 파일을 생성합니다. catcat은 파일의 내용을 보여줍니다. 파일의 내용이 길때 주르륵 스크롤 되기 때문에 more 함께 사용합니다. 123$ cat abc.txt$ cat abc.txt | more more를 사용했를 경우 spacebar를 누르면 다음 페이지로 이동됩니다. headhead는 파일의 윗부분을 기준으로 보여 줍니다.주로 무슨 파일인지 확인할 때 사용합니다.대부분의 프로그램의 첫 부분은 프로그램의 주석(설명)을 적도록 약속 했습니다.123$ head abc.txt$ head -20 abc.txt 1행 옵션이 없이 사용하면 기본으로 10줄을 보여줍니다.3행 -옵션으로 20을 입력하면 20줄을 보여줍니다. tailhead와 반대로 아래를 기준으로 보여줍니다.주로 어떻게 끝났는지 확인 할 때 사용합니다.파일의 끝에 문자열을 추가하기 위해 사용합니다.123$ tail abc.txt$ tail -20 abc.txt lessless는 man page가 사용하는 프로그램입니다.1$ less abc.txt q를 누르면 종료h를 누르면 도움말j,k 위아래이동spacebar 한화면 아래로 이동찾기, 이동하기등 옵션이 많이 있습니다. vim과 사용법이 비슷합니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"cat","slug":"cat","permalink":"http://korcow.github.io/tags/cat/"},{"name":"head","slug":"head","permalink":"http://korcow.github.io/tags/head/"},{"name":"tail","slug":"tail","permalink":"http://korcow.github.io/tags/tail/"},{"name":"less","slug":"less","permalink":"http://korcow.github.io/tags/less/"}]},{"title":"파일및디렉토리삭제","slug":"centos-파일및디렉토리삭제","date":"2017-11-02T13:29:56.000Z","updated":"2017-11-04T14:52:11.487Z","comments":true,"path":"2017/11/02/centos-파일및디렉토리삭제/","link":"","permalink":"http://korcow.github.io/2017/11/02/centos-파일및디렉토리삭제/","excerpt":"","text":"파일 및 디렉토리 삭제rm파일을 삭제하는 명령입니다.파일을 삭제하는 것은 꼭 필요하지만 위험을 초례 할 수 있는 명령입니다. 추천하는 방법은 ls로 확인후 rm명령과 혼합해서 사용하는 방법을 추천합니다.파일을 지울 때는 파일의 소유권과 권한에 따라 지울 수 없는 경우도 있습니다.이때는 sudo 를 사용하거나 소유권을 또는 권한을 이양 받아 사용해야 합니다. pwd 현재의 경로를 확인 합니다. ls *.txt 지울 파일을 확인합니다. rm !! 바로전 ls명을 덧붙여 사용합니다. rm -rf 디렉토리와 그안에 있는 파일도 삭제 합니다. -r 옵션은 하위에 디렉토리가 있어도 모두 지움니다. -f 옵션은 지울때 확인하는 메시지 없이 지워 버립니다. rmdir디렉토리를 삭제하는 명령입니다. rmdir deldir 반드시 디렉토리가 비워져 있어야 지울 수 있습니다. man page123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960이름 rm - 파일 지우기사용법 rm [-dfirvR] [--directory] [--force] [--interactive] [--recursive] [--help] [--version] [--verbose] name...설명 이 문서는 더이상 최신 정보를 담고 있지않다. 그래서, 몇몇 틀릴 경우도 있고, 부족한 경우도 있을 것이다. 완전한 매뉴얼을 원하면, Texinfo 문서를 참조하기 바란다. 이 매뉴얼 페이지는 rm 명령의 GNU 버전에 대한 것이다. rm 명령은 지정한 파일을 지운다. 초기값으로는 경로는 지우지 않는다. 만약에 파일 모드가 읽기 전용이고, 표준 입력이 tty이고, -f나 --force 옵션이 지정되지 않으면, rm 명령은 사용자에게 지정한 파일을 정말 지울것인지 물어본다. 이때, `y&apos;나 `Y&apos;를 입력해 주어야지만 그 파일을 지운다. GNU rm 명령과 같이 getopt(3) 함수를 사용하는 모든 풀그림에서는 -- 옵션 다음에 오는 것은 옵션이 아닌 것으로 인식한다. 즉 파일 이름이 `-f&apos; 라는 파일을 지우고자 한다면, 다음 두 방법을 사용한다. rm -- -f 또는 rm ./-f 유닉스 rm 명령의 `-&apos; 문자로 시작하는 옵션들 때문에 이런 기능들이 고안된 것이다.옵션 -d, --directory `rmdir&apos; 명령 대신에 `unlink&apos;와 함께 경로를 지운다. unlink하기 전에 그 경로가 비어있는지 확인하지 않고, 그냥 unlink 해버린다. 이렇기 때문에, 만약에 그 지워지는 경로 안에 파일 있다면, 그 파일들의 종속성문제가 생길 수 있다.(접근 불가능 현상, 미아 파일.) 이 옵션을 사용 한 후에서는 fsck(8)로 파일 시스템을 검사하기 바란다. 이 옵션은 시스템 관리자만이 사용할 수 있다. -f, --force 지울 파일이 없을 경우에 아무런 메시지를 보여주지 않고 그냥 넘어간다. 이 옵션은 쉘 스크립트 안에서 사용될 때 유용하게 쓰인다. -i, --interactive 각 파일을 하나씩 지울 것인지 사용자에게 일일이 물어본다. 이때 `y&apos; 나 `Y&apos;를 눌러야지만 파일이 지워진다. -r, -R, --recursive 일반 파일이면 그냥 지우고, 경로면, 그 하위 경로와 파일을 모두 지운다. -v, --verbose 각각의 파일 지우는 정보를 자세하게 모두 보여준다. --help 도움말을 보여주고 마친다. --version 버전 정보를 보여주고 마친다.번역 한글 Manpage 프로젝트 (http://man.kldp.org) 2005년 2월 14일FSF GNU File Utilities RM(1)","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"rm","slug":"rm","permalink":"http://korcow.github.io/tags/rm/"},{"name":"rmdir","slug":"rmdir","permalink":"http://korcow.github.io/tags/rmdir/"}]},{"title":"Bash","slug":"centos-bash","date":"2017-11-02T05:20:16.000Z","updated":"2017-11-04T05:49:18.630Z","comments":true,"path":"2017/11/02/centos-bash/","link":"","permalink":"http://korcow.github.io/2017/11/02/centos-bash/","excerpt":"","text":"bash bash는 shell 프로그램 중의 하나 입니다. sh, csh, ksh, zsh등 많은 쉘이 있지만 bash shell이 거의 표준처럼 사용되고 있습니다.bash는 사용자가 입력한 명령을 커널이 인식할 수 있는 명령으로 번역해 주는 interpreter 입니다.shell은 내부명령과 관리에 필요한 프로그래밍 문법을 가지고 있습니다. 많은 기능이 있는 만큼 shell에 대해 한번쯤 읽어 보는 것을 추천합니다. (이게 리눅스의 알짜입니다.)번역해 주신 이만용님께 감사도 표하시구요.(알짜리눅스) 참고로 수정을 하지않아 우측 스크롤 있습니다. bash man12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421BASH(1) General Commands Manual BASH(1)이름 bash - GNU Bourne-Again SHell개요 bash [옵션] [파일]저작권 Bash is Copyright (C) 1989, 1991 by the Free Software Foundation, Inc.설명 Bash 는 sh-호환의 명령 언어 해석기로서 표준 입력 또는 파일로부터 읽어들인 명령을 실행한다. Bash 는 또한 콘쉘 과 C 쉘(ksh, csh)로부터 유용한 기능을 도입하였다. Bash 는 IEEE POSIX 쉘과 도구 명세(IEEE Working Group 1003.2)에 호환되도록 쉘을 구현하겠다는 목표를 가지고 있다.옵션 set 내부 명령 기술 부분에서 설명하고 있는 단일 문자 쉘 옵션 외에도 bash는 실행될 때 다음 플래그(flag)도 해석한다 (역자 주 : 앞으로 option은 옵션, flag는 플래그, parameter는 매개변수, 그리고 argument는 전달인수 또는 간단히 인수로 해석한다): -c 문자열 -c 플래그가 있으면, 문자열 로부터 명령을 읽어들인다. 문자열 뒤에 전달인수가 있으면, 그 전달인수는 $0 부터 시작하여 위치 매개변수로 지정된다. -i -i 플래그가 있으면, 쉘은 대화형 (interactive)모드로 동작한다. -s -s 플래그가 있을 때 또는 옵션 처리 후에 남은 인수가 없을 때에는 표준 입력으로부터 명령을 읽어들인다. 이 옵션을 사용하여 대화형 쉘을 실행시킬 때 위치 매개변수를 설정할 수 있다. - - 한 글자는 옵션이 끝났음을 알리는 표시이며 더 이상 옵션 처리를 하지 않도록 지시한다. - 다음의 인수는 모두 파일 이름과 인수로 받아들여진다. 글자 그대로 -라는 인수를 표현하려면 -- 를 사용한다. Bash 는 또한 여러 글자 옵션을 해석한다. 이 옵션을 인식시키려면 명령행에서 단일 글자 옵션보다 앞에 적어야 한다. -norc 쉘이 대화형 모드일 때 개인 초기화 파일인 ~/.bashrc 실행하지 않도록 한다. 쉘을 실행할 때 sh 라는 이름으로 실행하면 기본적으로 이 옵션이 켜진다. -noprofile 시스템 전역 시동 파일 /etc/profile 또는 ~/.bash_profile, ~/.bash_login, ~/.profile 와 같은 모든 개인 초기화 파일을 읽지 않도록 한다. bash 가 로그인 쉘로 실행될 때에는 기본적으로 이 모든 파일을 읽는다.( 뒤에 나오는 INVOCATION 참고 ). -rcfile 파일 쉘이 대화형 모드일 때( INVOCATION 참고 ) 표준적인 개인 초기화 파일인 ~/.bashrc 대신 파일 의 명령을 실행한다. -version 실행할 때 bash 의 버전 번호를 보여준다. -quiet 시작할 때 상세한 정보를 보여주지 않는다.(즉 쉘 버전과 기타 정보를 표시하지 않는다.) 기본값이다. -login bash 가 마치 로그인 쉘로 시작된 것처럼 행동하게 한다. -nobraceexpansion 중괄호 확장을 하지 않는다. ( 뒤에 나오는 중괄호(Brace) 확장 참고 ). -nolineediting 대화형 모드에서 명령을 읽을 때 GNU readline 라이브러리를 사용하지 않는다. -posix 기본적으로 POSIX 1003.2 표준과 다른 bash의 행동 방식을 바꾸어 표준에 부합되도록 지시한다.인수 옵션 처리 후 남은 인수가 있거나 -c 또는 -s 옵션이 없는 경우에는, 첫번째 인수를 쉘 명령을 포함하고 있는 파일 이름으로 간주한다. bash 가 이런 방식을 실행되면, is invoked in this fashion, $0 는 파일의 이름으로 설정되고 위치 매개변수는 남은 인수로 설정된다. Bash 는 이 파일의 명령을 실행하고 종료한다. 스크립트에서 실행된 마지막 명령의 종료 상태가 Bash 의 종료 상태로 된다.정의 공백(blank) 스페이스 또는 탭. 단어(word) 쉘에 의해 하나의 단위로 간주되는 연속된 문자들. 토큰(token) 이라고 부르기도 한다. 이름(name) 알파벳, 숫자 문자와 언더스코어(_)로만 이루어져 있고 알파벳 문자와 언더스코어로 첫 문자를 시작하는 단어 를 말한다. 식별자(identifier) 라고 부르기도 한다. 메타문자(metacharacter) 쿼우트(quote) 처리하지 않을 때 단어을 구별하게 만드는 문자. 다음과 같다: | &amp; ; ( ) &lt; &gt; 스페이스 탭 제어 연산자(control operator) 제어 기능을 수행하는 토큰이다. 다음 기호에 해당한다: || &amp; &amp;&amp; ; ;; ( ) | &lt;newline&gt;예약어(RESERVED WORDS) 예약어란 쉘에 있어 특별한 의미를 갖는 단어를 말한다. 다음 단어는 쿼우트하지 않으면 예약어로 인식하거나 또는 간단한 명령의 첫번째 단어 또는 case 나 for 명령의 세번째 단어로 인식한다: ( 쉘 문법 참고 ) ! case do done elif else esac fi for function if in select then until while &#123; &#125;쉘 문법(SHELL GRAMMAR) 간단한 명령 간단한 명령이란 변수 지정(선택적, 역자 주: 원어로 optional이며 있어도 되고 없어도 된다는 의미로 사용한다.) 다음에 공백으로 구분된 단어와 리다이렉션이 뒤따르고 제어 문자로 끝나는 연속된 문자열을 말한다. 첫번째 단어는 실행할 명령이 된다. 나머지 단어는 실행 명령에 인수로 전달된다. 간단한 명령의 반환값은 종료 상태이거나 시그널 n. 로 종료된 경우에는 128+n이 된다. 파이프라인 파이프라인이란 | 문자로 구분된 한 개 이상의 명령이 연속되어 나오는 것을 말한다. 파이프라인의 형식은 다음과 같다: [ ! ] 명령 [ | 명령2 ... ] 명령 의 표준 출력은 명령2 의 표준 입력으로 연결된다. 파이프 라인 연결은 명령에서 명시한 리다이렉션 이전에 수행된다. ( 리다이렉션 참고 ). 예약어인 ! 가 파이프라인 앞에 나오면 파이프라인의 종료 상태값을 마지막 명령의 종료 상태에 대한 논리적인 NOT으로 설정한다. 그렇지 않은 일반적인 경우에는 마지막 명령의 종료 상태값이 파이프라인의 종료 상태값로 된다. 쉘은 값을 반환하기 전에 파이프라인에 연결되어 있는 모든 명령이 종료하기를 기다린다. 파이프라인의 각 명령은 개별적인 프로세스로 실행된다.(즉, 각자의 서브쉘 안에서 실행된다.) 리스트(Lists) 리스트란 한 개 이상의 파이프라인이 ;, &amp;, &amp;&amp;, ⎪⎪ 연산자 중 하나에 의해 구분되고 ;, &amp;, &lt;개행문자&gt; 중 하나로 끝나는 연속된 문자열을 말한다. 리스트 연산자 중에서, &amp;&amp; 와 ⎪⎪ 는 같은 우선권을 가지고 있으며 그 다음으로 ; 와 &amp; 가 같은 우선권을 가지고 있다. 명령이 제어 연산자인 &amp; 로 끝나면, 쉘은 그 명령을 서브쉘에서 백그라운드로 실행한다. 쉘은 명령이 종료하길 기다리지 않으면 반환값은 0 이다. ; 로 구분된 명령들은 순차적으로 실행된다; 쉘은 차례대로 각 명령이 종료하기를 기다린다. 반환 상태값은 마지막으로 실행한 명령의 종료 상태값을 따른다. 제어 연산자 &amp;&amp; 와 ⎪⎪ 는 각각 AND 리스트와 OR 리스트를 나타낸다. AND 리스트는 다음과 같은 형태를 가진다. 명령 &amp;&amp; 명령2 명령2 는 명령 이 0 이라는 종료 상태값을 반환할 때에만 실행된다. OR 리스트는 다음과 같은 형태를 가진다. 명령 ⎪⎪ 명령2 명령2 는 명령 의 종료 상태값이 0 이 아닌 값일 때에만 실행된다. AND와 OR 리스트의 반환 상태값은 리스트에서 마지막으로 실행된 명령의 종료 상태값을 따른다. 복합 명령 복합 명령이란 다음 중 하나를 말한다: (리스트) 리스트가 서브셀 안에서 실행된다. 명령이 완료된 후에는 쉘의 환경에 영향이 미치는 변수 지정과 내부 명령의 효과가 사라진다. 반환 상태값은 리스트 의 종료 상태값을 따른다. &#123; 리스트; &#125; 리스트는 그냥 현재의 쉘 환경에서 실행된다. known as a 그룹 명령 이라고 부르기도 한다. 반환 상태값은 리스트 의 종료 상태값을 따른다. for 이름 [ in 단어; ] do 리스트 ; done in 다음의 단어 리스트가 확장되어 처리 항목 리스트를 생성한다. 리스트가 실행될 때마다 변수 이름에 리스트의 원소가 순서대로 설정된다. in 단어가 생략되면 for 명령은 설정된 각 위치 매개변수에 대하여 리스트를 한 번씩 실행한다. ( PARAMETERS 참고 ). select 이름 [ in 단어; ] do 리스트 ; done in 다음의 단어 리스트가 확장되어 처리 항목 리스트를 생성한다. 확장된 단어 목록에 숫자를 붙여 표준 에러로 출력한다. in 단어가 생략되면 위치 매개변수를 출력한다. ( PARAMETERS 참고 ). PS3 프롬프트가 표시되고 표준 입력으로부터 한 줄을 입력받는다. 입력행의 내용에 표시된 단어 중 하나에 해당하는 숫자가 포함되어 있으면 이름 은 그 단어로 설정된다. 빈 줄일 때에는 단어 리스트와 프롬프트가 다시 표시된다. EOF를 만나면 명령이 종료한다. 그 밖의 다른 값이 입력되면 이름 이 널(null)로 설정된다. 읽어 들인 행은 변수 REPLY 에 저장된다. break 또는 return 명령을 만나기 전까지 각각의 선택에 대하여 리스트 가 실행된다. select 의 종료 상태값은 리스트 안에서 실행된 마지막 명령의 종료 상태값이거나 또는 아무 명령도 실행되지 않은 경우 0 이 된다. case 단어 in [ 패턴 [ | 패턴 ] ... ) 리스트 ;; ] ... esac case 명령은 우선 단어를 확장한 다음, 경로명 확장에서와 똑같은 일치 규칙을 사용하여 차례대로 패턴과의 매치를 시도한다. ( Pathname Expansion 참고 ). 일치하는 것이 발견되면 해당하는 리스트가 실행된다. 첫번째 일치 후에는 다음 일치 내용을 찾지 않는다. 아무 패턴과도 일치하지 않으면 0 이라는 종료 상태값을 갖는다. 일치하는 것이 있을 때에는 리스트에서 실행된 마지막 명령의 종료 상태값을 따른다. if 리스트 then 리스트 [ elif 리스트 then 리스트 ] ... [ else 리스트 ] fi if 리스트 가 실행된다. 그 종료 상태값이 0 이면 then 리스트를 실행하고 명령을 마친다. 0 이 아니면 elif 리스트가 있는 경우 이 부분을 실행한다. 종료 상태값은 마지막 실행 명령의 종료 상태값이 되거나 테스트한 조건이 하나도 참이 아닌 경우에는 0 이 된다. while 리스트 do 리스트 done until 리스트 do 리스트 done while 명령은 리스트의 마지막 명령 결과가 0 인 동안 do 리스트를 계속 실행한다. until 명령은 while 명령과 같으나 테스트 결과를 반대로 처리한다. do 리스트 는 리스트 의 마지막 명령이 0 아닌 종료 상태값을 가지는 동안 실행된다. while과 until 명령의 종료 상태값은 마지막 do 리스트 명령의 상태 종료값을 따른다. 또는 아무 것도 실행되지 않은 경우 0 이 된다. [ function ] 이름 () &#123; 리스트; &#125; 이름의 함수를 정의한다. 함수의 몸체 부분은 &#123; 와 &#125; 사이에 있는 명령 리스트 이다. 간단한 명령의 이름으로 이름이 나올 때마다 이 리스트가 실행된다. 함수의 종료 상태값은 몸체 안에서 실행된 마지막 명령의 종료 상태값을 따른다. ( FUNCTIONS 참고.)주석(COMMENTS) 비-대화형 쉘 또는 set 내부 기능을 작동하도록 하기 위해 -o interactive-comments 옵션을 주어 실행한 대화형 쉘 안에서, # 로 시작하는 단어와 그 행의 모든 단어는 무시한다. -o interactive-comments 옵션 없이 대화형 쉘을 시작하면 주석을 사용할 수 없다.쿼우팅(QUOTING) 쿼우팅은 쉘에 있어 특별한 의미를 갖는 문자나 단어의 그 의미를 제거할 때 사용한다. 또한 특수 문자에 대한 특별한 처리를 하지 못하게 하고 예약된 단어의 예약적 의미를 없애고 매개변수 확장을 하지 못하도록 할 때에도 쿼우팅을 사용한다. (역자 주 : Quote에 대하여 여러 가지 한글 번역이 가능하겠으나 유닉스 쉘에서의 특별한 의미를 전달할 수 없다고 판단하여 그냥 발음나는 대로 쿼우트라고 번역하였다.) DEFINITIONS 섹션에 나열한 메타문자 각각은 쉘에서 특별한 의미를 갖고 있기 때문에 글자 그대로를 표현하려면 쿼우트해야 한다. 3 가지 쿼우트 메커니즘이 있다: 이스케이프(escape) 문자, 싱글 쿼우트, 더블 쿼우트가 있다. 쿼우트하지 않은 백슬래쉬(\\)가 이스케이프 문자 이다. &lt;개행문자&gt;를 제외하고 이스케이프 문자는 그 다음에 뒤 따라 오는 문자의 글자 그대로의 의미를 보존한다. \\&lt;개행문자&gt;가 나오고 백슬래쉬를 쿼우트하지 않았을 때에는 \\&lt;개행문자&gt;를 행 계속(역자 주 : 긴 명령을 한 줄에 적을 수 없을 때 행 끝에서 \\&lt;개행문자&gt;를 입력하면 다음 줄에 계속해서 입력할 수 있다) 을 뜻한다.(즉, 그 자체는 쉘에 의해 무시된다.) 싱글 쿼우트의 묶는 문자는 묶인 문자의 보이는 그대로의 값을 보존한다. 백슬래쉬를 앞에 적는다 해도 싱글 쿼우트 안에 싱글 쿼우트가 다시 들어 갈 수는 없다. 더블 쿼우트의 묶는 문자는 몇 가지 예외를 제외하고 쿼우트 안에 들어있는 모든 문자의 보이는 그대로의 의미를 보존한다. $, `, 와 \\ 는 예외의 경우이다. $ 와 ` 문자는 더블 쿼우트 안에서도 특별한 의미를 유지한다. 백슬래쉬는 그 뒤에 다음 문자가 뒤따라 나올 때에만 특별한 의미를 갖는다: $, `, \", \\, 또는 &lt;개행문자&gt;. 더블 쿼우트 안의 더블 쿼우트는 백슬래쉬를 사용하여 포함시킬 수 있다. 특별한 매개변수인 * 와 @ 는 더블 쿼우트 안에서 특별한 의미를 지닌다. ( PARAMETERS 참고 ).매개변수(PARAMETERS) 매개변수 란 값을 저장하는 개체로서 기존의 프로그램 언어에서의 변수와 어느 정도 비슷하다. 이름, 숫자, 또는 특별한 매개변수(Special Parameters) 섹션에서 나열한 특수 문자 중 하나가 될 수 있다. 쉘에 있어 변수 란 이름 으로 가리키는 매개변수이다. 값을 지정하면 매개변수가 설정된다. 널 문자열도 유효한 값으로 간주한다. 일단 변수가 설정되면 unset 내부 명령을 통해서만 설정 해제할 수 있다. ( 쉘 내부 명령(SHELL BUILTIN COMMANDS) 참고 ). A 변수 는 다음과 같은 문장을 통해 지정할 수 있다. 이름=[값] If 값 을 지정하지 않으면 변수는 널 문자열을 값으로 갖게 된다. 모든 변수 는 틸드 확장, 매개변수와 변수 확장, 명령 치환, 연산에 의한 확장, 쿼우트 제거 등의 과정을 거친 다음, 그 결과를 저장한다. 변수의 -i 속성이 설정되어 있는 상태라면 ( 쉘 내부 명령 섹션의 declare 참고 ) 값 은 $[...] 문법이 아니더라도 연산에 의한 확장을 거친다. 특별한 매개변수 섹션에서 설명할 \"$@\"를 제외하고 단어 분리는 하지 않는다. 경로명 확장은 이루어지지 않는다. 위치 매개변수 위치 매개변수 란 0 하나만 적는 것을 제외하고 숫자로 지시하는 매개변수를 말한다. 위치 매개변수는 쉘이 실행될 때 인수로부터 지정되거나 또는 set 내부 명령을 사용하여 재지정할 수 있다. 위치 매개변수는 변수 지정 문장을 사용하여 지정할 수 없다. 위치 매개변수는 쉘 함수가 실행될 때 일시적으로 치환된다. ( 함수(FUNCTIONS) 참고 ). 1 개 이상의 숫자로 구성된 위치 매개변수를 확장할 때에는 중괄호로 묶어주어야 한다. ( 확장(EXPANSION) 참고 ). 특별한 매개변수 쉘은 몇 가지 매개변수를 특별하게 처리한다. 이러한 매개변수는 참조만 가능할 뿐 값을 지정할 수는 없다. * 1 부터 시작하여 위치 매개변수로 확장한다. 더블 쿼우트에서 확장이 이루어지면 각 매개변수 값을 한 단어로 확장한다. 각 단어는 IFS 특별 변수의 첫번째 문자로 구분한다. 다시 말해, ``$*'' 는 ``$1c$2c...'' 와 같다. 여기서 c 는 IFS 변수의 첫번째 문자이다. IFS 가 널이거나 해제되어 있으며 매개변수는 스페이스로 구분한다. @ 1 부터 시작하여 위치 매개변수로 확장한다. 더블 쿼우트 안에서 확장이 이루어질 때에는 각 매개변수가 개별적인 단어로 확장한다. 즉 `` $@'' 는 ``$1'' ``$2'' ... 와 같다. 위치 매개변수가 없을 때에는 ``$@'' 와 $@ 은 아무 것으로도 확장되지 않는다.(즉, 없었던 것처럼 제거된다.) # 십진수로 위치 매개변수의 갯수로 확장한다. ? 최근에 실행된 포그라운드 파이프라인의 상태값으로 확장한다. - 실행하자마자 set 내부 명령을 통해 또는 쉘 자체에 의해 (예를 들어 -i 플래그) 설정된 현재 옵션 플래그로 확장한다. $ 쉘의 프로세스 ID로 확장한다. () 서브쉘에서는 서브쉘이 아닌 현재 쉘의 프로세스 ID로 확장한다. ! 최근에 실행한 백그라운드(비동기) 명령의 프로세스 ID로 확장한다. 0 쉘 또는 쉘 스크립트의 이름으로 확장한다. 쉘 초기화 과정 중에 설정된다. bash 이 명령을 포함하는 파일 이름으로 실행되었다면, $0 는 그 파일의 이름으로 설정된다. bash 가 -c 옵션을 가지고 실행되었다면 $0 는 실행될 문자열(있는 경우) 뒤 첫번째 인수로 설정된다. 그렇ㅈ 않은 경우 bash 를 실행할 때 0 번 인수로 주어진 경로명으로 설정된다. _ 지난 번 명령의 마지막 인수(확장되고 난 형태)로 확장된다. 실행된 각 명령의 완전한 경로명으로도 설정되며 그 명령에게 export한 환경에 위치한다. (역자 주 : 쉘의 용어에서 export의 마땅한 한글 번역을 찾지 못한 상태이다) 쉘 변수 다음 변수는 쉘에 의해 설정된다: PPID 쉘의 부모 프로세스 ID. PWD cd 명령으로 설정된 현재 작업 디렉토리. OLDPWD cd 명령에 의해 설정되며 바로 이전 작업 디렉토리. REPLY 인수가 제공되지 않은 경우 read 내부 명령으로 읽어 들인 입력 행으로 설정 UID 현재 사용자의 사용자 ID로 확장. 쉘 시동 시 초기화됨. EUID 현재 사용자의 유효 사용자 ID로 확장. 쉘 시동 시 초기화됨. BASH 현재 실행 중인 bash 를 실행할 때 사용한 완전한 경로명으로 확장. BASH_VERSION 현재 실행 중인 bash 인스턴스(instance)의 버전 번호로 확장. SHLVL bash 인스턴스를 실행할 때마다 1 씩 증가하는 변수 RANDOM 이 매개변수를 참조할 때마다 무작위 정수가 발생된다. 무작위 정수의 순서는 RANDOM 에 값을 지정하면 초기화된다. If RANDOM 를 unset하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은 속성은 돌아오지 않는다. SECONDS 이 매개변수를 참조할 때마다 쉘이 시작한 시점부터 경과된 시간을 반환한다. SECONDS 에 값을 지정하면, 그 다음부터는 지정한 시점으로부터 경과한 시간 더하기 지정한 값이 반환된다. SECONDS 를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은 속성은 돌아오지 않는다. LINENO 참조할 때마다 쉘은 이 변수를 스크립트 또는 함수 내에서의 지금 현재 시점에서의 순차적인 행 번호(1부터 시작)을 십진수로 치환해준다. 스크립트나 함수 안이 아닌 경우, 이 값은 의미가 없다. 함수 안에서의 값은 명령이 소스에서 위치하는 행 번호가 아니며 (이 정보는 함수가 실행될 때 사라진다.) 현재 함수 내에서 실행된 간단한 명령 의 갯수에 대한 근사값이라고 생각하면 된다. If LINENO 를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은 속성은 돌아오지 않는다. HISTCMD 현재 명령의 히스토리 번호 또는 히스토리 리스트에서의 인덱스. HISTCMD 를 unset 하면 특별한 속성을 잃게 된다. 그 뒤에 다시 설정해도 잃은 속성은 돌아오지 않는다. OPTARG getopts 내부 명령에 의해 처리된 마지막 옵션 인수의 값 ( 쉘 내부 명령 참고 ). OPTIND getopts 내부 명령에 의해 처리된 다음 인수의 인덱스 ( 쉘 내부 명령 참고 ). HOSTTYPE 자동으로 bash 가 실행 중인 머신의 타입을 기술하는 고유한 문자열로 지정됨. 기본값은 시스템에 따라 다르다. OSTYPE 자동으로 bash 가 실행 중인 운영체제의 타입을 기술하는 고유한 문자열로 지정됨. 기본값은 시스템에 따라 다르다. 다음 변수는 쉘에서 사용한다. 몇몇 경우 bash 는 변수에 기본값을 지정한다; 이런 경우에 대해서는 언급한다. IFS 내부 필드 구분자(Internal Field Separator) 는 확장 후에 단어를 분리하고 read 내부 명령으로 읽은 행을 분리할 때 사용된다. that is used 기본값은 ``&lt;스페이스&gt;&lt;탭&gt;&lt;개행문자&gt;''이다. PATH 명령을 찾을 검색 경로이다. 쉘이 명령을 찾아 볼 디렉토리 목록을 콜론으로 구분하여 지정한다. ( 명령 실행(COMMAND EXECUTION) 참고 ). 기본값은 시스템에 따라 다르며 관리 bash 를 설치하는 관리자가 설정할 수 있다. 일반적으로 ``/usr/gnu/bin:/usr/local/bin: /usr/ucb:/bin:/usr/bin:'' 라는 값을 갖는다. HOME 현재 사용자의 홈 디렉토리; cd 내부 명령의 기본 인수이다. CDPATH cd 명령에서 사용하는 검색 경로. cd 명령에서 사용한 목적지 디렉토리를 찾아 볼 디렉토리를 콜론으로 구분하여 적는다. 예를 들어 ``.:~:/usr''와 같은 값으로 설정한다. ENV bash가 쉘 스크립트를 실행할 때 매개변수가 설정되어 있으면, 그 값은 .bashrc 와 같이 쉘을 초기화하는 명령을 담고 있는 파일의 이름으로 해석한다. The value of ENV 의 값은 경로명으로 해석되기 전에 매개변수 확장, 명령 치환, 연산 확장을 거쳐 설정된다. 결과로 나오는 경로명 검색에서 PATH 는 사용하지 않는다. MAIL 이 매개변수가 파일 이름으로 설정되어 있고 MAILPATH 변수는 설정되어 있지 않으면, bash 는 그 파일을 보고 메일의 도착 여부를 사용자에게 알려준다. MAILCHECK 얼마나 자주(초 단위로) bash 가 메일을 점검할 것인지 결정한다. 기본값은 60 초이다. 메일을 점검할 때가 되면 프롬프트를 보여 주기 전에 실행한다. 변수를 unset하면 메일 점검을 하지 않는다. MAILPATH 메일이 왔는지 점검하기 위해 사용하는 경로명을 콜론으로 구분하여 설정한다. 출력할 메시지는 경로명 다음에 `?'를 적고 그 다음에 적어 설정할 수 있다. $_ 는 현재 사용하고 있는 메일 파일의 이름을 표시한다. 예: MAILPATH='/usr/spool/mail/bfox?\"You have mail\":~/shell-mail?\"$_ has mail!\"' Bash 가 이 변수에 대한 기본값을 제공하지만 사용자 메일 파일의 위치는 시스템에 따라 다르다. (예를 들어, /usr/spool/mail/$USER). MAIL_WARNING 이 변수가 설정되어 있고 bash가 메일을 점검할 때 사용하는 파일을 지난 번 점검 시간 이후, 접근한 적이 있다면, ``The mail in 메일파일 has been read''라는 메시지가 출력된다. PS1 이 매개변수의 값을 확장하여 ( PROMPTING 참고 ) 주 프롬프트 문자열로 사용한다. 기본값은 ``bash\\$ ''이다. PS2 이 매개변수의 값을 확장하여 2차 프롬프트 문자열로 사용한다. 기본값은 ``&gt; ''이다. PS3 매개변수 값을 확장하여 select 명령의 프롬프트로 사용한다. (앞서 나온 쉘 문법 참고). PS4 매개변수 값을 확장하여 실행 추적 중 bash 가 각 명령을 표시하기 전에 그 값을 사용한다. PS4 의 첫번째 문자는 여러 레벨을 표시하기 위해 필요한 만큼 반복하여 표시한다. 기본값은 ``+ ''. HISTSIZE 명령 히스토리에서 기억해 둘 명령의 갯수 ( 히스토리(HISTORY) 참고 ) 기본값은 500. HISTFILE 명령 히스토리를 저장할 파일 이름. ( HISTORY 참고.) 기본값은 ~/.bash_history. unset 하면 대화형 쉘이 종료할 때 명령 히스토리를 저장하지 않는다. HISTFILESIZE 히스토리 파일의 최대 행 갯수. 값을 지정하면 필요한 경우 그 값에 맞게 파일을 잘라 쓴다(truncate). 기본값은 500. OPTERR 1로 설정하면 bash 는 getopts 내부 명령에서 발생한 에러 메시지를 표시한다. ( 쉘 내부 명령 참고). 쉘이 실행되거나 쉘 스크립트가 실행될 때 OPTERR 는 1로 초기화된다. PROMPT_COMMAND 설정하면 주 프롬프트를 출력하기 전에 지정한 명령을 실행한다. IGNOREEOF 입력행에 EOF 문자만 입력되었을 때 쉘이 어떤 행동을 보일 것인지 제어한다. 설정하면 값으로 지정한 횟수만큼 입력행의 처음에 EOF 문자가 연속적으로 입력될 때 bash 가 종료한다. 변수는 존재하지만 숫자 값이 아니거나 아무런 값도 갖지 않을 때에는 기본값 10 을 사용한다. 존재하지 않으면 EOF 은 쉘에게 입력의 끝을 의미한다. 대화형 쉘에서만 효과를 지닌다. TMOUT 0 보다 큰 값으로 설정하면 주 프롬프트가 표시된 후 설정한 값 만큼의 초를 기다린다. 그 동안 아무런 입력도 없으면 Bash 이 종료한다. FCEDIT fc 내부 명령의 기본 편집기. FIGNORE 파일명 완성을 수행할 때 무시할 꼬리말의 목록을 콜론으로 구분하여 나열한다. ( READLINE 참고) FIGNORE 에 설정되어 있는 꼬리말을 가진 파일명은 일치하는 파일명 목록으로부터 제외된다. 예를 들어 ``.o:~''와 같은 값을 사용할 수 있다. INPUTRC 기본값인 ~/.inputrc 대신 readline 시동 파일로 사용할 파일명. ( READLINE 참고). notify 설정하면, If set, bash 는 종료된 백그라운드 작업에 대한 보고를 그 다음 주 프롬프트 표시 전까지 기다리지 않고 즉시 한다. ( set 내부 명령의 -b 옵션 참고) history_control HISTCONTROL ignorespace 라는 값으로 설정하면 스페이스 문자로 시작하는 행은 히스토리 목록에 넣지 않는다. ignoredups 로 설정하면 마지막 히스토리 행과 일치하는 행은 히스토리 목록에 넣지 않는다. ignoreboth 는 두 옵션을 합한 것과 같다. unset하거나 위에서 말한 값이 아닌 값으로 설정하면 파서(parser)에서 읽어 들인 모든 행을 히스토리 목록에 저장한다. command_oriented_history 설정하면, bash 는 여러 행으로 이루어진 명령의 모든 행을 똑같은 히스토리 항목으로 저장한다. 이렇게 하면 여러 행으로 이루어진 명령을 다시 편집할 때 편하다. glob_dot_filenames 설정하면, bash 경로명 확장의 결과에서 `.'로 시작하는 파일명도 포함시킨다. allow_null_glob_expansion 설정하면, bash 일치하는 파일이 없는 경로명 패턴을 그대로 놔두지 않고 널 문자열로 확장해준다. ( 경로명 확장 참고) histchars 히스토리 확장과 토큰화를 제어하는 둘 또는 세 개의 문자. ( 히스토리 확장 참고) 첫번째 문자는 히스토리 확장 문자(history expansion character) 로서, 즉 히스토리 확장의 시작을 알리는 문자이며 보통 `! 이다. 두번째 문자는 빠른 치환(quick substitution) 문자로서 입력했던 이전 명령을 다시 실행하고 한 문자열을 명령의 다른 문자열로 치환하는데 사용하는 단축문자이다. 기본값은 `^' 이다. 선택적인 세번째 문자는 단어의 첫 문자로 사용할 때 행의 나머지 부분은 주석임을 알리는데 사용하는 문자로서, 보통 `#'를 사용한다. 히스토리 주석 문자를 사용하면 히스토리 치환를 할 때 행의 나머지 부분에 대하여 치환를 하지 않고 건너뛰도록 한다. 이 기능을 사용하기 위해 꼭 쉘 파서(parser)로 하여금 행의 나머지 부분을 주석으로 처리하도록 해 둘 필요는 없다. nolinks 설정하면, 현재 작업 디렉토리를 변경하는 명령을 실행할 때 쉘이 심볼릭 링크는 따라가지 않도록 한다. 대신 물리적인 디렉토리 구조를 사용하도록 한다. 기본적으로 bash 는 cd 와 같은 현재 디렉토리 변경 명령을 실행할 때 논리적인 디렉토리 사실을 따른다. set 내부 명령의 -P 옵션에 대한 설명을 참고하라. ( 쉘 내부 명령 참고) hostname_completion_file HOSTFILE /etc/hosts 과 같은 형식의 파일로서 쉘이 호스트이름을 완성할 때 사용한다. 파일이름은 그 때 그 때 변경할 수 있다; 다음 번에 호스트이름 완성을 시도할 때 bash 는 새로운 파일의 내용을 기존 데이터베이스에 추가한다. noclobber 설정하면, bash 는 &gt;, &gt;&amp;, &lt;&gt; 와 같은 리다이렉션 연산자로 기존의 파일을 덮어쓰지 않는다. &gt; 대신 &gt;| 리다이렉션 연산자를 사용하여 출력 파일을 만들 때에는 이 변수값에 상관없이 덮어쓴다. ( set 내부 명령의 -C 옵션에 대해서도 알아보라.) auto_resume 쉘이 사용자와 작업 제어에 대한 상화 대화를 어떻게 할 것인지 제어한다. 변수를 설정하면, 리다이렉션을 사용하지 않은 단일 단어의 간단한 명령을 기존의 중단된 작업 재개를 위한 후보로 간주한다. 모호한 것은 허용되지 않는다; 입력한 문자열로 시작하는 작업이 여러 개일 때에는 최근에 접근한 적 있는 작업이 선택된다. 여기서 중단된 작업의 이름 이란 작업을 시작했을 때 사용한 명령행을 말한다. exact 라는 값으로 설정하면, 입력한 문자열이 중단된 작업의 이름과 정확하게 일치해야 한다; substring 이라는 값으로 설정하면 , 입력한 문자열이 중단된 작업 이름의 일부와 일치해도 된다; substring 값은 %? job id 와 유사한 기능을 제공한다. ( 작업 제어(JOB CONTROL) 참고 ) 다른 값으로 설정하면 입력한 문자열은 중단된 작업 이름의 머리말이어야 한다; % job id 와 유사한 기능을 제공한다. no_exit_on_failed_exec 이 변수를 설정하면, exec 내부 명령에서 주어진 파일을 실행할 수 없을 때에도 비대화형 쉘이 종료하지 않는다. exec 에 실패할 때 대화형 쉘은 종료하지 않는다. cdable_vars 이 변수를 설정하면 cd 내부 명령의 인수가 디렉토리가 아닐 때는, 이동하고자 하는 디렉토리를 값으로 갖고 있는 변수 이름으로 간주한다.확장(EXPANSION) 확장은 명령행을 단어로 분리한 후 실행된다. 다음과 같은 몇 가지 확장이 수행된다: 중괄호 확장(brace expansion), 틸드 확장(tilde expansion), 매개변수와 변수 확장, 명령 치환, 연산 확장, 단어 분리, 경로명 확장. 확장의 순서는 중괄호 확장, 틸드 확장, 매개변수, 변수, 명령 그리고 연산 치환(왼쪽에서 오른쪽 방향으로), 단어 분리, 경로명 확장 순이다. 이 기능을 지원하는 시스템에서는 프로세스 치환(process substitution)와 같은 추가 확장 기능이 있다. 중괄호 확장, 단어 분리, 경로명 확장만이 확장 시에 단어의 갯수를 변화시킬 수 있다; 다른 확장은 한 단어를 한 단어로 확장한다. 유일한 예외로는 앞서 설명한 바 있는 ``$@'' 확장을 들 수 있다. ( 매개변수 참고 ). 중괄호 확장(Brace Expansion) 중괄호 확장 은 임의의 문자열을 생성시킬 수 있는 메커니즘이다. 이 메커니즘은 경로명 확장과 유사하지만 파일이름이 존재하지 않아도 된다는 점에서 다르다. 중괄호 확장할 패턴은 다음과 같은 형태를 띤다. 선택적인 preamble 다음에 콤마로 구분된 문자열을 둘러 싼 중괄호가 나오고 선택적인 postamble 이 따라 나온다. preamble은 중괄호 안에 있는 각 문자열 앞에 추가되고 postamble은 왼쪽에서 오른쪽으로 각각의 결과 문자열 뒤에 추가된다. 중괄호 확장은 중첩할 수 있다. 확장된 각 문자열의 결과는 정렬되지 않는다; 왼쪽에서 오른쪽으로라는 순서는 보존된다. 예를 들어 a&#123;d,c,b&#125;e는 `ade ace abe'로 확장된다. 중괄호 확장은 다른 확장보다 먼저 수행되며 다른 확장에 특별한 의미를 갖는 문자열은 보존된다. 중괄호 확장은 엄격하게 글자 그대로 이루어진다. Bash 는 확장 상황이나 중괄호 안의 텍스트에 대하여 문법적인 해석을 시도하지 않는다. 올바른 형식의 중괄호 확장에는 쿼우트하지 않은 상태로 여는 중괄호, 닫는 중괄호가 있고 역시 쿼우트하지 않은 하나 이상의 콤마가 포함된다. 올바르지 않은 형태의 중괄호 확장은 그대로 놔둔다. 중괄호 확장 형식은 보통 다음 예에서처럼 문자열의 공통 머리말 부분이 훨씬 긴 경우 짧게 축약하기 위해 사용된다: mkdir /usr/local/src/bash/&#123;old,new,dist,bugs&#125; 또는 chown root /usr/&#123;ucb/&#123;ex,edit&#125;,lib/&#123;ex?.?*,how_ex&#125;&#125; 중괄호 확장은 전통적인 버전의 sh, 본쉘(Bourne shell)과 약간의 비호환성을 가져왔다. sh 는 중괄호가 단어의 일부로 나타날 때 특별하게 처리하지 않고 그대로 보존하여 출력한다. Bash 는 단어로부터 중괄호를 제거하고 중괄호 확장을 한다. 예를 들어 sh 에서 file&#123;1,2&#125;는 출력에서도 그대로 file&#123;1,2&#125; 이다. bash 에서는 같은 단어에 대하여 중괄호 확장을 하여 file1 file 로 보여준다. 만약 sh 과의 철저한 호환성을 원할 때에는 bash 를 시작할 때 -nobraceexpansion 플래그를 붙여 실행하라. -nobraceexpansion ( 앞서 나온 옵션 참고 ) 또는 set 명령에서 +o braceexpand 옵션을 주어 중괄호 확장 기능을 해제할 수 있다. ( 쉘 내부 명령 참고 ) 틸드 확장(Tilde Expansion) 단어가 틸드 문자(`~')로 시작하면, 첫번째 슬래쉬 앞에 있는 모든 문자(또는 슬래쉬가 없는 경우에는 모든 문자)는 가능한 로그인 이름으로 간주한다. 로그인 이름이 널 문자열인 경우에는 HOME 매개변수의 값으로 틸드를 치환한다. HOME 가 설정되어 있지 않을 때에는 쉘을 실행 중인 사용자의 홈 디렉토리로 대신 치환한다. 틸드 다음에 `+'가 뒤따르면, 틸드와 `+'를 PWD 의 값으로 치환한다. `-'이 오는 경우에는 OLDPWD 변수 값으로 치환된다. 틸드 다음에 나오는 값이 유효한 로그인 이름일 때에는 틸드와 로그인 이름을 그 이름을 갖는 사용자의 홈 디렉토리로 치환한다. 이름이 유효하지 않을 때에는 틸드 확장이 실패할 것이며 그 때에는 단어를 그대로 놔둔다. 변수 지정을 시행할 때마다 : 또는 = 다음에 나오는 쿼우트하지 않은 틸드를 점검한다. 이 경우 틸드 확장이 시행된다. 따라서 PATH, MAILPATH, CDPATH 지정에서 틸드와 함께 경로명을 사용할 수 있으며 쉘은 그 확장된 값을 지정해준다. 매개변수 확장(Parameter Expansion) `$' 문자는 매개변수 확장, 명령 치환, 연산 확장을 시행하도록 한다. 확장할 매개변수 이름 또는 기호는 중괄호로 둘러 쌀 수도 있다. 확장할 변수 뒤에 따라 오는 문자들을 이름의 일부로 해석하지 않도록 보호할 때 사용한다. $&#123;매개변수&#125; 매개변수의 값으로 치환된다. 매개변수 가 한 개 이상의 숫자로 된 위치 매개변수이거나, 매개변수 다음에 문자열로 함께 해석하지 않아야 할 문자가 뒤따라 나오는 경우에는 중괄호가 필요하다. 아래의 모든 경우에서, 단어에 대하여 틸드 확장, 매개변수 확장, 명령 치환, 연산 치환가 시행된다. Bash 매개변수가 unset 상태인지 널인지 점검한다; 콜론을 빼면 unset 상태의 매개변수에 대한 점검만 행한다. $&#123;매개변수:-단어&#125; 기본값 사용. If 매개변수 가 unset 되어 있거나 널이면, 단어 의 확장으로 치환된다. 그렇지 않을 때에는 매개변수 의 값으로 치환된다. $&#123;매개변수:=단어&#125; 기본값을 지정. 매개변수 가 unset 되어 있거나 널이면, 단어 의 확장이 매개변수 로 지정된다. 그러면 매개변수 의 값 자체가 치환된다. 위치 매개변수와 특별한 매개변수는 이런 방식으로 지정할 수 없을 것이다. $&#123;매개변수:?단어&#125; 널이거나 unset 이면 에러를 출력한다. If 매개변수 가 널이거나 unset 상태면, 단어의 확장(또는 단어 가 존재하지 않으면 그에 대한 메시지) 이 표준 에러와 쉘에 출력하고 대화형 모드가 아닐 때에는 종료한다. 그렇지 않으면 매개변수의 값이 치환된다. $&#123;매개변수:+단어&#125; 다른 값 사용하기. 매개변수 가 널이거나 unset 이면, 아무 것도 치환되지 않고 그렇지 않으면 단어 의 확장으로 치환된다. $&#123;#매개변수&#125; 매개변수의 값으로 들어있는 문자열의 길이로 치환한다. 매개변수가 * 이거나 @ 일 때에는, 더블 쿼우트 안에서 * 이 확장되었을 때의 길이로 치환한다. $&#123;매개변수#단어&#125; $&#123;매개변수##단어&#125; 경로명 확장에서처럼 패턴을 만들기 위해 단어 가 확장된다. 만약 패턴이 매개변수 값의 첫 부분과 일치하면, 매개변수 값에서 가장 짧은 일치가 일어나는 패턴 내용을 삭제한 값 (``#''의 경우) 또는 가장 긴 일치가 일어나는 패턴을 삭제한 값 (``##''의 경우)으로 확장한다. $&#123;매개변수%단어&#125; $&#123;매개변수%%단어&#125; 경로명 확장에서처럼 패턴을 만들기 위해 단어 가 확장된다. 만약 패턴이 매개변수 값의 뒷 부분과 일치하면, 매개변수 값에서 가장 짧은 일치가 일어나는 패턴 내용을 삭제한 값 (``%''의 경우) 또는 가장 긴 일치가 일어나는 패턴을 삭제한 값 (``%%''의 경우)으로 확장한다. 명령 치환 명령 치환을 사용하여 명령 이름을 명령의 출력 결과로 치환할 수 있다. 다음 두 가지 형태를 가지고 있다: $(명령) 또는 `명령` Bash 는 명령을 실행하고 그 명령의 표준 출력으로 명령 치환을 교체하는 방식으로 확장을 실행한다. 표준 출력에서 뒷 부분의 개행문자는 삭제한다. 구식 백쿼우트 형식을 사용할 때, 백슬래쉬는 그 뒤에 $, `, \\ 이 따라오는 경우를 제외하고는 글자 그대로의 의미를 유지한다. $(명령) 형식을 사용할 때에는 괄호 사이에 있는 모든 글자가 명령을 구성한다; 어느 문자도 특별하게 취급받지 않는다. 명령 치환은 중첩할 수 있다. 구식 형태에서 중첩을 하려면 내부의 백쿼우트를 백슬래쉬로 해석금지시켜야 한다. 더블 쿼우트 안에서 치환이 일어나면 결과에 대하여 단어 분리, 경로명 확장은 시행되지 않는다. 연산 확장 연산 확장을 사용하여 연산식을 계산하고 그 결과 값으로 치환할 수 있다. 연산 확장에는 두 가지 형식이 있다: $[표현식] $((표현식)) The 표현식 은 더블 쿼우트 안에 있는 것처럼 취급한다. 그러나 중괄호와 괄호 안에 놓인 더블 쿼우트는 특별하게 대우하지 않는다. 표현식 안에 있는 모든 토큰은 매개변수 확장, 명령 치환, 쿼우트 제거 과정을 거친다. 연산 치환은 중첩 가능하다. 평가 작업은 뒤에 나올 연산 평가(ARITHMETIC EVALUATION) 에서 나열한 규칙에 따라 시행된다. 표현식 이 유효하지 않을 때 bash 는 실패를 뜻하는 메시지를 출력하고 더 이상 치환을 하지 않는다. 프로세스 치환 프로세스 치환은 명명된 파이프(FIFOs) 또는 오픈한 파일을 명명하는 /dev/fd 방식을 갖고 있는 시스템에서 지원된다. &lt;(리스트) 또는 &gt;(리스트)의 형식을 띤다. 프로세스 리스트는 입력 또는 출력을 FIFO 또는 /dev/fd의 파일에 연결하여 실행한다. 확장의 결과로 이 파일의 이름이 현재 명령의 인수로 전달된다. &gt;(리스트) 형식을 사용하면 파일에 쓰는 내용이 리스트에 대한 입력이 된다. &lt;(리스트) 형식을 사용하면 리스트의 출력을 얻기 위해 인수로 전달된 파일을 읽을 수 있어야 한다. 이를 지원하는 시스템에서 프로세스 치환은 매개변수와 변수 확장, 명령 치환, 연산 확장 과 동시에 일어난다. 단어 분리 쉘은 단어 분리 를 위하여 더블 쿼우트 안에서 일어나지 않은 매개변수 확장, 명령 치환, 연산 확장의 결과를 조사한다. 쉘은 IFS 값으로 들어있는 각 글자를 구분자(delimeter)로 사용하여 다른 확장의 결과를 단어로 분리한다. IFS 의 값이 정확히 &lt;스페이스&gt;&lt;탭&gt;&lt;개행문자&gt; 즉 기본값이라면, IFS 문자의 어떠한 조합도 단어를 구분하게 해준다. IFS 의 값이 기본값 아닌 값을 가지고 있는 경우에는, 화이트스페이스 문자가 IFS 값에 포함되어 있는 한, 단어의 앞뒤에 오는 화이트스페이스 문자 스페이스 와 탭 을 무시한다. IFS ( IFS 화이트스페이스 문자). IFS 화이트스페이스가 아닌 IFS 속의 모든 문자와 인접한 IFS 화이트스페이스 문자는 하나의 필드로 구분한다. IFS 화이트스페이스 문자의 연속도 구분자로 간주한다. IFS 값이 널이면 단어 분리는 일어나지 않는다. IFS 는 unset 할 수 없다. 명시적인 널 인수는 (\"\" 또는 '') 그대로 유지한다. 매개변수 의 확장 결과 만들어지는 널 인수는 제거된다. 확장이 일어나지 않은 경우에는 단어 분리도 일어나지 않는다는 사실을 잘 알아두어야 한다. 경로명 확장 단어 분리 후에는 -f 옵션이 설정되어 있지 않는 한, bash 는 단어 를 검색하면서 *, ?, [ 문자를 찾는다. 이러한 문자 중 하나가 나타나면 그 단어는 패턴 으로 간주하고 패턴과 일치하는 경로명을 알파벳 순으로 정렬한 리스트로 치환한다. 일치하는 경로명이 발견되지 않고 쉘 변수 allow_null_glob_expansion 가 unset되어 있으면 단어를 변경하지 않고 그대로 놔둔다. 이 변수가 설정되어 있기는 하지만 일치하는 것이 없다면, 단어를 제거한다. 경로명 생성 시에 패턴이 사용될 때, 이름의 시작 부분 또는 슬래쉬 바로 다음에 나오는 ``.'' 문자에 대해서는 쉘 변수 glob_dot_filenames 가 설정되어 있지 않은 한, 명시적인 일치가 이루어져야 한다. 슬래쉬 문자는 항상 명시적인 일치여야 한다. 다른 경우 ``.'' 문자는 특별하게 취급하지 않는다. 특수한 패턴 문자는 다음과 같은 의미를 지닌다: * 널 문자열을 포함한 모든 문자열과 일치한다. ? 모든 단일 문자와 일치한다. [...] 대괄호 안의 어떤 문자와도 일치한다. 문자 가운데 마이너스 부호가 있는 경우에는 범위 를 뜻한다; 두 문자 사이의 사전적 순서에 의거하여 위치하는 모든 문자(두 문자 포함)에 대하여 일치가 일어난다. [ 다음에 나오는 첫번째 문자가 ! 이거나 ^ 이면 괄호 안에 있는 모든 문자에 대하여 일치가 일어나지 않는다. - 또는 ] 에 대하여 일치를 시키려면 괄호 안에서 첫번째 또는 마지막 문자로 포함시키면 된다. 쿼우트 제거 앞서 말한 확장이 일어난 후, 쿼우트하지 않은 모든 \\, `, \" 문자는 제거한다.리다이렉션(REDIRECTION) 명령이 실행되기에 앞서 쉘에 의해 특별하게 해석되는 표시를 사용하여 입력과 출력을 방향 전환 또는 리다이렉트 할 수 있다. 현재 쉘 실행 환경에 대하여 파일을 열고 닫는 용도로 리다이렉션을 사용할 수도 있다. 다음에 나오는 리다이렉션 연산자는 간단한 명령 의 앞 또는 중간에 오거나 명령 의 뒤에 온다. 리다이렉션은 왼쪽부터 오른족으로 나타난 순서대로 처리한다. 다음 설명에 있어 파일 기술자 번호가 생략되어 있고 리다이렉션 연산자의 첫번째 문자가 &lt; 이면 이 리다이렉션은 표준 입력(파일 기술자 0 번)을 가리킨다. 리다이렉션 연산자의 첫번째 문자가 &gt; 이면 이 리다이렉션은 표준 출력(파일 기술자 1 번)을 가리킨다. 리다이렉션 연산자 다음에 나오는 단어는 중괄호 확장, 틸드 확장, 매개변수 확장, 명령 치환, 연산 확장, 쿼우트 제거, 경로명 확장을 거친다. 한 개 이상의 단어로 확장될 때에는 bash 가 에러를 보고한다. 리다이렉션의 순서가 매우 중요하다. 예를 들어, 다음 명령 ls &gt; dirlist 2&gt;&amp;1 는 표준 출력과 표준 에러 모두 dirlist 파일로 보내지만 다음 명령 ls 2&gt;&amp;1 &gt; dirlist 오로지 표준 출력만 dirlist 파일로 보낸다. 왜냐하면 표준 출력이 dirlist 파일로 방향 전환되기 전에 표준 에러가 표준 출력으로 복제되었기 때문이다. 입력 리다이렉션 입력 리다이렉션은 파일 기술자 n 또는 n 이 생략된 경우 표준 입력 (파일 기술자 0)으로 읽기 위해 단어 를 확장하여 나온 이름의 파일을 오픈하게 만든다. 입력 리다이렉션의 일반적인 형식은 다음과 같다: [n]&lt;단어 출력 리다이렉션 출력 리다이렉션은 파일 기술자 n 또는 n 이 생략된 경우 표준 출력 (파일 기술자 1)으로 쓰기 위해 단어 를 확장하여 나온 이름의 파일을 오픈하게 만든다. 출력 리다이렉션의 일반적인 형식은 다음과 같다: [n]&gt;단어 리다이렉션 연산자를 &gt;| 와 같이 적으면, set 내부 명령에 대한 -C 옵션 값을 점검하지 않고 파일 생성을 시도한다. ( 위에서 나온 쉘 변수 섹션의 noclobber 설명을 참고 ) 추가 출력 리다이렉션 추가 출력 리다이렉션은 파일 기술자 n 또는 n 이 생략된 경우 표준 출력 (파일 기술자 1)으로 추가하기 위해 단어 를 확장하여 나온 이름의 파일을 오픈하게 만든다. 파일이 존재하지 않으면 생성한다. 출력 추가하기의 일반적인 형식은 다음과 같다: [n]&gt;&gt;단어 표준 출력과 표준 에러 리다이렉션 Bash 는 지금 설명할 표기법을 사용하여 표준 출력(파일 기술자 1)과 표준 에러 출력(파일 기술자 2) 둘 다 단어 의 확장 결과 나오는 이름의 파일로 방향전화시킬 수 있다. 표준 출력과 표준 에러를 동시에 리다이렉트하는 두 가지 형식이 있다: &amp;&gt;단어 and &gt;&amp;단어 두 가지 형식 중 첫번째 것을 선호한다. Of the two forms, the first is preferred. 위 형식은 다음과 문법적으로 동일하다. &gt;단어 2&gt;&amp;1 HERE 문서 이 유형의 리다이렉션은 쉘로 하여금 자신의 현재 소스로부터 단어 (뒤에 공백이 없이) 만 나오는 줄이 나올 때가지 입력으로 읽어들이도록 지시한다. 이 지점까지의 모든 행은 명령에 대한 표준 입력으로 사용된다. HERE 문서의 형식은 다음과 같다: &lt;&lt;[-]단어 HERE-문서 구분자 단어 에 대해서는 어떠한 매개변수 확장, 명령 치환, 경로명 확장, 또는 연산 확장도 시행되지 않는다. 단어 안의 문자에 대하여 쿼우트된 것이 있다면 구분자 는 단어 로부터 쿼우트를 제거한 결과이며 HERE 문서의 행은 확장되지 않는다. 그렇지 않을 때에는 HERE 문서의 모든 행에 대하여 매개변수 확장, 명령 치환, 연산 치환이 시행된다. 후자의 경우, \\&lt;개행문자&gt; 는 무시하며 \\, $, ` 문자를 쿼우트할 때에는 \\ 를 사용한다. 리다이렉션 연산자가 &lt;&lt;- 라면, 입력행과 구분자 를 포함하는 행에서 앞에 나오는 모든 탭 문자를 제거한다. 이 기능을 사용하면 쉘 스크립트 내부의 HERE 문서에서도 자연스럽게 들여쓰기를 사용할 수 있다. 파일 기술자 복제하기 다음 리다이렉션 연산자 [n]&lt;&amp;단어 는 입력 파일 기술자를 복제할 때 사용한다. 단어 가 한 개 이상의 숫자로 확장되면, n 이 가리키는 파일 기술자는 그 파일 기술자의 복사본이 된다. 만약 단어 의 결과가 - 라면 , 파일 기술자 n 은 닫힌다. n 를 명시하지 않으면, 표준 입력(파일 기술자 0)을 사용한다. 다음 연산자 [n]&gt;&amp;단어 는 마찬가지로 출력 파일 기술자를 복제할 때 사용한다. n 이 생략되어 있으면 표준 출력(파일 기술자 1)이 사용된다. 특별한 경우로서, n이 생략되어 있고 단어가 한 개 이상의 숫자로 확장되지 않을 때에는 앞에서 설명한 것처럼 표준 출력과 표준 에러가 리다이렉트된다. 읽기 쓰기를 위해 파일 기술자 열기 다음 리다이렉션 연산자 [n]&lt;&gt;단어 는 읽기와 쓰기를 위해 파일 기술자 n 또는 n 이 생략된 경우 표준 입력과 표준 출력으로 단어 의 확장 결과로 나오는 이름을 가진 파일을 오픈하도록 한다. 파일이 존재하지 않는 경우 생성된다.함수(FUNCTIONS) 앞서 나온 쉘 문법 섹션에서 정의한 바 있는 쉘 함수는 이후의 실행을 위해 명령의 나열을 저장해둔다. 함수는 현재 쉘 상황에서 실행된다; 함수를 해석하기 위해 새로운 프로세스가 만들어지지는 않는다.(이는 쉘 스크립트 실행과 대조적이다.) 함수가 실행되면 실행 중에는 함수에 대한 인수가 위치 매개변수로 바뀐다. 특별한 매개변수인 # 는 이 변화를 반영하기 위해 갱신된다. 위치 매개변수 0 은 바뀌지 않는다. 함수에 지역적인 변수는 내부 명령 local 을 사용하여 선언할 수 있다. 보통은 변수와 그 값은 함수와 호출한 자가 공유한다. 내부 명령 return 이 함수 안에서 실행되면 함수는 실행을 완료하고 함수 호출 바로 다음부터 실행이 재개된다. 함수 실행이 완료되면 위치 매개변수와 특별한 매개변수 # 의 값이 함수 호출 이전 상태로 복원된다. 함수 이름과 정의는 내부 명령 declare 또는 typeset 명령에 -f 옵션을 주어 나열할 수 있다. 내부 명령 export 에 -f 옵션을 주면 서브쉘에서도 자동으로 정의되도록 함수를 export할 수 있다. 함수는 재귀 호출할 수 있다. 재귀 호출의 횟수에 대한 제한 사항은 없다.앨리어스 또는 별칭(ALIASES) 쉘은 내부 명령 alias 와 unalias 로 설정하고 해제할 수 있는 앨리어스(aliases) 목록을 관리한다. ( 쉘 내부 명령 참고 ). 쿼우트하지 않은 각 명령의 첫번째 단어에 대해서는 앨리어스가 있는지 점검한다. 앨리어스가 있으면 그 단어는 앨리어스의 텍스트 내용으로 치환된다. 앨리어스 이름과 치환 텍스트는 메타문자 를 포함하여 유효한 쉘 입력을 포함할 수 있다. 그러나 예외적으로 앨리어스 이름에 =를 포함할 수 없다. 치환 텍스트의 첫번째 단어에 대하여 앨리어스가 있는지 점검한다. 그러나 확장하려는 앨리어스와 똑같은 단어는 두 번 확장하지 않는다. 즉, 다음과 같이 ls 의 앨리어스를 다음과 같이 ls -F 라고 정의할 수 있으며 bash 는 치환 텍스트를 회귀적으로 확장하려 하지 않는다. 앨리어스 값의 마지막 문자가 공백 이면, 앨리어스 다음에 나오는 명령 단어에 대해서도 앨리어스 확장 여부를 점검한다. 앨리어스는 alias 명령을 사용하여 만들고 열거하며 unalias 명령을 사용하여 제거한다. csh 에서처럼 치환 텍스트에서 인수를 사용하게 해주는 메커니즘은 없다. 인수가 필요할 때에는 쉘 함수를 사용해야 한다. 쉘이 대화형 모드가 아닐 때에는 앨리어스를 확장하지 않는다. 앨리어스의 정의와 사용법에 대한 규칙은 약간 혼란스럽다. Bash 는 항상 어떤 행에 존재하는 명령을 실행하기에 앞서 최소한 완전한 한 행을 읽는다. 앨리어스를 실행할 때가 아니라 명령을 읽어들일 때 확장된다. 따라서, 다른 명령과 같은 행에 나타나는 앨리어스 정의는 다음 행을 읽을 때까지 효력을 발휘하지 않는다. 같은 행에서 앨리어스 정의 다음에 나오는 명령은 새로운 앨리어스의 영향을 받지 않는다. 이 행동 방식은 함수가 실행될 때에도 문제가 된다. 함수 정의 자체가 복합 명령이기 때문에 함수를 실행할 때가 아니라 함수 정의를 읽을 때 앨리어스를 확장한다. 결과적으로 함수 안에 정의된 앨리어스는 다른 함수를 실행하기 전까지는 사용되지 않는다. 안전하게 하기 위해 앨리어스 정의는 항상 개별적인 행에 적고 복합 명령에서는 앨리어스 를 사용하지 말라. 거의 모든 용도에서 앨리어스 대신 함수를 사용하는 것이 좋다는 점을 기억하라.작업 제어(JOB CONTROL) 작업 제어 란 선택적으로 프로세스의 실행을 멈추고 (일시 중지(suspend)) 나중에 중단된 실행을 계속하도록 할 수 있는 (작업 재개(resume)) 기능을 말한다. 사용자는 일반적으로 시스템의 터미널 드라이버와 bash 에서 제공하는 대화형 인터페이스를 통해 이 기능을 사용한다. 쉘은 각 파이프라인에 작업 을 연관시킨다. 쉘은 현재 실행 중인 작업 도표를 지니고 있으며 jobs 명령을 사용하여 나열해 볼 수 있다. bash 가 작업을 비동기적으로 ( 백그라운드 로) 시작할 때는, 다음과 유사한 행을 출력한다: [1] 25647 이 작업의 작업 번호가 1 이며 이 작업과 연관된 파이프라인의 마지막 프로세스의 프로세스 ID가 25647 이라는 사실을 알려준다. Bash 는 작업 제어를 위해 그 기초로서 작업 추상화를 사용한다. 작업 제어에 대한 사용자 인터페이스를 구현을 할 수 있도록 시스템에서는 현재 터미널 프로세스 그룹 ID라는 것을 관리한다. 이 프로세스 그룹의 멤버(자신의 프로세스 그룹 ID가 현재 터미널 프로세스 그룹 ID와 동일한 프로세스들)는 SIGINT 와 같이 키보드를 통해 발생시키는 시그널을 받는다. 이러한 프로세스는 포그라운드 에 놓여 있다고 말한다. 백그라운드 프로세스란 자신의 프로세스 그룹 ID가 터미널의 프로세스 그룹 ID와 다른 프로세스를 말한다; 이 프로세스는 키보드를 통해 발생시키는 시그널에 면역을 가진다. 오로지 포그라운드 프로세스만이 터미널로부터 읽고 터미널에 쓸 수 있다. 터미널로부터 읽거나 쓰려고 시도하는 백그라운드 프로세스는 터미널 드라이버가 보내는 SIGTTIN (SIGTTOU) 시그널을 받는다. 그리고 이를 잡아 처리하지 않으면 프로세스를 일시 중지시킨다. bash 가 실행 중인 운영체제에서 작업 제어를 지원하면 bash 는 여러분으로 하여금 작업 제어 기능을 사용할 수 있도록 해준다. 프로세스 실행 중 일시중지 문자 ( 보통 ^Z, Control-Z)를 누르면 프로세스가 멈추고 여러분에게 bash 프롬프트가 나온다. 지연된 일시중지(delayed suspend) 문자를 누르면(보통 ^Y, Control-Y)프로세스가 터미널로부터 입력을 받으려고 할 때 중지되며 bash 로 제어권이 넘어온다. 그 다음에는 bg 명령을 사용하여 백그라운드에서 실행을 계속하도록 하거나 fg 명령을 사용하여 포그라운드에서 실행을 계속하도록 또는 kill 명령을 사용하여 죽이는 등 작업의 상태를 제어할 수 있다. ^Z는 즉시 효력을 발휘하며 아직 출력되지 않은 내용과 타이핑을 했으나 입력 처리되지 않은 내용은 버린다. 쉘에서 어떤 작업을 지시하는 방법은 몇 가지 있다. % 문자는 작업 이름과 관련있다. 작업 번호 n 은 %n 으로 표시한다. 또한 작업을 시작할 때 사용했던 이름의 앞 글자나 명령행의 일부 문자열을 사용하여 가리킬 수 있다. 예를 들어, %ce 는 중단된 ce 작업을 가리킨다. job. 접두어가 하나 이상의 작업과 일치할 때에는 bash 가 에러를 보고한다. 한편 %?ce 를 사용하면, 명령행 중간에 ce 를 포함하고 있는 작업을 가리킨다. 그 일부 문자열과 일치하는 작업이 여러 개일 때에는 bash 가 에러를 보고한다. %% 표시와 %+ 표시는 쉘에서 포그라운드에 있던 동안 중단된 가장 최신의 작업을 가리키며 현재 작업(current job) 이라 부른다. 이전 작업(previous job) 은 %- 표시를 통해 가리킬 수 있다. 작업을 가리키는 출력 내용에서 (예를 들어, jobs 명령의 출력 내용) 현재 작업은 항상 + 로 표시하고, 이전 작업은 - 로 표시한다. 간단히 작업 이름을 지칭하기만 해도 작업이 포그라운드로 돌아온다: %1 는 ``fg %1''와 같은 뜻이며, 작업 1 번을 백그라운드에서 포그라운드로 오게 한다. 마찬가지로 ``%1 &amp;'' 는 작업 1 번을 백그라운드에서 작업 재개를 하도록 하며 ``bg %1'' 와 같다. 쉘은 작업이 상태를 바꿀 때마다 그 상황을 안다. 보통의 경우, bash 는 다른 출력 내용을 방해하지 않기 위해 프롬프트를 출력할 때까지 기다렸다가 작업의 상태의 변화를 보고한다. set 내부 명령에 -b 옵션을 주었다면, bash 는 변화 내용을 즉시 보고한다. (앞서 나온 쉘 변수 섹션의 notify 설명을 참고하라.) 작업이 중단된 상태에서 bash 를 종료하려고 하면, 쉘은 경고 메시지를 출력한다. 여러분은 jobs 명령을 사용하여 작업의 상태를 조사할 수 있다. 이 명령을 실행하거나 곧바로 다시 종료를 시도하면 경고는 나오지 않으며 중단된 작업은 종료한다.시그널(SIGNALS) bash가 대화형 모드일 때에는 SIGTERM 는 무시하고 (따라서 kill 0해도 대화형 쉘은 죽지 않는다), SIGINT 는 잡아서 처리한다.(따라서 wait 내부 명령은 인터럽트 가능하다) 어떤 경우든 bash는 SIGQUIT 를 무시한다. 작업 제어 중일 때 bash 는 SIGTTIN, SIGTTOU, SIGTSTP 를 무시한다. bash가 시작한 동기화된 작업은 부모로부터 쉘에 의해 상속받은 값으로 시그널을 설정한다. 작업 제어 중이 아닐 때 백그라운드 작업은 ( &amp; 로 시작한 작업 ) SIGINT , SIGQUIT 를 무시한다. 명령 대체의 결과로 실행된 명령은 키보드에 의해 발생하는 작업 제어 시그널인 SIGTTIN, SIGTTOU, SIGTSTP 를 무시한다.명령 실행(COMMAND EXECUTION) 명령이 단어로 분리된 후, 그 결과 간단한 명령과 인수 목록이 나오면, 다음 행동이 취해진다. 명령 이름에 슬래쉬가 포함되어 있지 않으면 쉘을 명령의 위치를 찾는다. 만약 그 이름을 가진 쉘 함수가 존재하면 FUNCTIONS 섹션에서 설명한 것처럼 함수가 실행된다. 그런 함수가 없으면 쉘 내부 명령 목록을 검색한다. 만약 일치하는 것이 발견되면 내부 명령이 실행된다. 쉘 함수 또는 내부 명령 중 어느 것과도 일치하지 않고 슬래쉬를 포함하고 있지 않으면, bash 는 그 이름을 가진 실행 파일이 들어있는 디렉토리를 찾기 위해 PATH 의 각 원소를 검색한다. 검색에 실패하면 쉘은 에러 메시지를 출력하고 0 아닌 종료 상태값을 반환한다. 검색에 성공하거나 또는 명령 이름에 하나 이상의 슬래쉬가 포함되어 있을 때에는 그 이름을 가진 프로그램을 실행한다. 전달 인수 0 는 그 이름으로 설정되고, 나머지 전달 인수가 있다면 명령에 대한 전달 인수로 설정된다. 실행 파일 형식이 아니거나 디렉토리가 아니어서 실행이 실패하면 쉘 명령을 포함하고 있는 쉘 스크립트로 간주한다. 쉘 스크립트를 실행하기 위해 서브쉘을 생성한다. 서브쉘 자체로 다시 초기화하기 때문에 부모 쉘이 기억하고 있는 명령 위치를 기억한다는 점을 제외하고, 나머지 사항에 대해서는 스크립트를 처리하기 위해 새로운 쉘이 실행된 것이나 다름없다. ( 쉘 내부 명령 섹션의 hash 참고 ) 만약 프로그램이 #! 로 시작하는 파일이라면, 첫번째 행의 나머지 부분은 그 프로그램에 대한 해석기이다. 쉘은 이 실행 파일 형식을 그 자체로 다루지 못하는 운영체제 상에서 주어진 해석기를 실행한다. 해석기에 대한 전달 인수는 프로그램의 첫번째 행에서 해석기 이름 다음에 나오는 단일 옵션, 그 다음의 프로그램 이름으로 구성되며 명령 인수가 따라 나오면 그것도 포함한다.환경(ENVIRONMENT) 프로그램이 실행될 때 프로그램은 환경 이라고 부르는 문자열 배열을 받는다. 이름=값 의 형식을 갖는 이름-값의 쌍으로 이루어진 목록이다. 쉘에서 여러 가지 방법으로 환경을 조작할 수 있는 방법을 제공한다. 실행할 때, 쉘은 자신의 환경 변수를 검색한 후 각 이름에 대하여 매개변수를 생성하고 자식 프로세스에게 export 하기 위해 자동으로 표시해 둔다. export 와 declare -x 명령을 사용하여 매개변수와 함수를 환경에 추가하거나 삭제할 수 있다. 환경의 매개변수 값을 변경하면 새로운 값이 예전 값을 치환하여 환경의 일부가 된다. 실행한 명령이 상속한 환경은 쉘의 초기 환경(값을 변경할 수 있음)에서 unset 명령으로 제거한 것을 빼고 export 와 declare -x 명령을 통해 추가한 것으로 이루어진다. 간단한 명령 또는 함수에 대한 환경은 매개변수 섹션에서 설명한 것처럼 매개변수 지정문을 앞에 두어 임시로 추가할 수 있다. 이러한 지정문은 그 명령의 환경에 대해서만 유효하다. -k 플래그가 설정되어 있으면( 아래의 set 내부 명령 참고) 명령 앞에 적은 것만이 아니라 모든 매개변수 지정문이 명령에 대한 환경에 놓이게 된다. bash 가 외부 명령을 실행할 때 _ 변수는 명령의 완전한 경로명으로 설정되고 그 명령의 환경에 전달된다.종료 상태 쉘에 있어 종료 상태값 0 인 명령은 성공으로 간주한다. 0 이라는 종료 상태값은 성공을 뜻한다. 0 이 아닌 종료 상태값은 실패를 가리킨다. 심각한 시그널을 받아 명령이 종료하면 bash는 종료 상태값으로 128+시그널 값을 사용한다. 명령을 찾을 수 없을 때 그 명령을 실행하기 위해 생성한 자식 프로세스는 127 이라는 값을 반환한다. 명령을 찾았으나 실행 파일이 아는 경우에는 126 을 반환한다. bash 그 자체는 문법 오류 때문에 0 아닌 값을 반환하는 경우가 아니라면, 실행한 마지막 명령의 종료 상태값을 반환한다. 뒤에 나오는 exit 내부 명령도 참고하라.프롬프트(PROMPTING) 대화형 모드로 실행하면서, bash 는 명령을 읽을 준비가 되어 있을 때 주 프롬프트인 PS1 를 표시하고 명령을 완성하기 위해 추가 입력이 필요할 때에는 두번째 프롬프트인 PS2 를 표시한다. Bash 는 다음과 같이 해석되는 백슬래쉬-해석금지된 특수 문자를 이용하여 프롬프트를 정의하여 사용할 수 있도록 해준다: \\t 현재 시간을 HH:MM:SS 형식으로 표시 \\d 날자를 \"요일 월 일\" 형식으로 표시 (예, \"Tue May 26\") \\n 개행문자 \\s 쉘의 이름, $0 의 베이스 이름 (마지막 슬래쉬 뒷 부분) \\w 현재 작업 디렉토리 \\W 현재 작업 디렉토리의 베이스 이름 \\u 현재 사용자의 사용자명 \\h 호스트 이름 \\# 이 명령의 명령 번호 \\! 이 명령의 히스토리 번호 \\$ 유효 UID가 0 이면 if the effective UID is 0, a #, 그렇지 않으면 $ \\nnn 팔진수 nnn에 해당하는 문자 \\\\ 백슬래쉬 \\[ 비출력 문자의 시퀀스를 시작한다. 프롬프트에 터미널 제어 시퀀스를 넣을 때 사용한다. \\] 비출력 문자의 시퀀스를 마친다. 명령 번호와 히스토리 번호는 일반적으로 다르다: 명령의 히스토리 번호는 히스토리 목록에서의 위치로서 이 목록에는 히스토리 파일로부터 복원된 명령들이 들어있을 수 있는 반면, ( 뒤에 나오는 히스토리(HISTORY) 참고 ) 명령 번호는 현재의 쉘 세션 동안 실행한 명령 순서에서의 위치이다. 문자열을 해독한 후, 매개변수 확장, 명령 대체, 연산 확장, 단어 분리를 통해 확장한다.READLINE -nolineediting 옵션을 주지 않은 한, 대화형 쉘에서 입력을 읽기를 처리해 주는 라이브러리이다. 기본적으로 행 편집 명령은 이맥스의 명령과 비슷하다. vi 스타일의 행 편집 인터페이스도 제공된다. 이 섹션에서 키 입력을 표기할 때 이맥스 스타일의 표기 방법을 사용한다. 컨트롤 키는 C-키로 표기한다. 예를 들어 C-n은 컨트롤-N을 뜻한다. 마찬가지로, 메타 키는 M-키로 표기하며 따라서 M-x는 메타-X를 뜻한다. ( 메타 키가 없는 키보드에서 M-x는 ESC x를 뜻한다. 이스케이프 키를 누른 다음 x 키를 누른다. ESC는 메타 접두어이다. M-C-x 조합은 ESC-컨트로-x 또는 이스케이프 키를 누른 후 컨트롤 키를 누른 채 x 키를 누르는 것을 뜻한다.) 기본 키-바인딩은 ~/.inputrc 파일을 사용하여 변경할 수 있다. 쉘 변수 INPUTRC 이 설정되어 있으면 그 값을 ~/.inputrc 대신 사용한다. 이 라이브러리를 사용하는 다른 프로그램에서 자신만의 명령과 바인딩을 추가할 수 있다. 예를 들어 M-Control-u: universal-argument 또는 C-Meta-u: universal-argument 를 ~/.inputrc 에 적으면 M-C-u이 readline 명령인 universal-argument 을 실행하게 된다. 다음의 심볼 문자 이름을 인식한다: RUBOUT, DEL, ESC, LFD, NEWLINE, RET, RETURN, SPC, SPACE, TAB. 명령 이름에 덧붙여, readline은 키에다 문자열을 결합하여 키를 누르면 문자열이 삽입되도록 해준다.(매크로) readline은 초기화 파일에 명령을 넣어 조정하여 사용할 수 있다. 이 파일의 이름은 INPUTRC 변수의 값으로부터 취한다. 변수가 unset 상태이면 기본값은 ~/.inputrc 이다. readline 라이브러리를 사용하는 프로그램이 시동하면 초기화 파일을 읽고 키 바인딩과 변수를 설정한다. readline 초기화 파일에서는 몇 가지 기본적인 구조만 사용할 수 있다. 공백 행은 무시한다. #로 시작하는 행은 주석이다. $로 시작하는 행은 조건 구조이다. 이외의 행은 키 바인딩 또는 변수 설정을 나타낸다. ~/.inputrc 파일 안에서 키 바인딩을 제어하는 문법은 간단하다. 명령의 이름 또는 결합되는 매크로와 키 시퀀스의 텍스트만이 필요하다. 이름은 두 가지 중 한 가지 방식을 사용하여 명시할 수 있다: Meta- 또는 Control- 접두어를 사용하는 심볼 키 이름 또는 키 시퀀스이다. 키이름:함수-이름 또는 매크로 형식을 사용할 때, 키이름 이란 영어로 된 키 이름이다. 예를 들어: Control-u: universal-argument Meta-Rubout: backward-kill-word Control-o: \"&gt;&amp;output\" 위 예에서, C-u 는 universal-argument 라는 함수에 결합된다. M-DEL 은 backward-kill-word 함수에 결합되고, C-o 는 오른쪽에 적은 매크로를 실행하도록 결합된다.(즉, &gt;&amp;output 라는 텍스트를 행에 추가한다.) 두번째 형태인, \"키시퀀스\":함수-이름 또는 매크로에서, 키시퀀스 는 전체 키 시퀀스를 더블 쿼우트 안에 넣어 표시할 수 있다는 점에서 키이름 과 다르다. 다음 예에서처럼 일부 GNU 이맥스 스타일의 키 이스케이프를 사용할 수 있다. \"\\C-u\": universal-argument \"\\C-x\\C-r\": re-read-init-file \"\\e[11~\": \"Function Key 1\" 이 예에서, C-u 는 universal-argument 함수에 결합된다. C-x C-r 는 re-read-init-file 함수에 결합되고, ESC [ 1 1 ~ 는 Function Key 1 라는 텍스트를 입력하도록 결합된다. 이스케이프 시퀀스는 다음과 같다: \\C- 컨트롤 접두어 \\M- 메타 접두어 \\e 이스케이프 문자 \\\\ 백슬래쉬 \\\" 글자 그대로의 \" \\' 글자 그대로의 ' 매크로 텍스트를 넣을 때에는 매크로 정의라는 것을 지시하기 위해 싱글 또는 더블 쿼우트를 사용해야 한다. 쿼우트하지 않은 텍스트는 함수 이름이라고 간주한다. 백슬래쉬는 \" 와 ' 를 포함하여 매크로 텍스트 안의 모든 문자를 쿼우트할 수 있다. Bash 에서는 bind 내부 명령을 사용하여 현재의 readline 키 바인딩을 표시하거나 수정할 수 있다. set 내부 명령에 -o 옵션을 주어 대화형 모드에서 편집 모드를 전환할 수 있다. ( 쉘 내부 명령 참고 ) Readline에는 행동 방식을 좀 더 변경할 수 있도록 해주는 변수가 있다. 이 변수는 inputrc 파일에 set 변수-이름 값 의 형식을 갖는 문장을 통해 설정할 수 있다. 특별히 거론하는 경우를 제외하고 readline 변수는 On 또는 Off 의 값을 취한다. 변수와 각 기본값은 다음과 같다: horizontal-scroll-mode (Off) On으로 설정하면 readline은 한 줄로 화면에 표시하며 화면 폭보다 긴 입력에 대해서는 자동으로 줄바꿈하지 않고 수평 방향으로 스크롤한다. editing-mode (emacs) readline이 emacs 와 vi와 유사한 키 바인딩 집합 중 어느 것으로 시작할 것인지 제어한다. editing-mode 모드는 emacs 또는 vi 이 가능하다. mark-modified-lines (Off) On로 설정하면 히스토리 중 수정된 사항은 그 앞에 애스테리스크 (*)를 넣어 표시한다. bell-style (audible) readline에서 터미널 벨을 울리고자 할 때 어떻게 할 것인지 제어한다. none으로 설정하면 소리를 내지 않는다. visible로 설정하면 사용 가능한 경우 비주얼 벨을 사용한다. audible로 설정하면 터미널의 벨 기능을 시도한다. comment-begin (``#'') vi-comment 명령이 실행될 때 vi 모드에서 삽입되는 문자열 meta-flag (Off) On으로 설정하면 터미널의 지원 여부와 상관없이 8 비트 입력을 가능케 한다.(즉 읽어 들이는 문자의 상위 비트를 자르지 않는다.) convert-meta (On) On으로 설정하면 8 비트 문자를 8 번째 비트 제거한 ASCII 키 시퀀스 앞에 이스케이프 문자를 넣어 변환한다.(실제로 메타 접두어를 이스케이프로 사용한다.) output-meta (Off) On으로 설정하면 8 번째 비트를 포함하고 있는 문자열을 표시할 때 메타 접두어를 사용한 이스케이프 시퀀스로 표시하지 않고 그대로 직접 표시한다. completion-query-items (100) possible-completions 명령에 의하여 발생된 가능한 완성 목록의 갯수가 몇 개를 넘으면 사용자에게 물어볼 것인지 결정한다. 0 보다 크거나 같은 정수로 설정한다. 가능한 완성의 갯수가 이 변수의 값보다 크면 사용자에게 전체를 볼 것인지 아닌지 묻는다; 그렇지 않을 때에는 그냥 터미널에 나열한다. keymap (emacs) 현재 readline 키맵을 설정한다. 가능한 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, vi-insert 가 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다. 기본값은 emacs 이다; editing-mode 의 값이 또한 기본 키맵에 영향을 준다. show-all-if-ambiguous (Off) 완성 함수의 기본 행동 방식을 변경한다. on 으로 설정하면 하나 이상의 완성이 가능한 단어에 대하여 소리를 내지 않고 즉시 그 목록을 보여준다. expand-tilde (Off) on으로 설정하면 단어 완성을 시도할 때 틸드 확장을 한다. Readline은 키 바인딩과 변수 설정을 테스트의 결과에 따라 수행하게 해주는 C 전처리기의 조건적 컴파일과 유사한 기능을 구현하고 있다. 3 가지 파서 지시자가 사용된다. $if $if 구조를 사용하여 편집 모드, 사용하고 있는 터미널, readline을 사용하는 애플리케이션에 따라 바인딩을 다르게 할 수 있다. 테스트 텍스트는 행의 끝까지이다; 테스트 텍스트를 다른 것과 구분하는 문자는 없다. mode $if 지시자의 mode= 형태는 readline이 이맥스 모드인가 vi 모드인가 테스트할 때 사용한다. 예를 들어, set keymap 명령과 함께 사용하여 readline이 이맥스 모드로 시작했을 때에만 emacs-standard의 바인딩과 emacs-ctlx 키맵을 설정하도록 할 수 있다. term term= 형태는 터미널의 펑션 키에 키 시퀀스 출력을 결합하는 등의 특정 터미널 키 바인딩에서 사용한다. = 의 오른쪽 단어를 터미널의 완전한 이름과 이름 중 첫번째 -의 앞 부분과 테스트한다. 예를 들어, sun 은 sun 과 sun-cmd 둘 다 일치하게 된다. application application 구조는 애플리케이션별 설정을 포함할 때 사용한다. readline 라이브러리를 사용하는 각 프로그램은 애플리케이션 이름을 설정하며 초기화 파일에서 이 특정값을 테스트할 수 있다. 특정 프로그램에서 유용한 함수에 키 시퀀스를 결합하는데 사용된다. 예를 들어, 다음 명령은 bash에서 현재 또는 이전 단어를 쿼우트하는 키 시퀀스를 추가한다: $if Bash # Quote the current or previous word \"\\C-xq\": \"\\eb\\\"\\ef\\\"\" $endif $endif 이 명령은 앞에서 본 것처럼 $if 명령을 종결한다. $else 이 가지에 속한 명령은 $if 지시자의 테스트에 실패했을 때 실행된다. Readline 명령에는 수치 인수 를 줄 수 있는데 일반적으로 반복 횟수를 의미한다. 하지만 종종 인수의 부호가 중요할 때가 있다. 앞 방향으로 동작하는 명령(예, kill-line) 에 음수 인수를 전달하면 뒷 방향으로 동작한다. 전달한 인수에 따라 명령의 행동 방식이 바뀌는 것에 대해서는 언급한다. 어떤 명령이 텍스트를 죽인다(kill)라고 할 때, 삭제된 그 텍스트는 나중에 불러 사용할 것을 위해 저장된다.(yanking이라고 부른다) 죽인 텍스트는 kill-ring이라는 곳에 보관된다. 연속적으로 텍스트를 죽이면 한 단위로 축적되어 한 번에 다시 yank할 수 있다. 텍스트를 죽이지 않는 명령은 kill-ring에서 텍스트를 서로 분리한다. 다음은 명령 이름과 기본값으로 결합되어 있는 키 시퀀스 목록이다. 이동을 위한 명령 beginning-of-line (C-a) 현재 행의 처음으로 이동 end-of-line (C-e) 현재 행의 끝으로 이동 forward-char (C-f) 한 문자 앞으로 이동 backward-char (C-b) 한 문자 뒤로 이동 forward-word (M-f) 다음 단어의 끝으로 전진 이동. 단어는 알파벳숫자 문자로 구성된다. (문자와 숫자) backward-word (M-b) 현재 단어 또는 이전 단어의 처음으로 후진 이동. 단어는 알파벳숫자 문자로 구성된다. (문자와 숫자) clear-screen (C-l) 현재 행을 화면 상단에 두고 화면을 지운다. 인수가 있으면 화면을 지우지 않은 채 현재 행을 갱신한다. redraw-current-line 현재 행을 갱신한다. 기본적으로 결합된 키가 없다. 히스토리 처리 명령 accept-line (Newline, Return) 커서가 어디에 있든 행을 받아들인다. 빈 행이 아니면 HISTCONTROL 변수의 상태에 따라 히스토리 목록에 추가한다. 만약 히스토리 행을 수정한 것이라면 히스토리 행을 원래 상태로 복원한다. previous-history (C-p) 히스토리 목록에서 뒤로 이동하여 이전 명령을 가져온다. next-history (C-n) 히스토리 목록에서 앞으로 이동하여 다음 명령을 가져온다. beginning-of-history (M-&lt;) 히스토리의 첫번째 행으로 이동 end-of-history (M-&gt;) 입력 히스토리의 끝으로 이동. 즉, 현재 입력하고 있던 행으로 돌아옴 reverse-search-history (C-r) 현재 행부터 시작하여 히스토리를 올라가면서 후방으로 검색한다. 누적 검색이다. forward-search-history (C-s) 현재 행부터 시작하여 히스토리를 내려가면서 전방으로 검색한다. 누적 검색이다. non-incremental-reverse-search-history (M-p) 현재 행부터 시작하여 히스토리를 후방으로 검색하되 누적 검색을 하지 않는다. non-incremental-forward-search-history (M-n) 현재 행부터 시작하여 히스토리를 전방으로 검색하되 누적 검색을 하지 않는다. history-search-forward 현재 행의 시작부터 현재 점까지의 문자열을 히스토리에서 전방으로 검색한다. 누적 검색을 하지 않는다. 기본적으로 결합되어 있지 않다. history-search-backward 현재 행의 시작부터 현재 점까지의 문자열을 히스토리에서 후방으로 검색한다. 누적 검색을 하지 않는다. 기본적으로 결합되어 있지 않다. yank-nth-arg (M-C-y) 현재 커서 지점에서 이전 명령에 대한 첫번째 인수를 삽입한다. (보통 이전 행의 두번째 단어에 해당된다.) 인수 n 을 적으면 이전 명령으로부터 n 번째 단어를 삽입한다.(이전 명령의 단어는 0 부터 순서를 매긴다) 음수인 경우 이전 명령의 끝에서 n 번째 단어를 삽입한다. yank-last-arg (M-., M-_) 이전 명령의 마지막 인수를 삽입한다.(이전 행의 마지막 단어) 인수를 주면 yank-nth-arg과 동일하게 동작한다. shell-expand-line (M-C-e) 쉘이 입력을 받는 동안 하는 것처럼 행을 확장한다. 모든 쉘 단어 확장은 물론 앨리어스, 히스토리 확장을 수행한다. 히스토리 확장에 대해서는 뒤에 나오는 히스토리 확장 을 참고하라. history-expand-line (M-^) 현재 행에 대하여 히스토리 확장을 수행한다. 히스토리 확장에 대해서는 뒤에 나오는 히스토리 확장 을 참고하라. insert-last-argument (M-., M-_) yank-last-arg와 동의어 operate-and-get-next (C-o) 현재 행을 받아들여 실행하고 편집을 위하여 히스토리로부터 현재 행에 대하여 다음 행을 가져온다. 모든 인수는 무시한다. 텍스트 변경 명령 delete-char (C-d) 커서 아래 있는 문자를 삭제한다. 행의 시작 부분에 있을 때, 행에 아무런 글자도 없을 때 그리고 마지막 문자를 입력하지 않았을 때 C-d 는 EOF 를 반환한다. backward-delete-char (Rubout) 커서 뒤에 있는 문자를 삭제한다. 수치 인수를 주면 kill-ring에 삭제한 텍스트를 저장한다. quoted-insert (C-q, C-v) 이 다음부터 타이핑하는 문자를 행에 있는 그대로 추가한다. 예를 들어, C-q와 같은 문자를 삽입할 때 사용한다. tab-insert (C-v TAB) 탭 문자를 삽입한다. self-insert (a, b, A, 1, !, ...) 입력한 문자를 삽입한다. transpose-chars (C-t) 입력점에 앞에 있는 문자와 입력점에 놓인 문자를 서로 교환한다. 입력점도 앞으로 전진한다. 입력점이 행의 끝에 있으면 입력점 앞에 있는 두 문자를 치환한다. 음수 인수는 작동하지 않는다. transpose-words (M-t) 커서 뒤에 있는 단어를 커서 앞으로 끌어 놓는다. 커서 또한 이동한다. upcase-word (M-u) 현재(또는 뒤에 나오는) 단어를 대문자화한다. 음수 인수를 주면 앞 단어에 대하여 대문자화를 진행하지만 입력점은 움직이지 않는다. downcase-word (M-l) 현재(또는 뒤에 나오는) 단어를 소문자화한다. 음수 인수를 주면 앞 단어에 대하여 소문자화를 진행하지만 입력점은 움직이지 않는다. capitalize-word (M-c) 현재(또는 뒤에 나오는) 단어의 첫글자를 대문자화한다. 음수 인수를 주면 앞 단어에 대하여 수행하며 입력점은 움직이지 않는다. 죽이기와 붙이기(Killing, Yanking) kill-line (C-k) 현재 커서 위치로부터 행 끝까지 텍스트를 죽인다. backward-kill-line (C-x C-Rubout) 현재 커서 위치로부터 행의 앞까지 텍스트를 죽인다. unix-line-discard (C-u) 현재 입력점으로부터 행의 앞까지 텍스트를 죽인다. kill-whole-line 커서가 어디에 있든 현재 행의 모든 문자를 죽인다. 기본적으로 결합되어 있지 않는다. kill-word (M-d) 커서 위치로부터 현재 단어의 끝까지 또는 단어 중간인 경우 그 다음 단어의 끝까지 죽인다. 단어 경계는 forward-word 에서 사용하는 것과 동일하다. backward-kill-word (M-Rubout) 커서 뒤의 단어를 죽인다. 단어 경계는 forward-word 에서 사용하는 것과 동일하다. unix-word-rubout (C-w) 화이트스페이스를 단어 경계로 하여 커서 뒤의 단어를 죽인다. 단어 경계는 backward-kill-word에서와 다르다. delete-horizontal-space 입력점 주변의 모든 스페이스와 탭을 삭제한다. 기본적으로 키와 결합되어 있지 않다. yank (C-y) kill ring의 상단에 놓인 것을 커서 위치의 버퍼에 붙인다. yank-pop (M-y) kill-ring을 순환시킨 후 상단의 것을 붙인다. yank 또는 yank-pop 다음에만 동작한다. 수치 인수 digit-argument (M-0, M-1, ..., M--) 이미 축적 중인 인수에 이 숫자를 더하거나 새로운 인수를 시작한다. M-- 는 음수 인수를 시작한다. universal-argument 실행할 때마다 인수 갯수에 4 를 곱한다. 인수 갯수는 처음에 1 이다. 따라서 한 번 실행하면 인수 갯수가 4 가 된다. 기본적으로 키에 결합되어 있지 않다. 완성 complete (TAB) 입력점 앞의 텍스트에 대하여 완성을 시도한다. Bash 는 텍스트를 순서대로 변수($로 텍스트가 시작하면), 사용자 이름(~로 시작하면), 호스트 이름(@로 시작하면) 또는 명령(앨리어스와 함수 포함)으로 취급하여 완성을 시도한다. 일치하는 것이 없을 때에는 파일 이름 완성을 시도한다. possible-completions (M-?) 입력점 앞의 텍스트에 대한 완성 후보 목록을 보여준다. insert-completions possible-completions로 만들어 질 수 있는 모든 완성 텍스트를 입력점 앞에 삽입한다. 기본적으로 키와 결합되어 있지 않다. complete-filename (M-/) 입력점 앞의 텍스트에 대하여 파일 이름 완성을 시도한다. possible-filename-completions (C-x /) 입력점 앞의 텍스트를 파일 이름으로 간주하고 완성 후보 목록을 보여준다. complete-username (M-~) 입력점 앞의 텍스트에 대하여 사용자 이름 완성을 시도한다. possible-username-completions (C-x ~) 입력점 앞의 텍스트를 사용자 이름으로 간주하고 완성 후보 목록을 보여준다. complete-variable (M-$) 입력점 앞의 텍스트에 대하여 쉘 변수 완성을 시도한다. possible-variable-completions (C-x $) 입력점 앞의 텍스트를 쉘 변수로 간주하고 완성 후보 목록을 보여준다. complete-hostname (M-@) 입력점 앞의 텍스트에 대하여 호스트 이름 완성을 시도한다. possible-hostname-completions (C-x @) 입력점 앞의 텍스트를 호스트 이름으로 간주하고 완성 후보 목록을 보여준다. complete-command (M-!) 입력점 앞의 텍스트에 대하여 명령 완성을 시도한다. 명령 완성은 텍스트를 앨리어스, 예약어, 쉘 함수, 내부 명령, 마지막으로 실행 파일 이름 순으로 일치를 시도한다. possible-command-completions (C-x !) 입력점 앞의 텍스트를 명령 이름으로 간주하고 완성 후보 목로을 보여준다. dynamic-complete-history (M-TAB) 입력접 앞의 텍스트를 히스토리 목록의 행과 비교하여 완성을 시도한다. complete-into-braces (M-&#123;) 파일 이름 완성을 수행하고 완성 후보 목록을 쉘에서 사용할 수 있도록 중괄호 안에 넣는다. ( 앞서 나온 중괄호 확장 을 참고 ) 키보드 매크로 start-kbd-macro (C-x () 입력하는 문자를 현재 키보드 매크로에 저장하기 시작한다. end-kbd-macro (C-x )) 현재 키보드 매크로에 저장하기를 멈추고 정의 내용을 저장한다. call-last-kbd-macro (C-x e) 최근에 정의한 키보드 매크로를 다시 실행하여 마치 키보드로 입력한 것처럼 매크로 안의 문자를 보여준다. 기타 re-read-init-file (C-x C-r) 여러분의 초기화 파일 내용을 다시 읽어 모든 바인딩과 변수 지정을 현재 환경에 추가한다. abort (C-g) 현재 진행 중인 편집 명령을 중지하고 터미널 벨을 울린다. ( bell-style 설정에 따라 벨이 울릴 것인지 여부는 달라진다) do-uppercase-version (M-a, M-b, ...) 해당하는 대문자와 결합된 명령을 실행한다. prefix-meta (ESC) 다음 입력하는 문자를 메타화한다. ESC f 는 메타-f 와 동일하다. undo (C-_, C-x C-u) 각 행에 대하여 기억된 내용으로 누증 편집 명령 되돌리기를 행한다. revert-line (M-r) 행에 가해진 모든 변화 내용을 취소하고 원래대로 돌려 놓는다. 행의 초기 상태로 돌려 놓기 위해 undo 명령을 여러 번 실행한 것과 같다. tilde-expand (M-~) 현재 단어에 대한 틸드 확장을 수행한다. dump-functions readline 출력 스트림에 모든 함수와 키 바인딩을 출력한다. 수치 인수를 주면 inputrc 파일에 넣을 수 있는 형태로 형식화해서 출력해준다. display-shell-version (C-x C-v) 현재 실행 중인 bash 의 버전 정보를 보여준다.히스토리(HISTORY) 대화형 모드에서 쉘은 이전에 입력한 명령 목록인 명령 히스토리를 접근할 수 있도록 해준다. 최근 HISTSIZE 갯수의 명령 텍스트는(기본 500) 히스토리 목록에 저장된다. 쉘은 각 명령에 대하여 매개변수 확장과 변수 확장 전에 히스토리 목록에 저장한다. ( 확장 참고 ) 그러나 command_oriented_history 와 HISTCONTROL 변수의 값에 따라 히스토리 확장을 수행한 후에 저장하기도 한다. 시동할 때, 히스토리는 HISTFILE 변수가 가리키는 파일로부터 초기화된다. (기본값 ~/.bash_history). HISTFILESIZE 보다 커지지 않도록 필요할 때에는 HISTFILE 파일을 잘라낸다. 내부 명령 fc ( 쉘 내부 명령 참고)을 사용하여 히스토리를 보거나 일부 명령을 편집하여 재실행할 수 있다. history 내부 명령을 사용하여 히스토리 목록을 표시하고 히스토리 파일을 조작할 수 있다. 명령행 편집을 사용할 때 각 모드마다 히스토리 목록을 검색할 수 있는 명령이 있다. 대화형 쉘을 종료하면 최근 HISTSIZE 행만큼이 히스토리 목록으로부터 HISTFILE 로 복사된다. HISTFILE 을 unset하거나 히스토리 파일에 쓸 수 없을 때는 히스토리를 저장하지 않는다.히스토리 확장(HISTORY EXPANSION) 쉘에서는 csh 의 히스토리 확장과 유사한 히스토리 확장 기능을 지원한다. 이 섹션에서는 사용 가능한 기능의 문법을 설명한다. 대화형 쉘에서는 기본 동작하며 +H option to the set 내부 명령에 +H 옵션을 주어 해제할 수 있다. ( 쉘 내부 명령 참고) 비대화형 모드 쉘에서는 히스토리 확장을 수행하지 않는다. 히스토리 확장은 완전한 행이 읽히고 쉘이 단어로 분리하기 전에 즉시 수행된다. 두 부분에서 일어난다. 우선 이전 히스토리로부터 어떤 행을 가져가 치환에 사용할 것인지 결정한다. 두번째는 현재 행에 포함시키기 위해 그 행의 일부분을 선택한다. 이전 히스토리로부터 선택된 행을 이벤트(event)라 하며 행동이 취해 질 그 행의 일부분을 단어(words)라고 한다. 행은 입력을 읽어 들일 때와 같은 방식으로 단어로 분리되며 따라서 몇 가지 메타문자에 의해 구분된 단어가 쿼우트로 둘러 싸이면는 하나의 단어로 취급한다. 오로지 백슬래쉬(\\)와 싱글 쿼우트만이 히스토리 이스케이프 문자를 (기본값 !) 쿼우트할 수 있다. 히스토리 확장 메커니즘에서 사용하는 다양한 문자를 제어할 수 있다. ( 쉘 변수 섹션에서 histchars 설명 참고 ) 이벤트 지시자(Event Designators) 이벤트 지시자는 히스토리 목록의 명령행 항목에 대한 참조이다. ! 그 뒤에 공백, 개행문자, = 또는 ( 가 나오는 경우를 제외하고 히스토리 치환을 시작하도록 한다. !! 이전 명령을 가리킨다. `!-1'와 동의어이다. !n n 번 명령행을 가리킨다. !-n 현재 명령행에서 n 를 뺀 행을 가리킨다. !문자열 문자열 로 시작하는 가장 최근 명령을 가리킨다. !?문자열[?] 문자열 을 포함하는 가장 최근 명령을 가리킨다. ^문자열1^문자열2^ 빠른 치환. 지난 번 명령에 대하여 문자열1 을 문자열2 로 바꾸어 실행한다. ``!!:s/문자열1/문자열2/''와 같다. (변경자(Modifiers) 참고). !# 지금까지 입력한 전체 명령행. 단어 지시자 : 는 단어 지시자로부터 이벤트 명시를 분리한다. 단어 지시자가 ^, $, *, % 로 시작할 때에는 생략할 수 있다. 단어는 행의 처음부터 시작하여 세며 첫번째 단어는 0(숫자 영) 으로 나타낸다. 0 (숫자 영) 0 번째 단어. 쉘에 있어 명령 단어에 해당한다. n n번째 단어. ^ 첫번째 인수 즉 단어 1 이다. $ 마지막 인수. % 가장 최근의 `?문자열?' 검색과 일치하는 단어 x-y 단어의 범위; `-y' 는 `0-y'와 같이 줄여 쓴다. * 0 번째를 제외한 모든 단어. `1-$'와 동의어이다 이벤트에 단어 하나만 있을 때에도 * 를 사용하는 것은 에러가 아니다; 이 경우 빈 문자열이 반환된다. x* x-$를 줄여 쓴 것이다. x- x*와 같이 x-$를 줄여 쓴 것이지만 마지막 단어를 제외한다. 변경자(Modifiers) 선택적인 단어 지시자 뒤에 앞에 `:'를 붙여 다음과 같은 변경자를 추가할 수 있다. h 머리 부분만 남기도 뒷부분 경로명 부분을 제거한다. r 베이스 이름만 남기고 .xxx 형태의 뒷부분 꼬리말을 제거한다. e 꼬리말을 제외하고 모두 제거한다. t 꼬리 부분은 남기고 앞에 나오는 모든 경로명 부분을 제거한다. p 새로운 명령을 출력하지만 실행하지는 않는다. q 치환된 단어를 쿼우트하여 더 이상 치환이 일어나지 않도록 해석금지시킨다. x q 과 함께 사용하여 치환된 단어를 쿼우트한다. 그러나 공백 과 개행문자에서 단어를 분리한다. s/예전것/새것/ 이벤트 행에서 처음 나오는 예전것 을 새것 으로 교체한다. / 대신 어떤 분리자도 사용 가능하다. 마지막 분리자가 이벤트 행의 마지막 단어일 때는 생략 가능하다. 예전것 과 새것 안에서 단일 백슬래쉬를 사용하여 분리자를 쿼우트할 수 있다. 새것 안에 &amp; 이 있으면 그 문자는 예전것 으로 치환된다. 단일 백슬래쉬를 사용하여 &amp; 를 쿼우트할 수 있다. &amp; 이전 치환을 반복한다. g 변화 내용을 전체 이벤트 행에 적용하도록 한다. `:s' (예, `:gs/예전것/새것/') 또는 `:&amp;'와 사용한다. If used with `:s'와 사용하면 / 대신 어떤 분리자든 사용할 수 있으며 마지막 분리자가 이벤트 행의 마지막 문자일 때는 생략할 수 있다.산술 평가(ARITHMETIC EVALUATION) 쉘은 특정 상황에서 산술 표현식을 계산할 수 있도록 해준다. ( let 내부 명령과 연산 확장 참고 ) 평가는 오버플로우 점검 없이 long 형 정수로 이루어진다. 0 으로 나누는 것은 잡아내어 에러로 표시한다. 다음 연산자 목록은 같은 우선 순위를 갖는 것끼리 모았다. 나열한 순위는 내림 차순이다. - + 단일 마이너스와 플러스 ! ~ 논리적 그리고 비트수준 부정 * / % 곱하기, 나누기, 나머지 연산 + - 더하기, 빼기 &lt;&lt; &gt;&gt; 왼쪽, 오른쪽 비트 쉬프트 &lt;= &gt;= &lt; &gt; 비교 == != 같다, 같지 않다 &amp; 비트수준 AND ^ 비트수준 배타적(exclusive) OR | 비트수준 OR &amp;&amp; 논리적 AND || 논리적 OR = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= 지정 피연산자로 쉘 변수를 사용할 수 있다; 표현식을 평가하기 전에 매개변수 확장이 수행된다. 매개변수의 갑은 표현식 안에서 long 형 정수로 강제 전환한다. 표현식에 사용하기 위해 쉘 변수의 정수 속성을 켤 필요는 없다. 0으로 시작하는 상수는 8 진수로 해석한다. 0x 또는 0X로 시작하면 16 진수를 뜻한다. 그 외의 경우에 대해서는 [base#]n 형태로 숫자를 받아들인다. 여기서 base는 진법을 나타내는 2 부터 36 사이의 10진수이며 n는 그 진법 안에서의 숫자이다. base를 생략하면 10 진법을 사용한다. 연산자는 우선 순위에 의거하여 평가해 나간다. 괄호 안의 서브 표현식은 먼저 평가하며 위에서 말한 우선 순위를 무시하도록 한다.쉘 내부 명령(SHELL BUILTIN COMMANDS) : [인수들] 아무런 효과도 없다; 인수들 을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다. 종료 상태값 0 을 반환한다. . 파일명 [인수들] source 파일명 [인수들] 파일명 으로부터 명령을 읽어 현재 쉘 환경 안에서 실행한다. 파일명 에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다. 파일명 에 슬래쉬가 없으면 PATH 변수에 들어있는 경로명을 사용하여 파일명 을 검색한다. PATH 변수에서 찾는 파일이 실행 파일일 필요는 없다. PATH 에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다. 인수들을 적으면 파일을 실행할 때 위치 매개변수로 사용한다. 그렇지 않으면 위치 매개변수는 변하지 않는다. 스크립트 내에서 종료한 마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0) 파일명 을 찾을 수 없으면 거짓을 반환한다. alias [이름[=값] ...] 아무런 인수 없이 Alias를 실행하면 표준 출력에 이름=값의 형식으로 앨리어스 목록을 출력해준다. 인수를 제공하면 각각의 이름에 대하여 값을 앨리어스로 정의한다. 값 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도 앨리어스 확장이 가능한지 점검하도록 할 수 있다. 인수 목록에서 값을 주지 않은 이름에 대해서는 앨리어스의 이름과 값을 출력한다. 주어진 이름에 대한 앨리어스가 정의되어 있지 않은 경우가 아니라면 참값을 반환한다. bg [작업명세] &amp; 를 붙여 실행한 것처럼 작업명세가 가리키는 작업을 백그라운드로 보낸다. 작업명세가 없으면 현재 작업에 해당하는 작업이 사용된다. bg 작업명세 는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만 작업명세를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고 0 을 반환한다. bind [-m 키맵] [-lvd] [-q 이름] bind [-m 키맵] -f 파일명 bind [-m 키맵] 키시퀀스:함수이름 readline 의 현재 키, 함수 바인딩을 표시하거나 readline 함수나 매크로에 키 시퀀스를 결합한다. 바인딩 문법은 .inputrc 의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다; 예를 들어, '\"\\C-x\\C-r\": re-read-init-file'. 옵션을 적는 경우에는 다음과 같은 의미를 가진다: -m 키맵 뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로 키맵 을 사용한다. 가능하 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, 그리고 vi-insert 이 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다. -l 모든 readline 함수의 이름을 나열한다. -v 현재 함수 이름과 바인딩을 나열한다. -d 다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다. -f 파일명 filename으로부터 키 바인딩을 읽는다. -q 함수 함수를 실행시키는 키에 대하여 알아본다. 알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다. break [n] for, while, until 루프 안에서 탈출한다. n을 명시하면 n 레벨을 탈출한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다. break 이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다. builtin 쉘-내부명령 [인수들] 명시한 쉘 내부 명령에 인수들 을 주어 실행하고 종료 상태값을 반환한다. 쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의 기능을 활용하고자 할 때 유용하다. 보통 cd 내부 명령을 이런 식으로 재정의하곤 한다. 쉘-내부명령 이 쉘 내부 명령이 아닐 때 거짓을 반환한다. cd [디렉토리] 현재 디렉토리를 디렉토리로 변경한다. HOME 변수 값이 기본 디렉토리 값이다. CDPATH 변수는 디렉토리 를 포함하는 디렉토리에 대한 검색 경로를 정의한다. 서로 다른 디렉토리는 콜론(:)으로 구분한다. CDPATH 에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 ``.''와 같다. 디렉토리 가 슬래쉬(/)로 시작하면 CDPATH 는 사용되지 않는다. 전달인수로 - 를 사용하면 $OLDPWD 와 같다. 성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다. command [-pVv] 명령 [인수 ...] 보통의 쉘 함수 찾아보기를 하지 않고 명령 을 인수 와 함께 실행한다. 내부 명령 또는 PATH 에서 찾을 수 있는 명령만을 실행한다. are executed. If the -p 옵션을 주면 PATH 의 기본값을 사용하여 명령 에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다. -V 또는 -v 옵션을 주면 명령 에 대한 설명을 출력한다. -v 옵션은 명령 을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다; -V 옵션은 좀 더 자세한 설명을 출력한다. -- 를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다. -V 또는 -v 옵션을 주었을 때 종료 상태값은 명령 이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나 명령 을 찾을 수 없으면 종료 상태값은 127 이 된다. 그렇지 않을 때 command 내부 명령의 종료 상태값은 명령 의 종료 상태값이다. continue [n] 둘러 싸고 있는 for, while, until 루프의 다음 순차 작업을 재개한다. n 을 명시하면, n 번째 루프를 재개한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(`최상위 레벨' 루프)를 재개한다. continue 명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은 0 이다. declare [-frxi] [이름[=값]] typeset [-frxi] [이름[=값]] 변수를 선언하거나 변수에 속성을 부여한다. 아무런 이름도 주어지지 않았을 때에는 변수의 값을 표시한다. 옵션을 사용하여 특정 속성의 변수에 대해서만 출력하도록 제한할 수 있다. -f 함수 이름만 사용 -r 이름을 읽기 전용으로 만든다. 그 뒤에는 지정문을 사용하여 값을 지정할 수 없다. -x 이름을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다. -i 변수를 정수처럼 취급한다; 변수에 값을 지정하면 산술 평가( 산술 평가 참고 )를 수행한다. 이 옵션을 끄려면 `-' 대신 `+'를 사용한다. 함수 안에서 사용하면 local 명령처럼 이름을 지역적으로 만든다. 잘못된 옵션을 만났다든지, \"-f foo=bar\"를 사용하여 함수를 정의하려고 시도했다든지, 이름이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용 상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를 표시하려 한 경우가 아니라면 반환값은 0 이다. dirs [-l] [+/-n] 현재까지 기억하고 있는 디렉토리 목록을 표시한다. 디렉토리를 목록에 추가할 때에는 pushd 명령을 사용한다; popd 명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다. +n 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 왼쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -n 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 오른쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -l 긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼 때 틸드를 사용한다. 틀린 옵션을 주거나 n 이 디렉토리 스택 범위를 넘어서는 경우가 아니라면 반환값은 0 이 된다. echo [-neE] [인수 ...] 스페이스로 구분되어 있는 인수들을 출력한다. 반환값은 항상 0 이다. -n을 명시하면 마지막의 개행문자를 출력하지 않는다. -e 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다. -E 옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도 이스케이프 문자를 해석하지 않도록 지시한다. \\a 경고 (벨) \\b 백스페이스 \\c 마지막 개행문자를 생략함 \\f 폼 피드 \\n 개행문자 \\r 캐리지 리턴 \\t 수평 탭 \\v 수직 탭 \\\\ 백슬래쉬 \\nnn ASCII 코드가 nnn (8진수)인 문자 enable [-n] [-all] [이름 ...] 쉘 내부 명령을 켜거나 큰다. 이 기능을 사용하면 쉘 내부 명령과 같은 이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수 있다. -n을 사용하면 각 이름의 사용을 끈다; 그렇지 않으면 이름의 사용을 켠다. 예를 들어, 쉘 내부 명령 버전 대신 PATH 에서 찾을 수 있는 test 바이너리를 사용하려면 ``enable -n test'' 라고 실행한다. 인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다. -n만 주면 사용 불능 상태의 내부 명령 목록을 출력한다. -all만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여 출력해준다. enable 명령은 -all 대신 -a 도 받아들인다. 이름 이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다. eval [인수 ...] 모든 인수를 읽어 하나의 명령으로 결합한다. 그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을 eval 명령의 반환값으로 돌려준다. 인수 가 하나도 없거나 널 인수이면 eval 은 참을 반환한다. exec [[-] 명령 [인수]] 명령 을 명시하면 그 명령으로 쉘 프로세스를 교체한다. 새로운 프로세스는 만들어지지 않는다. 인수 는 명령의 인수가 된다. 첫번째 인수가 - 이면 쉘은 명령 에 전달하는 0 번째 인수에 대쉬를 넣는다. 이 과정은 로그인이 하는 일과 같다. 어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수 no_exit_on_failed_exec가 존재하여 거짓을 반환하는 경우를 제외하고 비대화형 쉘은 종료한다. 파일을 실행할 수 없을 때 대화형 쉘은 거짓을 반환한다. 명령 을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은 0 이 된다. exit [n] 상태값 n을 가지고 쉘을 종료한다. n 을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다. 쉘을 종료하기 전에 EXIT 에 대한 트랩(trap) 루틴이 실행된다. export [-nf] [이름[=단어]] ... export -p 나열한 이름 을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다. -f 옵션을 주면 이름 은 함수를 가리킨다. 아무런 이름 도 적지 않거나 또는 -p 옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다. -n 옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다. -- 인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다. 잘못된 옵션을 만나거나 이름이 적법한 쉘 변수 이름이 아니거나 또는 함수가 아닌 이름 에 대하여 -f 옵션을 준 경우가 아니라면 export 는 종료 상태값 0 을 반환한다. fc [-e 편집기이름] [-nlr] [처음] [마지막] fc -s [패턴=치환텍스트] [명령] 명령을 수정한다. 첫번째 형식에서, 명령의 범위는 처음 부터 마지막 범위에 있는 명령을 히스토리 목록에서 선택한다. 처음 과 마지막 은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자 (히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터 떨어진 만큼을 뜻한다)로 명시할 수 있다. 마지막 을 명시하지 않으면 현재 명령으로 설정되고(따라서 fc -l -10 은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면 처음 까지 출력한다. If 처음 을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해 -16 을 설정한다. -n 플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다. -r 플래그는 명령의 표시 순서를 반대로 한다. -l 플래그가 있으면 명령을 표준 출력에 나열한다. 그렇지 않을 때에는 편집기이름 이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다. 편집기이름 이 없으면 FCEDIT 변수의 값을 사용하며 FCEDIT 가 설정되어 있지 않을 때에는 EDITOR 값을 사용한다. 둘 다 설정되어 있지 않으면 vi 를 사용한다. 편집을 마친 후에는 편집한 명령들이 화면에 표시되고 실행된다. 두번째 형태에서, 명령은 패턴이 치환텍스트로 교체된 후에 다시 실행된다. 유용한 앨리어스로는 ``r=fc -s''가 있다. 앨리어스 적용 후 ``r cc'' 라고 치면 ``cc''로 시작하는 최근 명령을 실행하고 ``r''이라고 치면 마지막 명령을 다시 실행하게 된다. 첫번째 형태를 사용하면 잘못된 옵션이 있거나 처음 또는 마지막 이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다. -e 옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서 오류가 발생하는 경우 실패 값을 가진다. 두번째 형태를 사용하면 명령 이 유효한 히스토리 행을 가리키지 못하여 fc 가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로 사용한다. fg [작업스펙] 작업스펙 이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다. 작업스펙 이 존재하지 않으면 쉘에서 현재 작업이라고 부르는 것을 사용한다. 반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서 실행된 경우에는 실패이다. 그리고 작업 제어 가능한 상태에서도 작업스펙 이 유효한 작업을 가리키지 않거나 작업스펙 이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다. getopts 옵션문자열 이름 [인수] getopts 는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다. 옵션문자열 은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에 화이트스페이스로 분리된 인수가 온다는 뜻이다. 매번 실행될 때마다, getopts 는 다음 옵션을 쉘 변수 이름 에 넣는다. 이름 이 존재하지 않을 때에는 초기화한다. 그리고 처리할 다음 인수의 인덱스는 OPTIND 변수에 넣는다. OPTIND 는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다. 옵션에서 인수를 필요로 할 때에는 getopts 에서 그 인수를 OPTARG 변수에 넣는다. 쉘이 자동으로 OPTIND 변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을 사용하려면 getopts 를 부를 때마다 수동으로 재설정해 주어야 한다. getopts 는 두 가지 방식으로 오류를 보고할 수 있다. 옵션문자열 의 첫번째 문자가 콜론이면 조용한 오류 보고가 사용된다. 정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의 경우 증상을 설명하는 메시지가 출력된다. OPTERR 변수를 0 으로 설정하면 옵션문자열 의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다. 잘못된 옵션을 만나면, getopts 는 이름 에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우, 오류 메시지를 출력하고 OPTARG 를 unset 한다. getopts 이 조용한 모드에 있는 경우 찾아낸 옵션 문자를 OPTARG 에 넣고 증상 설명 메시지를 출력하지 않는다. 필요한 인수를 찾을 수 없으며 getopts 가 조용한 모드에 있지 않을 때에는 물음표를 (?) 이름 에 넣고 OPTARG 를 unset 하며 증상 설명 메시지를 출력한다. getopts 가 조용한 모드에 있으면 콜론을 (:) 이름 에 넣고 OPTARG 을 찾아낸 옵션 문자로 설정한다. getopts 는 보통 위치 매개변수를 파싱하지만 인수 부분에 더 많은 인수를 주면 getopts 는 대신 그 인수를 파싱한다. getopts 는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다. 옵션의 끝이거나 에러가 발생하면 거짓을 반환한다. hash [-r] [이름] 각 이름 에 대하여, 그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다. -r 옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다. 아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다. -- 라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다. 이름 이 없거나 잘못된 옵션이 주어진 경우가 아닌 경우에는 참을 반환한다. help [패턴] 내부명령에 대한 도움말을 출력한다. 패턴 을 적으면, help 는 패턴과 일치하는 모든 명령에 대하여 자세한 도움말을 준다; 패턴을 적지 않으면 모든 내부명령 목록을 출력한다. 패턴과 일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다. history [n] history -rwan [filename] 옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. * 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다;없으면 HISTFILE 변수의 값을 사용한다. 옵션이 있는 경우 다음과 같은 뜻을 갖는다: -a 히스토리 파일에 ``새로운'' 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다. -n 히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다. -r 히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다. -w 현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다. jobs [-lnp] [ 작업스펙 ... ] jobs -x 명령 [ 인수 ... ] 첫번째 형태는 활동 중인 작업을 나열한다. -l 옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다; -p 옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다. -n 옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다. 작업스펙 을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다. 잘못된 옵션을 적거나 잘못된 작업스펙 을 적은 경우가 아니라면 반환값은 0 이다. -x 옵션을 붙이면, jobs 명령은 명령 또는 인수 안 에서 작업스펙 을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고 명령 에 인수 를 주어 실행하고 그 종료 상태값을 반환한다. kill [-s 시그널스펙 | -시그널스펙] [pid | 작업스펙] ... kill -l [시그널번호] pid 또는 작업스펙이 가리키는 프로세스에게 시그널스펙 이 가리키는 시그널을 보낸다. 시그널스펙 은 SIGKILL 과 같은 시그널 이름 또는 시그널 번호이다. 시그널스펙 이 시그널 이름인 경우, 대소문자는 구별하지 않으며 SIG 라는 접두어를 써도 되고 쓰지 않아도 된다. 시그널스펙 이 없으면, SIGTERM 이라고 가정한다. -l 인수를 적으면 시그널 이름을 나열해 준다. -l 이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고 반환값은 0 이다. -- 인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다. kill 최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다. 오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다. let 인수 [인수 ...] 각각의 인수 는 계산한 수치 표현식이다.( 산술 평가 참고 ). 마지막 인수 를 평가하여 그 결과가 0 이면, let 은 1 을 반환한다; 나머지 경우에는 0 을 반환한다. local [이름[=값] ...] 각 인수에 대하여 이름 이라는 지역 변수를 만들고 값 을 할당한다. local 을 함수 안에서 사용하면, 이름 변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다. 피연산자가 없으면, local 은 지역변수 목록을 표준 출력으로 출력한다. local 를 함수 안에서 사용하지 않는 것은 오류이다. local 을 함수 외부에서 사용했거나 잘못된 이름 을 적은 경우가 아니라면 반환 상태값은 0 이다. logout 로그인 쉘을 마친다. popd [+/-n] 디렉토리 스택에서 항목을 제거한다. 인수가 없으면 스택의 최상위 디렉토리를 제거하고 그 새로운 상위 디렉토리로 cd 한다. +n dirs 명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, ``popd +0''는 첫번째 디렉토리를, ``popd +1''는 두번째 디렉토리를 제거한다. -n dirs 명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, ``popd -0''는 맨 마지막 디렉토리를, ``popd -1''는 맨 마지막 바로 전 디렉토리를 제거한다. popd 명령이 성공적이면, dirs 명령도 실행하며 반환 상태값은 0 이다. popd 는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다. pushd [디렉토리] pushd +/-n 디렉토리를 디렉토리 스택의 맨 위에 추가하거나, 스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다. 인수가 없으면, 최상위 두 디렉토리를 교환한다. 디렉토리 스택이 비어 있지 않으면 0을 반환한다. +n n번째 디렉토리( dirs 명령이 보여주는 목록의 맨 왼쪽부터 센다) 이 맨 위에 놓이도록 스택을 회전시킨다. ) -n n번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록 스택을 회전시킨다. 디렉토리 디렉토리 를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다. pushd 명령이 성공적이면, dirs 명령도 수행한다. 첫번째 형식을 사용하면, pushd 는 디렉토리 로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다. 두번째 형식을 사용하면, pushd 는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면 0을 반환한다. pwd 현재 디레토리의 절대 경로명을 출력한다. set 내부명령의 -P 옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다. ( 쉘 변수 섹션에서 nolinks 에 대한 설명을 참고하라.) above). 현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은 0이다. read [-r] [이름 ...] 표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 첫번째 이름 에 할당하고 두번째 단어를 두번째 이름 에 할당하고 나머지 남은 단어들을 마지막 이름 에 할당한다. IFS 에 있는 단어만을 단어 구분자로 인식한다. 아무런 이름 도 적지 않으면 읽어들인 행을 REPLY 변수에 할당한다. 파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다. -r 옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로 인식한다. readonly [-f] [이름 ...] readonly -p 주어진 이름들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해 이름들의 값이 바뀌지 않도록 해 준다. -f 옵션을 더하면, 이름에 해당하는 함수를 읽기 전용으로 표기한다. 아무런 인수도 없거나 -p 옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다. -- 인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다. 잘못된 옵션이 있거나 이름들 중 하나라도 적접한 쉘 변수 이름이 아닌 경우 또는 -f 다음에 나온 이름 이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다. return [n] 함수를 상태 반환값 n 을 갖고 종료하도록 한다. n 을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다. 함수 밖에서 사용했지만 . (source) 명령으로 실행한 스크립트에서 사용하면, 쉘은 그 스크립트 실행을 멈추고 n 또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로 반환한다. 함수 밖에서 사용했으며 .\\[uB85C] 실행한 스크립트가 아니라면 반환 상태값은 거짓이 된다. set [--abefhkmnptuvxldCHP] [-o 옵션] [인수 ...] -a 뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로 표기한다. -b 종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이 아니라 즉시 보여 주도록 한다. ( 쉘 변수 섹션에서 notify 참고) -e 간단한-명령 ( 쉘 문법 참고)이 0 아닌 상태값을 갖고 종료하면 즉시 종료한다. 만약 실패한 명령이 until 또는 while 루프의 일부, if 문의 일부, &amp;&amp; 의 일부, or ⎪⎪ 목록의 일부이거나 또는 명령의 반환값이 ! 으로 반전되면 종료하지 않는다. -f 경로명 확장을 하지 않는다. -h 함수를 정의할 때 함수 명령을 찾아 기억해 둔다. 함수를 실행할 때 함수 명령을 정상적으로 찾아 본다. -k 명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에 둔다. -m 모니터(감시) 모드. 작업 제어를 사용한다. 지원하는 시스템에서 실행하는 대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다. ( 작업 제어 참고). 백그라운드 작업은 별도의 프로세스 그룹 안에서 실행되며 실행을 완료하면 종료 상태값을 포함하는 행을 출력한다. -n 명령을 읽지만 실행하지는 않는다. 쉘 스크립트 문법 오류를 점검할 때 사용할 수 있다. 대화형 쉘에서는 무시한다. -o 옵션-이름 옵션-이름은 다음 중 한 가지이다: allexport -a 와 같다. braceexpand 쉘이 중괄호 확장을 행한다. ( 앞서 나온 중괄호 확장 참고) 선택하지 않아도 기본값이다. emacs 이맥스 스타일의 명령행 편집 인터페이스를 사용한다. 쉘을 시작할 때 -nolineediting 옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다. errexit -e와 같다. histexpand -H와 같다. ignoreeof 마치 쉘 명령 `IGNOREEOF=10'을 실행한 것과 같은 효과를 발휘한다. (앞서 나온 쉘 변수 참고). interactive-comments 어떤 단어를 # 로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다. (앞서 나온 주석 참고). monitor -m와 같다. noclobber -C와 같다. noexec -n와 같다. noglob -f와 같다. nohash -d와 같다. notify -b와 같다. nounset -u와 같다. physical -P와 같다. posix POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을 따르도록 만든다. privileged -p와 같다. verbose -v와 같다. vi vi 스타일의 명령행 편집 인터페이스를 사용한다. xtrace -x와 같다. 옵션-이름을 적지 않으면 현재 옵션값을 출력한다. -p privileged 모드를 켠다. 이 모드에서는 $ENV 파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다. 유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때 자동으로 작동한다. 이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자, 그룹 ID로 설정한다. -t 명령 하나를 읽어 실행한 후 종료한다. -u 매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다. 미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고 대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다. -v 쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다. -x 각각의 간단한-명령 을 확장한 후, bash PS4, 의 확장값을 표시하고 명령과 확장된 인수를 표시한다. -l for 이름 [in 단어] 명령의 이름 바인딩을 저장하고 복원한다. (앞서 나온 쉘 문법 참고). -d 실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다. 보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할 필요 없다. -C 쉘 명령 `noclobber='을 실행한 것과 같은 효력을 발휘한다. (앞서 나온 쉘 변수 참고). -H ! 스타일의 히스토리 치환을 사용한다. 쉘이 대화형 모드이면 기본으로 켜지는 플래그이다. -P 설정하면, 현재 디렉토리를 변경하는 cd 와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다. 대신 물리적인 디렉토리를 사용한다. -- 이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다. 만약 나오면, - 로 시작하는 것이 있다 할 지라도 위치 매개변수를 인수로 설정한다. - 옵션의 끝을 나타내며, 그 뒤에 나오는 모든 인수들을 위치 매개변수로 설정한다. -x 와 -v 옵션이 꺼진다. 만약 아무런 인수도 없다면, 위치 매개변수는 그대로이다. 다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다. - 대신 + 를 사용하면 플래그를 끈다. 쉘을 실행할 때 옵션으로 적을 수 있다. 현재 플래그 상태는 $- 를 보면 알 수 있다. 옵션 인수를 처리한 후, 나머지 n 개의 인수는 위 매개변수의 값으로 간주하고 차례대로 $1, $2, ... $n 에 할당한다. 아무런 옵션도 없고 인수도 없으면 모든 쉘 변수를 출력한다. 잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다. shift [n] n+1 부터의 위치 매개변수 이름을 $1 .... 로 변경한다. $#부터 $#-n+1까지의 매개변수는 unset된다. n 이 0 이면, 매개변수의 변화는 없다. n 이 주어지지 않으면 1 로 간주한다. n 은 $#보다 작거나 같은 음수 아닌 숫자여야 한다. n 이 $#보다 크면, 위치 매개변수의 변화는 없다. n 이 $# 보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다; 그렇지 않으면 0 이다. suspend [-f] SIGCONT 시그널을 받을 때까지 쉘의 실행을 정지시킨다. -f 옵션은 로그인 쉘이라 할 지라도 불평 메시지를 출력하지 않도록 한다; 어찌 되었든 일시 정지한다. 쉘이 로그인 쉘이면서도 -f 이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은 0 이 된다. test 표현식 [ 표현식 ] 조건 표현식 을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다. 표현식은 일항 또는 이항 표현식일 수 있다. 일항 표현식은 주로 파일의 상태를 점검할 때 사용한다. 문자열 연산자와 수치 비교 연산자도 있다. 각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다. 파일이 /dev/fd/n의 형태일 때에는, 파일 기술자 n를 점검한다. -b 파일 파일이 존재하고 블럭 특수 파일이면 참. -c 파일 파일이 존재하고 문자 특수 파일이면 참. -d 파일 파일이 존재하고 디렉토리이면 참. -e 파일 파일이 존재하면 참. -f 파일 파일이 존재하고 일반 파일이면 참. -g 파일 파일이 존재하고 set-group-id이면 참. -k 파일 파일에 ``스틱키(sticky)'' 비트가 설정되어 있으면 참. -L f파일 파일이 존재하고 심볼릭 링크이면 참. -p 파일 파일이 존재하고 명명된(named) 파이프이면 참. -r 파일 파일이 존재하고 읽을 수 있으면 참. -s 파일 파일이 존재하고 그 크기가 0 보다 크면 참. -S 파일 파일이 존재하고 소켓이면 참. -t fd fd (파일 기술자)가 열린 상태이고 터미널이면 참. -u 파일 파일이 존재하고 set-user-id 비트가 설정되어 있으면 참. -w 파일 파일이 존재하고 쓸 수 있으면 참. -x 파일 파일이 존재하고 실행 가능하면 참. -O 파일 파일이 존재하고 유효(effective) 사용자 ID의 소유이면 참. -G 파일 파일이 존재하고 유효 그룹 ID의 소유이면 참. 파일1 -nt 파일2 파일1이 (수정 일시에 의거하여) 파일2보다 새로운 파일이면 참. 파일1 -ot 파일2 파일1이 파일2보다 오래 된 파일이면 참. 파일1 -ef 파일2 파일1과 파일2가 같은 장치이며 아이노드 번호가 같으면 참. -z 문자열 문자열의 길이가 0이면 참. -n 문자열 문자열 문자열 의 길이가 0이 아니면 참. 문자열1 = 문자열2 두 문자열이 같으면 참. 문자열1 != 문자열2 두 문자열이 같지 않으면 참. ! 표현식 표현식 이 거짓이면 참. 표현식1 -a 표현식2 표현식1 과 표현식2 둘 다 참이면 참. 표현식1 -o 표현식2 표현식1 또는 표현식2 둘 중 하나가 참이면 참. 인수1 연산자 인수2 연산자 는 -eq, -ne, -lt, -le, -gt, 또는 -ge 중 하나이다. 위와 같은 수치 이항 연산자는 각각 인수1이 인수2와 같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다. 인수1 과 인수2 는 양의 정수, 음의 정수 또는 -l 문자열과 같이 문자열 의 길이로 평가되는 특별한 표현식이 될 수 있다. times 쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간, 시스템 영역에서의 소모 시간을 출력한다. 반환값은 0 이다. trap [-l] [인수] [시그널스펙] 쉘이 시그널스펙 이 가리키고 있는 시그널을 받으면 인수 로 주어진 명령을 읽어 실행하도록 한다. 인수 가 없거나 - 이면, 제시한 모든 시그널에 대하여 원래의 값으로 돌아간다. (즉 쉘을 시작했을 때의 값) 인수 가 널 문자열이면 쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다. 시그널스펙 은 &lt;signal.h&gt;에 정의되어 있으면 시그널 이름이거나, 시그널 번호이다. 시그널스펙 이 EXIT (0) 이면 인수 로 주어진 명령을 쉘 종료 시에 실행한다. 아무런 인수도 없으면, trap 은 각 시그널 번호와 연관된 명령 목록을 출력한다. -l 옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다. -- 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. 쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다. 가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다. 가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 trap 은 참을 반환한다. type [-all] [-type | -path] 이름 [이름 ...] 옵션없이 사용하면, 이름 이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다. -type 플래그를 사용하면, type 은 이름 이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때, alias, keyword, function, builtin, 그리고 file 중 하나를 출력한다. 이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다. -path 플래그를 사용하면, type 은 이름 이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나, -type 이 file 을 반환하지 않을 때에는 아무 것도 반환하지 않는다. 명령이 해쉬된 상태이면, -path 는 PATH 상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다. -all 플래그를 사용하면, type 은 이름 이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다. -path 플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다. -all 을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다. type 은 -all, -type, 과 -path 대신 각각 -a, -t, 과 -p 를 받아들인다. -- 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. type 은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을 반환한다. ulimit [-SHacdfmstpnuv [제한]] Ulimit 은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여 사용 자우너을 제한할 수 있도록 해 준다. 제한 값은 각 자원에 대한 단위 값이거나 unlimited 라는 값을 가질 수 있다. H와 S 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다. 하드 제한은 일단 설정되면 더 이상 늘릴 수 없다; 한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다. H 와 S 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고 간주한다. 제한 을 생략하면 H 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다. 여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다. 기타 다른 옵션은 다음과 같이 해석한다: -a 모든 현재 제한 사항을 보고한다. -c 코어 파일의 최대 크기 -d 프로세스의 데이터 세그먼트의 최대 크기 -f 쉘이 만들 수 있는 파일의 최대 크기 -m 상주 설정(resident size) 최대 크기 -s 최대 스택 크기 -t 초 단위의 최대 CPU 시간 -p 512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음) -n 열 수 있는 파일 기술자의 최대 크기 (대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.) -u 단일 사용자에게 허용하는 프로세스 최대 갯수 -v 쉘에 허용하는 가상 메모리의 최대량 -- 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다. 제한 이 주어지면, 명시한 자원에 대한 새로운 값이 된다.( -a 옵션은 표시할 때만 사용한다.) 아무런 옵션도 없으면 -f 로 간주한다. 값은 초 단위의 -t, 512 바이트의 블럭 단위인 -p, 그리고 단위가 없는 -n 과 -u 를 제외하고, 1024 바이트 단위로 생각한다. 잘못된 옵션이 있거나, 제한 값에 unlimited 이외의 수치 아닌 인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고 반환 상태값은 0 이다. umask [-S] [모드] 사용자 파일 생성 매스크를 모드 로 설정한다. 모드 가 숫자로 시작하면 8 진수로 해석한다. 그렇지 않으면 chmod(1) 와 비슷한 심볼릭 매스크로 해석한다. 모드 를 생략하거나, -S 옵션을 적으면, 현재의 매스크 값을 출력한다. -S 옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다; 기본 출력 형태는 8 진수이다. -- 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. 모드를 성공적으로 변경하거나 아무런 모드 값도 적지 않으면 반환 상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다. unalias [-a] [이름 ...] 정의된 앨리어스 목록에서 이름을 제거한다. -a 를 적으면 모든 앨리어스 정의를 제거한다. 적은 이름 이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다. unset [-fv] [이름 ...] 각각의 이름 에 대하여, 해당하는 변수를 제거하거나, -f 옵션의 경우 함수를 제거한다. -- 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. PATH, IFS, PPID, PS1, PS2, UID, 그리고 EUID 는 unset할 수 없다. RANDOM, SECONDS, LINENO, 또는 HISTCMD 중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을 잃게 된다. 이름 이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다. wait [n] 특정 프로세스를 기다리다가 종료값을 반환한다. n 은 프로세스 ID이거나 작업 스펙이다; 작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다. n 을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다. n 이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다. 그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이 된다.호출(INVOCATION) 로그인 쉘이란 0 번째 인수의 첫번째 문자가 - 이거나 플래그를 주어 시작한 쉘이다. 대화형(interactive) 쉘이라면 쉘의 표준 입력과 표준 출력 둘 다 터미널에 연결되어 있는 쉘 (그 여부는 isatty(3) 를 통해 판단한다.) 또는 -i 옵션을 주어 시작한 쉘이다. bash 가 대화형 모드일 때에는 쉘 스크립트나 시동 파일에서 두 가지 상태를 판단할 수 있도록 PS1 를 설정하고 $- 에 i 를 포함한다. 로그인 쉘: 로그인할 때 (-noprofile 옵션에 따라 달라진다): 만약 /etc/profile이 있으면, 그것을 소스(source)한다. 만약 ~/.bash_profile이 있으면 소스한다. 그렇지 않고 ~/.bash_login이 존재하면 그것을 소스한다. 그렇지 않고 ~/.profile이 존재하면 그것을 소스한다. 종료할 때: 만약 ~/.bash_logout이 존재하면 소스한다. 로그인이 아닌 대화형 쉘: 시동할 때 (-norc와 -rcfile 옵션에 따라 달라진다): 만약 ~/.bashrc이 존재하면 소스한다. 대화형 쉘이 아닌 쉘: 시동할 때: if the environment variable ENV is non-null, expand 만약 환경 변수 ENV가 널이 아니면, 확장한 뒤, 가리키는 파일을 소스한다. 마치 다음과 같은 루틴이라고 보면 된다. if [ \"$ENV\" ]; then . $ENV; fi 그러나 경로명에 탐색을 위해서는 PATH를 사용하지 않는다. POSIX 모드로 시동하지 않았다면, bash는 ENV를 찾기 전에 BASH_ENV를 찾는다. bash를 sh 라는 이름으로 호출하면, 가능한 최대한 sh 의 행동 방식을 흉내내려 한다. 로그인 쉘의 경우, /etc/profile 와 ~/.profile, 만을 순서대로 소스한다. -noprofile 옵션을 주면 이런 행동 방식을 방지할 수 있다. sh 라는 이름으로 호출할 쉘은 기타 다른 시동 파일을 소스하지 않는다. -posix 명령행 옵션을 주어 bash 를 posix 모드로 시작하면 시동 파일에 대하여 POSIX 표준에 따른다. 이 모드에서는 ENV 변수를 확장하여 그 파일을 소스한다; 다른 시동 파일을 읽지 않는다.참고 사항 Bash Features, Brian Fox and Chet Ramey The Gnu Readline Library, Brian Fox and Chet Ramey The Gnu History Library, Brian Fox and Chet Ramey A System V Compatible Implementation of 4.2BSD Job Control, David Lennert Portable Operating System Interface (POSIX) Part 2: Shell and Utilities, IEEE sh(1), ksh(1), csh(1) emacs(1), vi(1) readline(3)파일 /bin/bash bash 실행파일 /etc/profile 시스템 전역 초기화 파일로서 로그인 쉘에서 실행 ~/.bash_profile 개인 초기화 파일로서 로그인 쉘에서 실행 ~/.bashrc 각각의 대화형 쉘에 대한 개별 시동 파일 ~/.inputrc 개별적인 readline 초기화 파일저자 Brian Fox, Free Software Foundation (주 개발자) bfox@ai.MIT.Edu Chet Ramey, Case Western Reserve University chet@ins.CWRU.Edu버그 보고 bash 에서 버그를 발견하면 보고해야 한다. 우선 진짜로 버그인지 확실히 하고 최신 버전의 bash 인지 확인하라. 일단 정말로 버그가 있다고 생각했다면 bashbug 명령을 사용하여 버그를 보고한다. 고친 내용이 있다면 그 내용을 메일로 보낸다면 환영이다! 제안 사항이나 `철학적인' 버그 보고는 bug-bash@prep.ai.MIT.Edu에 메일을 쓰거나 유즈넷 뉴스그룹인 gnu.bash.bug 에 글을 적는다. 모든 버그 보고는 다음을 포함해야 한다: bash의 버전 번호 하드웨어와 운영체계 컴파일 시 사용한 컴파일러 버그에 대한 설명 버그를 내는 간단한 스크립트 또는 'recipe' bashbug 는 버그 보고 시에 사용하는 템플릿에 처음 나오는 3 가지 항목을 자동으로 추가해 준다. 매뉴얼 페이지에 대한 언급과 버그 보그는 chet@ins.CWRU.Edu 로 보낸다.버그 너무 크고 너무 느리다. bash 와 전통적인 sh 버전 간에 약간의 미묘한 차이점이 존재한다. 그 중 대부분은 POSIX 스펙에 의한 것이다. 앨리어스는 일부 사용법에서 혼란스럽다.번역자 이 만 용, 알짜 리눅스 Man-Yong Lee, ALZZA LINUX yong@alzzalinux.com geoman@nownuri.net 번역에 대한 버그 보고 또는 제한 사항은 위 메일로 보내기 바란다.GNU 1995 May 5 BASH(1)","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"bash","slug":"bash","permalink":"http://korcow.github.io/tags/bash/"}]},{"title":"외부명령어 요약","slug":"centos-외부명령어-요약","date":"2017-11-01T17:55:45.000Z","updated":"2017-11-06T05:03:50.085Z","comments":true,"path":"2017/11/02/centos-외부명령어-요약/","link":"","permalink":"http://korcow.github.io/2017/11/02/centos-외부명령어-요약/","excerpt":"","text":"외부 명령어파일 관리 명령어 ls | 파일의 리스트를 보여줌. touch | 파일의 생성일자를 변경. 파일이 없다면 새로운 파일을 만듦. cat | 파일의 내용을 보여줌. more | 파일의 내용을 보여줌.(화면단위) head | 파일의 내용을 파일의 처음을 기준으로 10줄 보여줌. tail | 파일의 내용을 파일의 끝을 기준으로 10줄 보여줌. less | 파일의 내용을 보여주는 프로그램. man page 기본프로그램 which | 명령어의 위치를 알려줌.(명령어가 어느것인지 $PATH에서만 찾음) whereis | 명령어의 위치를 알려줌.(명령어가 어디에 있는지 /bin;/etc;/man 에서찾음) find | 파일을 찾아줌. file | 파일의 정보를 알려줌. cp | 파일을 복사. rm | 파일을 지움. mv | 파일을 이동시킴. grep | 단어(키워드)를 찾아줌. ln | 링크를 만들어줌. mkdir | 디렉토리를 만들어줌. rmdir | 디렉토리를 삭제해줌. wc | 파일의 통계(라인수, 단어수, 문자수)를 보여줌. grep | 패턴을 검색 egrep | 확장된 옵션으로 패턴을 검색 fgrep | 패턴을 검색(문자열로만) ed | 라인 에디터 sed | 스트리밍 에디터 vi | 텍스트 편집 에디터 df | 디스크의 남은 용량을 보여줌. dd | 지정한 블럭 크기만큼 파일을 복사한다. 권한 소유 관리 id | 사용자 모든 id 정보를 보여줌. whoami | 사용자의 id를 보여줌 finger | 사용자의 시스템 사용 현황을 보여줌. chmod | 파일의 권한을 수정함. chown | 파일의 소유권을 수정함. sudo | 다른 사용자로 실행 (옵션이 없으면 root) passwd | 비밀번호를 수정 useradd | 사용자를 추가함.(사용 권한이 있어야 함.) w | 시스템에 로그인된 사용자를 보여줌. who | 현재 사용자의 사용정보를 보여줌. 프로세스관리 top | 시스템 사용 현황을 보여줌. 기본 응용 cal | 달력을 보여줌. date | 날짜와 시간을 보여줌. time | 프로그램이 실행된 실간을 출력.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"}]},{"title":"히스토리","slug":"centos-히스토리","date":"2017-11-01T15:44:28.000Z","updated":"2017-11-04T04:24:38.311Z","comments":true,"path":"2017/11/02/centos-히스토리/","link":"","permalink":"http://korcow.github.io/2017/11/02/centos-히스토리/","excerpt":"","text":"히스토리리눅스는 명령을 수행하면 모든 명령을 history log에 담아 둡니다. history 명령히스토리를 보여줍니다. Ctrl + p 이전 명령을 프롬프트에 나타내 줍니다. !! 이전 명령을 다시 실행해 줍니다. history -rwan [filename] 옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. * 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다;없으면 HISTFILE 변수의 값을 사용한다. 옵션이 있는 경우 다음과 같은 뜻을 갖는다: -a 히스토리 파일에 새로운 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다. -n 히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다. -r 히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다. -w 현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다. 히스토리(HISTORY) 대화형 모드에서 쉘은 이전에 입력한 명령 목록인 명령 히스토리를 접근할 수 있도록 해준다. 최근 HISTSIZE 갯수의 명령 텍스트는(기본 500) 히스토리 목록에 저장된다. 쉘은 각 명령에 대하여 매개변수 확장과 변수 확장 전에 히스토리 목록에 저장한다. ( 확장 참고 ) 그러나 command_oriented_history 와 HISTCONTROL 변수의 값에 따라 히스토리 확장을 수행한 후에 저장하기도 한다. 시동할 때, 히스토리는 HISTFILE 변수가 가리키는 파일로부터 초기화된다. (기본값 ~/.bash_history). HISTFILESIZE 보다 커지지 않도록 필요할 때에는 HISTFILE 파일을 잘라낸다. 내부 명령 fc ( 쉘 내부 명령 참고)을 사용하여 히스토리를 보거나 일부 명령을 편집하여 재실행할 수 있다. history 내부 명령을 사용하여 히스토리 목록을 표시하고 히스토리 파일을 조작할 수 있다. 명령행 편집을 사용할 때 각 모드마다 히스토리 목록을 검색할 수 있는 명령이 있다. 대화형 쉘을 종료하면 최근 HISTSIZE 행만큼이 히스토리 목록으로부터 HISTFILE 로 복사된다. HISTFILE 을 unset하거나 히스토리 파일에 쓸 수 없을 때는 히스토리를 저장하지 않는다. 히스토리 확장(HISTORY EXPANSION) 쉘에서는 csh 의 히스토리 확장과 유사한 히스토리 확장 기능을 지원한다. 이 섹션에서는 사용 가능한 기능의 문법을 설명한다. 대화형 쉘에서는 기본 동작하며 +H option to the set 내부 명령에 +H 옵션을 주어 해제할 수 있다. ( 쉘 내부 명령 참고) 비대화형 모드 쉘에서는 히스토리 확장을 수행하지 않는다. 히스토리 확장은 완전한 행이 읽히고 쉘이 단어로 분리하기 전에 즉시 수행된다. 두 부분에서 일어난다. 우선 이전 히스토리로부터 어떤 행을 가져가 치환에 사용할 것인지 결정한다. 두번째는 현재 행에 포함시키기 위해 그 행의 일부분을 선택한다. 이전 히스토리로부터 선택된 행을 이벤트(event)라 하며 행동이 취해 질 그 행의 일부분을 단어(words)라고 한다. 행은 입력을 읽어 들일 때와 같은 방식으로 단어로 분리되며 따라서 몇 가지 메타문자에 의해 구분된 단어가 쿼우트로 둘러 싸이면는 하나의 단어로 취급한다. 오로지 백슬래쉬()와 싱글 쿼우트만이 히스토리 이스케이프 문자를 (기본값 !) 쿼우트할 수 있다. 히스토리 확장 메커니즘에서 사용하는 다양한 문자를 제어할 수 있다. ( 쉘 변수 섹션에서 histchars 설명 참고 ) 이벤트 지시자(Event Designators) 이벤트 지시자는 히스토리 목록의 명령행 항목에 대한 참조이다. ! 그 뒤에 공백, 개행문자, = 또는 ( 가 나오는 경우를 제외하고 히스토리 치환을 시작하도록 한다. !! 이전 명령을 가리킨다. !-1와 동의어이다. !n n 번 명령행을 가리킨다. !-n 현재 명령행에서 n 를 뺀 행을 가리킨다. !문자열 문자열 로 시작하는 가장 최근 명령을 가리킨다. !?문자열[?] 문자열 을 포함하는 가장 최근 명령을 가리킨다. ^문자열1^문자열2^ 빠른 치환. 지난 번 명령에 대하여 문자열1 을 문자열2 로 바꾸어 실행한다. ``!!:s/문자열1/문자열2/``와 같다. (변경자(Modifiers) 참고). !# 지금까지 입력한 전체 명령행. - 단어 지시자 : 는 단어 지시자로부터 이벤트 명시를 분리한다. 단어 지시자가 ^, $, *, % 로 시작할 때에는 생략할 수 있다. 단어는 행의 처음부터 시작하여 세며 첫번째 단어는 0(숫자 영) 으로 나타낸다. 0 (숫자 영) 0 번째 단어. 쉘에 있어 명령 단어에 해당한다. n n번째 단어. ^ 첫번째 인수 즉 단어 1 이다. $ 마지막 인수. % 가장 최근의 ``?문자열?`` 검색과 일치하는 단어 x-y 단어의 범위; ``-y`` 는 ``0-y``와 같이 줄여 쓴다. * 0 번째를 제외한 모든 단어. ``1-$``와 동의어이다 이벤트에 단어 하나만 있을 때에도 * 를 사용하는 것은 에러가 아니다; 이 경우 빈 문자열이 반환된다. x* x-$를 줄여 쓴 것이다. x- x*와 같이 x-$를 줄여 쓴 것이지만 마지막 단어를 제외한다. 변경자(Modifiers) 선택적인 단어 지시자 뒤에 앞에 :를 붙여 다음과 같은 변경자를 추가할 수 있다. h 머리 부분만 남기도 뒷부분 경로명 부분을 제거한다. r 베이스 이름만 남기고 .xxx 형태의 뒷부분 꼬리말을 제거한다. e 꼬리말을 제외하고 모두 제거한다. t 꼬리 부분은 남기고 앞에 나오는 모든 경로명 부분을 제거한다. p 새로운 명령을 출력하지만 실행하지는 않는다. q 치환된 단어를 쿼우트하여 더 이상 치환이 일어나지 않도록 해석금지시킨다. x q 과 함께 사용하여 치환된 단어를 쿼우트한다. 그러나 공백 과 개행문자에서 단어를 분리한다. s/예전것/새것/ 이벤트 행에서 처음 나오는 예전것 을 새것 으로 교체한다. / 대신 어떤 분리자도 사용 가능하다. 마지막 분리자가 이벤트 행의 마지막 단어일 때는 생략 가능하다. 예전것 과 새것 안에서 단일 백슬래쉬를 사용하여 분리자를 쿼우트할 수 있다. 새것 안에 &amp; 이 있으면 그 문자는 예전것 으로 치환된다. 단일 백슬래쉬를 사용하여 &amp; 를 쿼우트할 수 있다. &amp; 이전 치환을 반복한다. g 변화 내용을 전체 이벤트 행에 적용하도록 한다. ``:s`` (예, ``:gs/예전것/새것/``) 또는 ``:&amp;``와 사용한다. If used with ``:s``와 사용하면 ``/`` 대신 어떤 분리자든 사용할 수 있으며 마지막 분리자가 이벤트 행의 마지막 문자일 때는 생략할 수 있다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"history","slug":"history","permalink":"http://korcow.github.io/tags/history/"}]},{"title":"경로이동하기","slug":"centos-경로이동하기","date":"2017-11-01T14:55:27.000Z","updated":"2017-11-06T03:26:25.249Z","comments":true,"path":"2017/11/01/centos-경로이동하기/","link":"","permalink":"http://korcow.github.io/2017/11/01/centos-경로이동하기/","excerpt":"","text":"경로이동하기 pwd 현재의 경로를 확인합니다. . 현재의 경로를 의미합니다. ./abc 현재경로에 있는 abc파일을 실행합니다. .. 상위경로를 의미합니다. cd .. 부모경로로 이동합니다. cd 디렉토리명으로 경로를 이동할 수 있습니다. cd temp 디렉토리 이름을 쓸때 Tab키를 누르면 자동완성 바로전 경로로 이동하려면 cd - 홈디렉토리로 이동하려면 cd ~ 현재의 경로를 저장하려면 pushd . 절대경로로 지정 pushd /etc/apache2/conf 저장된 경로로 이동하려면 popd 상대 경로와 절대 경로상대경로 현재 위치의 경로를 기준../ 부모 경로로 이동 절대경로 /를 기준","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"cd","slug":"cd","permalink":"http://korcow.github.io/tags/cd/"},{"name":"pushd","slug":"pushd","permalink":"http://korcow.github.io/tags/pushd/"},{"name":"popd","slug":"popd","permalink":"http://korcow.github.io/tags/popd/"}]},{"title":"복사하기","slug":"centos-복사하기","date":"2017-11-01T05:42:06.000Z","updated":"2017-11-03T11:43:10.888Z","comments":true,"path":"2017/11/01/centos-복사하기/","link":"","permalink":"http://korcow.github.io/2017/11/01/centos-복사하기/","excerpt":"","text":"cp(복사하기)리눅스에서 파일을 복사하는 명령입니다.파일 하나만 복사할 수도 있도 여러개를 복사할 수도 있습니다.물론 디렉토리도 복사할 수 있습니다. 파일하나 복사 cp abc.txt anydir abc.txt 파일을 현재위치의 anydir/abc.txt 로 복사 cp abc.txt anydir/cde.txt 이름을 바꾸어 저장할 수도 있습니다. 여러개의 파일을 복사 cp abc.txt bcd.txt anydir 여러개의 파일을 직접 지정해서 복사 할 수 있습니다. cp * anydir 모든 파일을 anydir로 복사합니다. 와일드 카드 사용법을 참고하세요. cp *.txt anydir 모든 .txt로 끝나는 파일을 anydir로 복사합니다. cp *[[:alpha:]a][].txt anydir 모든 .txt로 끝나는 파일을 anydir로 복사합니다. cp $(ls *.txt) anydir 12$ ls *.txt$ cp !! anydir 디렉토리를 복사 cp -R sodir anydir 현재 경로의 sodir디렉토리및 하위 디렉토리 까지 anydir로 복사합니다. 파일과 디렉토리리눅스에서는 엄밀히 디렉토리라는 것이 없습니다 편의상 그렇게 부르는것 뿐입니다. 장치나 디렉토리나 모두 파일로 간주 합니다. 다만 파일의 특성이 있는 겁니다. 리눅스에서 디렉토리라고 부르는 파일의 특성은 자식파일을 갖을 수 있습니다. 자신의 권한과 소유권을 자식에게 승계 합니다. 자식 파일을 갖는 파일은 생성시 mkdir명령으로 생성합니다. ls의 -l 옵션으로 특성을 확인 할 수 있습니다. ls는 파일의 리스트를 확인 하는 프로그램입니다. 앞으로 편의상 디렉토리로 부를 겁니다. ^^; 123456789$ ``ls -l``합계 24drwxr-xr-x. 2 root root 20 11월 1 15:17 anyfolder-rw-r--r--. 1 root root 6072 11월 1 14:48 cp.doc-rw-rw-r--. 1 korcow korcow 13439 10월 28 09:33 ls.doc$ touch aaa$ mkdir aaamkdir: `aaa` 디렉토리를 만들 수 없습니다: 파일이 있습니다 cp 명령을 사용하다 에러가 나면 man page를 확인하세요. 대부분 권한, 소유권, 하위에 디렉토리 여부, 소프트링크 관련 에러 입니다.복사가 힘들다고 불평하지 마세요. 보안의 강화 때문입니다. 소중한 자료를 아무나 허락 없이 가져가면 안되죠… cp 한글 man page123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123CP(1) General Commands Manual CP(1)NAME cp - 파일 복사SYNOPSIS cp [options] source dest cp [options] source... directory Options: [-abdfilprsuvxPR] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;] [--backup] [--no-dereference] [--force] [--interactive] [--one-file- system] [--preserve] [--recursive] [--update] [--verbose] [--suf‐ fix=backup-suffix] [--version-control=&#123;numbered,existing,simple&#125;] [--archive] [--parents] [--link] [--symbolic-link] [--help] [--version]DESCRIPTION 이 문서는 더이상 최신 정보를 담고 있지않다. 그래서, 몇몇 틀릴 경우도 있고, 부족한 경우도 있을 것이다. 완전한 매뉴얼을 원하면, Texinfo 문서를 참조하기 바란다. 이 매뉴얼 페이지는 cp 명령의 GNU 버전에 대한 것이다. 마지막 명령행 인자로 경로가 지정되면, cp 명령은 지정한 source 파일들을 그 경로로 안으로 복사한다. 한편 명령행 인자로 두개의 파일 이름이 사용되면, 첫번째 파일을 두번째 파일로 복사한다. 마지막 명령행 인자가 경로가 아니고, 두개 이상의 파일이 지정되면, 오류 메시지를 보여준다. 초기값으로 경로는 복사하지 않는다. OPTIONS -a, --archive 원본 파일의 속성, 링크 정보들을 그대로 유지하면서 복사한다. 이 옵션은 -dpR 옵션과 같은 역활을 한다. -b, --backup 복사할 대상이 이미 있어, 이것을 덮어쓰거나 지울경우에 대비해 백업본을 만든다. -d, --no-dereference 만약 복사할 원본이 심블릭 파일이면, cp 명령은 그 심블릭 대상이 되는 파일을 복사한다. 이렇게 하지 않고, 단지 그 심블릭 파일 자체를 심블릭 정보와 함께 복사하고 할 때, 이 옵션을 사용한다. -f, --force 만약 복사 대상 파일이 이미 있으면 강제로 지우고 복사한다. -i, --interactive 만약 복사 대상 파일 이미 있으면 사용자에게 어떻게 처리 할 것인지 물어보는 프롬프트를 나타나게 한다. -l, --link 하드링크 형식으로 복사한다. 물론 하드 링크형식이기에 경로는 복사할 수 없다. -P, --parents 원본 파일에 지정을 경로와 같이 했을 경우, 그 경로 그대로 복사 된다. 이때는 대상으로 사용될 수 있는 것은 경로 이름이어야만 한다. 예를 들어, ``cp --parents a/b/c existing_dir`` 명령이 사용된다면, 이것의 결과는 existing_dir/a/b/c 이런 식이 된다. -p, --preserve 원본 파일의 소유주, 그룹, 권한, 시간정보들이 그대로 보존되어 복사된다. -r 일반 파일이면, 그냥 복사되고, 만약 원본이 경로면, 그 경로와 함께 경로 안에 있는 모든 하위경로, 파일들이 복사된다. -s, --symbolic-link 경로가 아닌 일반 파일을 심블릭 링크 형식으로 복사한다. 이때는 복사할 원본 파일 이름은 절대경로(``/``로 시작하는 경로)로 지정된 파일이름이어야 한다. 심블릭 링크를 지원하지 않는 시스템에서 이옵션을 사용할 경우에는 오류 메시지를 보여준다. -u, --update 복사할 대상이 이미 있는데, 이 파일의 변경 날짜가 같거나, 더 최근의 것이면 복사하지 않는다. -v, --verbose 각 파일의 복사 상태를 자세히 보여준다. -x, --one-file-system 원복과 대상 파일의 파일 시스템이 다를 경우에는 복사하지 않는다. -R, --recursive 경로를 복사할 경우에는 그 안에 포함된 모든 하위경로와 파일들을 모두 복사한다. --help 도움말을 보여주고 마친다. --version 버전 정보를 보여주고 마친다. -S, --suffix backup-suffix 만약에 복사 대상이 이미 있어, 백업을 해야할 경우에 그 백업 파일에서 사용할 파일 이름의 꼬리 문자를 지정한다. 이것은 이미 지정되어 있는 SIMPLE_BACKUP_SUFFIX 환경 변수를 무시하게 된다. 만약 이 환경변수도 지정되어 있지 않고, 이 옵션도 사용하지 않는다면, 초기값으로 Emacs과 같이 ``~`` 문자를 사용한다. -V, --version-control &#123;numbered,existing,simple&#125; 백업하는 방법을 지정하는데, 이 옵션은 이미 지정되어 있는 VER‐ SION_CONTROL 환경 변수를 무시한다. 만약 이 환경 변수도 지정되어 있지 않고, 이 옵션도 사용하지 않는다면, 초기값으로 ``existing``을 사용한다. 여기서 사용하는 백업방법은 GNU Emacs의 ``version-con‐ trol`` 값과 같다. 아래와 같이 보다 짧은 지시어들도 사용될 수 있다. 여기서 사용될 수 있는 백업 방법은 아래와 같다. ``t`` 또는 ``numbered`` 항상 번호 있는 백업본을 만든다. ``nil`` or ``existing`` 대상 파일이 이미 있을 경우에만 백업본을 만든다. ``never`` or ``simple`` 간단한 백업을 만듬.FSF GNU File Utilities CP(1)---","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"cp","slug":"cp","permalink":"http://korcow.github.io/tags/cp/"}]},{"title":"CtrlP 플러그인","slug":"vim-ctrlp-플러그인","date":"2017-10-31T13:22:20.000Z","updated":"2017-11-03T11:55:41.785Z","comments":true,"path":"2017/10/31/vim-ctrlp-플러그인/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-ctrlp-플러그인/","excerpt":"","text":"기본사용법 Ctrl+p를 누르면 하단에 파일검색 모드가 열립니다. Ctrl+f를 누르면 모드가 바뀝니다. 현재열린 버퍼 &gt; 파일 &gt; 전체 Ctrl+j, Ctrl+k 아래, 위로 이동(파일선택) Command-line에서는 아래와 같이 Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode. Run :CtrlPBuffer or :CtrlPMRU to invoke CtrlP in find buffer or find MRU file mode. Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time. Check :help ctrlp-commands and :help ctrlp-extensions for other commands.Once CtrlP is open: Press &lt;F5&gt; to purge the cache for the current directory to get new files, remove deleted files and apply new ignore options. Press &lt;c-f&gt; and &lt;c-b&gt; to cycle between modes. Press &lt;c-d&gt; to switch to filename only search instead of full path. Press &lt;c-r&gt; to switch to regexp mode. Use &lt;c-j&gt;, &lt;c-k&gt; or the arrow keys to navigate the result list. Use &lt;c-t&gt; or &lt;c-v&gt;, &lt;c-x&gt; to open the selected entry in a new tab or in a new split. Use &lt;c-n&gt;, &lt;c-p&gt; to select the next/previous string in the prompt’s history. Use &lt;c-y&gt; to create a new file and its parent directories. Use &lt;c-z&gt; to mark/unmark multiple files and &lt;c-o&gt; to open them. Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help. Submit two or more dots .. to go up the directory tree by one or multiple levels. End the input string with a colon : followed by a command to execute it on the opening file(s): Use :25 to jump to line 25. Use :diffthis when opening multiple files to run :diffthis on the first 4 files.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"vundle","slug":"vundle","permalink":"http://korcow.github.io/tags/vundle/"},{"name":"ctrlp","slug":"ctrlp","permalink":"http://korcow.github.io/tags/ctrlp/"}]},{"title":"shell이란","slug":"centos-shell이란","date":"2017-10-31T07:02:59.000Z","updated":"2017-11-01T05:10:46.129Z","comments":true,"path":"2017/10/31/centos-shell이란/","link":"","permalink":"http://korcow.github.io/2017/10/31/centos-shell이란/","excerpt":"","text":"리눅스 시스템이 부팅이 완료되고 로그인을 하면 커서가 깜빡이며 명령 수행을 대기합니다. 이것을 shell prompt 라고합니다.shell은 interpreter 입니다. 명령을 해석하고 올바른 명령이라면 kernel로 명령을 전달하고 처리 합니다. shell이 interpreter라고 했습니다. 컴파일러는 명령을 모두 해석해서 한번에 처리합니다.인터프리터는 명령을 한줄씩 해석해서 처리 합니다. 둘다 컴퓨터 언어 이기 때문에 변수, 상수, 자료형, 연산자, 예약어, 조건문, 반복문, 함수, 배열등이 존재 합니다. shell의 내부명령어는 예약어 입니다. cd, pwd, type, bg, fg 등… 언어 이기 때문에 계산도 가능합니다. 123$echo $((1+1))2$ 사칙연산과 우선순위도 있습니다.프로그래밍도 가능합니다.bash script programming 부분에서 프로그래밍을 다루고 지금은 shell은 인터프리터라는 것만 기억 하시면 됩니다. 컴퓨터를 켜면 커서가 깜빡이는데 우리가 입력하는 것은 프로그램 명령이구나 이정도만 기억 하시면 됩니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://korcow.github.io/tags/shell/"}]},{"title":"와일드카드","slug":"centos-와일드카드","date":"2017-10-31T06:29:20.000Z","updated":"2017-11-03T12:14:25.868Z","comments":true,"path":"2017/10/31/centos-와일드카드/","link":"","permalink":"http://korcow.github.io/2017/10/31/centos-와일드카드/","excerpt":"","text":"와일드 카드는 반드시 알고 있어야 하는 명령입니다.물론 정규식을 사용해도 되지만 왠만한 것은 와일드카드로 문제 없이 사용가능합니다. 여러개의 파일의 일괄처리가 필요할 경우, 파일의 삭제, 복사, 이동, 문자열 추가, 삭제, 치환등을 처리할때 꼭 필요합니다. 와일드카드 문자 설명 * 모든 문자 0개 이상 ? 문자하나 반드시 1문자 [characters] characters 문자 집합에 포함된 1문자 [!characters] characters 문자 집합에 포함 되지 않은 1문자 [[:class:]] 알파벳과 숫자를 지정 [:alnum:] 알파벳과 숫자를 지정 [:alpha:] 알파벳 지정 [:digit:] 숫자를 지정 [:lower:] 모든 소문자 [:upper:] 모든 대문자 ls 명령을 사용해 와일드 카드를 사용해 보겠습니다.ls명령과 와일드카드 명령 2개를 같이 사용하는 겁니다. 테스트용 디렉토리와 파일 만들기1234$cd ~$mkdir myTest$cd test$touch a&#123;a..d&#125;&#123;a..c&#125;&#123;1..3&#125;.txt ls a*a로 시작하는 모든 파일을 보여줍니다. ls a*.txta로 시작하고 .txt로 끝나는 모든 파일을 보여줍니다. ls ?b?.txt첫문자는 아무 문자나 와도 되고 두번째는 b 세번째는 아무문자 마지막에 .txt로 끝나는 파일을 보여줍니다. ls *.txt.txt로 끝나는 모든 파일을 보여줍니다. ls *[[:digit:]1].txt1.txt앞에 숫자 1만 있으면 그앞에 어떤 문자가 와도 모두 보여줍니다. ls *[abc]*파일명 중간이 abc로 된 파일을 모두 보여줍니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"와일드카드","slug":"와일드카드","permalink":"http://korcow.github.io/tags/와일드카드/"}]},{"title":"ls","slug":"centos-ls","date":"2017-10-31T04:27:36.000Z","updated":"2017-11-03T19:58:43.775Z","comments":true,"path":"2017/10/31/centos-ls/","link":"","permalink":"http://korcow.github.io/2017/10/31/centos-ls/","excerpt":"","text":"외부명령어ls디렉토리의 파일 목록을 보는 명령입니다. 파일의 목록을 볼때 어떻게 확인할지 옵션을 주어 파일을 볼수 있습니다. ls –help 또는 man ls로 설명을 볼 수 있습니다. 내부명령의 파이프라인과 리다이렉션을 이용해 목록의 출력 방향을 조정 하거나 리스트 결과를 다른 프로그램의 인자로 전달 할 수 있습니다. 와일드카드 문자 설명 * 모든 문자 0개 이상 ? 문자하나 반드시 1문자 [characters] characters 문자 집합에 포함된 1문자 [!characters] characters 문자 집합에 포함 되지 않은 1문자 [[:class:]] 아래 클래스를 지정합니다. [:alnum:] 알파벳과 숫자를 지정 [:alpha:] 알파벳 지정 [:digit:] 숫자를 지정 [:lower:] 소문자 [:upper:] 대문자 ls명령은 와일드카드와 같이 사용합니다. ls: 디렉토리의 파일 리스트를 출력합니다. ls a*: a로 시작하는 모든 파일을 보여 달라는 명령입니다. ls a???: a로 시작하고 문자의 길이가 총4개인 파일만 보여 달라는 명령입니다. ls -a: 숨김 파일도 보여 줍니다. ls -ld .?* 숨김 파일만 보여줍니다. ls -l: 리스트의 형태로 목록을 보여 줍니다. ls -al: 옵션을 조합해서 사용할 수 있습니다. 리스트의 형태로 숨김파일까지 보여 달라는 명령입니다. ls -al [[:alpha:][:alpha:][:alpha:][:digit:]].txt 알파벳3글자와숫자1로된 .txt로 끝나는 파일을 보여달라는 명령입니다. ls 명령은 find, grep, more, sed, vim, cp, mv, rename, rm 등 외부 명령과 조합 해서 사용할 수 있어야 합니다. 단순히 파일 목록만 확인 하는 것이 아니라 파일을 찾은후 파일에 문자열을 추가, 삭제, 실행 등의 작업을 할 수 있습니다. 이부분은 해당 명령에서 다루도록 하겠습니다. 리눅스의 명령은 유닉스, macos의 명령과 100% 같지 않습니다. 기본적인 기능은 거의 같지만 옵션이 틀릴수 있으니 동작이 안된다면 해당 OS의 man page를 참고해야 합니다.windows의 batch script도 알아 두면 좋습니다. 상호간의 통신을 위해 어려운 프로그램 개발을 안해도 됩니다. 참고로 아래는 centos의 한글 man page 입니다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291LS(1) General Commands Manual LS(1)NAME ls, dir, vdir - 경로의 내용을 나열한다.SYNOPSIS ls [-abcdfgiklmnpqrstuxABCFGLNQRSUX1] [-w cols] [-T cols] [-I pattern] [--all] [--escape] [--directory] [--inode] [--kilobytes] [--numeric-uid-gid] [--no-group] [--hide-control-chars] [--reverse] [--size] [--width=cols] [--tabsize=cols] [--almost-all] [--ignore-backups] [--classify] [--file-type] [--full- time] [--ignore=pattern] [--dereference] [--literal] [--quote-name] [--recursive] [--sort=&#123;none,time,size,extension&#125;] [--format=&#123;long,ver‐ bose,commas,across,vertical,single-column&#125;] [--time=&#123;atime,access,use,ctime,status&#125;] [--help] [--version] [--color[=&#123;yes,no,tty&#125;]] [--colour[=&#123;yes,no,tty&#125;]] [name...]DESCRIPTION 이 문서는 더이상 최신 정보를 담고 있지않다. 그래서, 몇몇 틀릴 경우도 있고, 부족한 경우도 있을 것이다. 완전한 매뉴얼을 원하면, Texinfo 문서를 참조하기 바란다. 이 매뉴얼 페이지는 ls 명령의 GNU 버전에 대한 것이다. dir과 vdir 명령은 ls 명령의 심블릭 파일로 그 출력 양식을 다르게 보여주는 풀그림들이다. 인자로 파일이름이나, 경로 이름이 사용된다. 경로의 내용은 초기값으로 알파벳 순으로 나열된다. ls의 경우는 출력이 표준 출력(터미날 화면)이면, 세로로 정열된 것이 가로로 나열된다. 다른 방식의 출력이면 한줄에 하나씩 나열된다. dir의 경우는, 초기값으로 ls와 같으나, 모든 출력에서 세로로 정열해서 가로로 나열한다.(다른 방식의 출력에서도 항상 같음) vdir의 경우는, 초기값으로 목록을 자세히 나열한다. OPTIONS -a, --all 경로안의 모든 파일을 나열한다. ``.``으로 시작하는 파일 들도 포함된다. -b, --escape 알파벳 형식을 사용하는 파일 이름안에서 그래픽 문자가 아닌 문자들을 사용한다. C와 같이 여덟가지 역슬래쉬 문자(`\\&apos;)와 함께 오는 문자들을 사용한다. -c, --time=ctime, --time=status 파일 최근 변경 시간에 따라 정열 해서 보여준다. 자세한 나열(-l 옵션)이면, 그 파일의 최근 변경 시간을 보여준다. -d, --directory 경로안의 내용을 나열하지 않고, 그 경로를 보여준다.(이것은 쉘 스크립트에서 유용하게 쓰인다.) -f 경로 내용을 정열하지 않는다: 이것은 디스크에 저장된 순으로 보여준다. -a와 -U 옵션과 같은 뜻이며, -l, -s, -t. 옵션과 반대뜻이다. --full-time 시간을 간략히 표시하지 않고, 모두 보여 준다. -g 무시: 유닉스 호환을 위해서 있음. -i, --inode 파일 왼쪽에 색인 번호를 보여준다. -k, --kilobytes 파일 크기가 나열되면, kb 단위로 보여준다. 이 옵션은 POSIXLY_CORRECT 환경 변수를 무시한다. -l, --format=long, --format=verbose 파일 나열에 있어, 파일 형태, 사용권한, 하드링크 번호, owner 이름, group 이름, 파일 크기, 시간(따로 지정하지 않으면 파일이 만들어진 날자다)을 자세하게 나열한다. 시간은 여섯달 이전 것이면, 시간이 생략되고, 파일의 연도가 포함된다. -m, --format=commas 파일을 가로로 나열한다. 가로로 나열할 수 있는 만큼 최대한 나열한다. -n, --numeric-uid-gid 이름의 나열에서 UID,GID 번호를 사용한다. -p 파일 형태를 지시하는 문자를 각파일에 추가한다. -q, --hide-control-chars 파일 이름에 그래픽 문자가 아닌 것이 있으면, ``?``로 표시한다. -r, --reverse 정열 순서를 내림차순으로 한다. -s, --size 파일 크기를 1Kb 단위로 나타낸다. POSIXLY_CORRECT 환경 변수가 지정되면, 512b 단위로 지정된다. -t, --sort=time 파일 시간 순으로 정열한다. 최근 파일이 제일 먼저. -u, --time=atime, --time=access, --time=use 파일 사용 시간 순으로 정열한다. 자세한 나열이면, 시간 표시는 만들어진 날자대신, 사용된 날자를 보여준다. -x, --format=across, --format=horizontal 정열 방식을 가로로 한다. -A, --almost-all ``.``, ``..`` 경로를 제외하고 디렉토리안의 모든 파일을 나열한다. -B, --ignore-backups 파일 끝이 `~&apos;인 파일은 목록 나열에 제외된다. -C, --format=vertical 정열 방식을 세로로 한다. -F, --classify 파일 형식을 알리는 문자를 각 파일 뒤에 추가한다. 일반적으로 실행파일은 &quot;*&quot;, 경로는 &quot;/&quot;, 심블릭 링크는 &quot;@&quot;, FIFO는 &quot;|&quot;, 소켓은 &quot;=&quot;, 일반적인 파일은 없다. -G, --no-group 자세한 목록 나열에서 group 정보를 제외한다. -L, --dereference 심블릭 링크 파일들을 그냥 파일로 보여준다. -N, --literal 이름이 영문이 아닌 경우, C에서 사용하는 역슬래쉬 문자(`\\&apos;)와 함께 사용하는 표기 대신 그대로 출력한다. -Q, --quote-name -N 옵션과 반대. -R, --recursive 하위 경로와 그 안에 있는 모든 파일들도 나열한다. -S, --sort=size 파일 크기가 가장 큰 것 부터 정열해서 나열한다. -U, --sort=none 정열을 하지 않고, 디스크에 저장된 순서대로 보여준다. 이 옵션은 -f 옵션을 사용할 수 없다. 유닉스 용 ls -f는 -a 옵션은 가능하나, -l, -s, -t 옵션이 불가능하기 때문이다. -X, --sort=extension 파일 확장자 순으로 정열한다. 확장자가 없는 파일이 제일 먼저 나열된다. -1, --format=single-column 한 줄에 한 파일씩 나열. -w, --width cols 가로 길이를 값으로 지정한다. 기본적으로는 한 화면의 가로 값이된다. 또한 COLUMNS 환경 변수 값으로 지정할 수 있다. 초기값은 80이다. -T, --tabsize cols 탭이 사용될 때, cols 값으로 지정한다. 초기값은 8이다. 0으로 지정되면 탭 문자는 무시된다. -I, --ignore pattern pattern 패턴으로 지정된 파일들은 목록에서 제외된다. 이때, 명령행에서 그 파일이 지정되면 물론 나열된다. --color, --colour, --color=yes, --colour=yes 파일의 형태에 따라 그 파일의 색깔을 다르게 보여주는 기능한다. 자세한 이야기는 아래 DISPLAY COLORIZATION 부분을 참조한다. --color=tty, --colour=tty --color 옵션과 같으나, 단지 표준 출력에서만 색깔을 사용한다. 이 옵션은 칼라 제어 코드를 지원하지 않는 보기 풀그림을 사용하는 쉘 스크립트나, 명령행 사용에서 아주 유용하게 쓰인다. --color=no, --colour=no 색깔 사용하지 않는다. 이것이 초기값이다. 이옵션은 색깔 사용을 이미 하고 있다면, 이 값을 무시한다. --help 도움말을 보여주고 마친다. --version 버전 정보를 보여주고 마친다. DISPLAY COLORIZATION --color 옵션을 사용할 때, 이 버전의 ls 명령은 파일 이름이나, 파일 형태에 따라 파일의 색깔별로 나열할 수 있다. 이 칼라화는 초기값으로 파일 형태에 따라서만 사용된다. 사용되는 코드는 ISO 6429 (ANSI)이다. 이런 초기 색깔 지정은 LS_COLORS (또는 LS_COLOURS) 환경 변수 지정으로 바꿀 수 있다. 이 변수들의 형식은 term‐ cap(5) 파일 포멧의 방식을 사용한다. 각 항목은 &quot;:&quot;으로 하며, 각 항목은 &quot;xx=문자열&quot;로 한다. xx에는 두개의 문자가 오는데, 여기서 사용할 수 있는 문자는 다음과 같다. no 0 파일 이름이 아닌 일반 텍스트 fi 0 일반 파일 di 32 경로 ln 36 심블릭 링크 pi 31 FIFO(파이프) so 33 소켓 bd 44;37 블럭 장치 cd 44;37 캐릭터 장치 ex 35 실행 파일 mi (없음) 잃어버린 파일 (초기값은 fi) or (없음) 심블릭 링크 대상이 없는 파일(초기값은 ln) lc \\e[ 왼쪽 코드 rc m 오른쪽 코드 ec (없음) 마침 코드 (lc+no+rc로 바뀜) 색깔을 바꿀 경우는 그 해당 변수만 바꾸면 된다. 파일 이름은 파일의 확장자에 따라 색깔을 지정할 수 있다. LS_COLORS 환경 변수에 포함하면 되고, 그 사용법은 위와 같다. 문법은 &quot;*ext=문자열&quot;이다. 예를 들어, C 소스 파일을 파란색으로 지정하려면, &quot;*.c=34&quot;이다. 제어 문자는 C에서와 갈이 `\\&apos;문자로 시작하는 문자를 사용하거나, stty와 같이 `^&apos;문자로 시작하는 문자를 사용할 수 있다. C 스타일일 경우는 \\e는 Esc, \\_ 공백문자, \\? Delete 이다. 추가로, \\ escape 문자는 \\, ^, :, =의 초기 처리 방식을 무시하는데 사용될 수 있다. 각 파일은 &lt;lc&gt; &lt;색깔값&gt; &lt;rc&gt; &lt;파일이름&gt; &lt;ec&gt; 형태로 지정 된다. 만약 &lt;ec&gt; 코드를 지엉하지 않으면, &lt;lc&gt; &lt;no&gt; &lt;rc&gt; 가 대치된다. 이 방법은 보다 많은 변환을 하지만 일반적인 방법은 아니다. 왼쪽, 오른쪽, 마지막 코드는 일반적인 ISO 6429 코드를 지원하지 않는 터미날을 위한 값으로 특별한 경우가 아니면, 사용할 필요가 없다. ISO 6429 코드일 경우 사용될 수 있는 코드값은 다음과 같다. (물론 lc, rc, ec 값은 제외된다.) 0 초기 색깔로 다시 돌린다. 1 강조색 4 밑줄 5 깜빡이는 글자. 30 까만색 전경 31 빨강 전경 32 녹색 전경 33 노랑(또는 갈색) 전경 34 파랑 전경 35 보라 전경 36 청록색 전경 37 흰색(또는 회색) 전경 40 까만색 배경 41 빨강 배경 42 녹색 배경 43 노랭(또는 갈색) 배경 44 파랑 배경 45 보라 배경 46 청록색 배경 47 흰색(또는 회색) 배경 모든 명령이 모든 시스템이나 디스플레이 장치에서 제대로 동작하는 것은 아니다. 몇 터미날은 초기 마지막코드(ec)가 인식되지 않을 수 있다. 만약, 색들을 사용했다면, no, fi 값을 0으로 지정해 초기값으로 되돌려 놓아야 한다.BUGS BSD 시스템에서는, -s 옵션이 HP-UX 시스템으로 부터 NFS 마운트된 파일을 위한 파일 크기가 반으로 잘못 보여진다고 한다. HP-UX 시스템에서는, BSD 시스템으로 부터 NFS 마운트된 파일을 위한 파일의 크기가 반대로 두배로 나타난다. 이런 현상은 HP-UX ls 풀그림도 마찬가지라고 한다. 영어권 문자셋을 사용할 경우는 별 문제가 없지만, 한국어와 같이 2바이트 문자권에서는 자국어로 된 파일 이름을 보기 위해 특별한 옵션을 지정해 주어야한다. ``-N --color=tty`` 옵션이 그 옵션이다.FSF GNU File Utilities LS(1)","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"ls","slug":"ls","permalink":"http://korcow.github.io/tags/ls/"},{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"}]},{"title":"외부명령어","slug":"centos-외부명령어-1","date":"2017-10-31T04:18:25.000Z","updated":"2017-11-03T11:38:51.394Z","comments":true,"path":"2017/10/31/centos-외부명령어-1/","link":"","permalink":"http://korcow.github.io/2017/10/31/centos-외부명령어-1/","excerpt":"","text":"외부명령어","categories":[],"tags":[]},{"title":"solarized_theme적용하기","slug":"vim-solarized-theme적용하기","date":"2017-10-30T18:01:54.000Z","updated":"2017-11-03T11:53:18.581Z","comments":true,"path":"2017/10/31/vim-solarized-theme적용하기/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-solarized-theme적용하기/","excerpt":"","text":"터미널 Solarized Theme 적용12345678910111213141516171819202122232425262728293031323334353637$mkdir -p ~/.mysetting/Solarized$cd ~/.mysetting/Solarized$git clone https://github.com/sigurdga/gnome-terminal-colors-solarized.git$cd gnome-terminal-colors-solarized$./install.sh그럼 다음과 같은 순서 대로 물어 물어 옵니다.색상 선택: 1번을 선택Please select a color scheme:1) dark2) dark_alternative3) light#? 1프로파일 선택: 1번을 선택Please select a Gnome Terminal profile:1) 이름 없음#? 1You have selected: Scheme: dark Profile: 이름 없음 (b1dcc9dd-5262-4d8d-a863-c897e6d979b9)프로파일을 덮어쓰겠냐고 물으면 yes를 입력Are you sure you want to overwrite the selected profile?(YES to continue) yesConfirmation received -- applying settingsA dircolors adapted to solarized can be automatically downloaded.1) Download seebi' dircolors-solarized: https://github.com/seebi/dircolors-solarized2) [DEFAULT] I don't need any dircolors.디렉토리및파일 색상 변경을 설치하겠냐고 물으면 2번을 눌러 설치 안함을 선택.Enter your choice : [2] 2 터미널을 종료했다 다시 실행하면 됩니다. 터미널 디렉토리및 파일 색상 설정(CentOS 만)1234$cd ~/.mysetting/solarized$git clone https://github.com/seebi/dircolors-solarized$vi ~/.bash_profile 맨밑에 아래 줄을 붙여 넣으세요. 123eval `dircolors ~/.mysetting/solarized/dircolors-solarized/dircolors.ansi`:wq 터미널을 종료 하고 재실행하면 반영됩니다.또는 1$suource ~/.bash_profile","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"vundle","slug":"vundle","permalink":"http://korcow.github.io/tags/vundle/"},{"name":"solarized","slug":"solarized","permalink":"http://korcow.github.io/tags/solarized/"},{"name":"theme","slug":"theme","permalink":"http://korcow.github.io/tags/theme/"}]},{"title":"Vundle 설치","slug":"vim-vundle-설치","date":"2017-10-30T17:53:54.000Z","updated":"2017-11-03T11:59:43.736Z","comments":true,"path":"2017/10/31/vim-vundle-설치/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-vundle-설치/","excerpt":"","text":"프로그래밍을 위한 vim 세팅복사/붙여넣기 vi가 익숙하지 않을 경우 gedit을 이용해도 됩니다. 맥용 virtualbox 5.1.28에서 macos용이 게스트 확장이 안되고 있습니다. 클립보드 공유와 화면크기 자동조정, 마우스 통합등. 맥사용자는 불편하더라도 당분간 아래 방법을 써야 합니다. 아님 paralls, vmware를 이용하는 것도 무방합니다. centOS에서 브라우저 내용을 복사해서 터미널로 붙여 넣을 때는 Shift+Ctrl+v 또는 Alt + 마우스 왼쪽클릭 하면 팝업메뉴가 나옵니다. 붙여넣기 선택 또는 터미널 메뉴의 편집 &gt; 붙여넣기를 선택합니다. git 설치12345678# centos$sudo yum install git# ubuntu$sudo apt_get install git# macos$brew install git sudo 가붙은 명령은 관리자 비밀번호 입력해야 합니다. gvim설치(설치 되어 있다면 통과)12345678# centos$sudo yum install gvim# ubuntu$sudo apt_get install gvim# macos$brew install macvim gvim을 설치하는 이유는 클립보드로 복사, 붙여넣기를 해야 하기 때문입니다. vim에서 클립보드 내용을 붙여 넣으려면 “+P vim의 내용을 클립보드로 복사 하려면 “+Y 이 동작은 .vimrc 에 set clipboard=unnamed 를 추가해야 동작 됩니다. 이 후 한꺼번에 추가하도록 하겠습니다. 터미널에서 vi를 실행하면 gvim이 실행되도록 .bash_profile을 수정합니다. .bash_profile 수정12$cd ~$vi .bash_profile 1234\" 마지막에 줄에 아래문장을 붙여 넣습니다.alias vi=\"gvim -v\":wq 1$source .bash_profile .vim 디렉토리 생성 및 vundle clone123$mkdir -p .vim/bundle$git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim .vimrc 생성.vimrc 파일을 오픈합니다. 123$gvim:e ~/.vimrc .vimrc 파일이 열리면 아래 내용을 복사해서 붙여 넣습니다.vim에서 붙여넣기 할 때는 편집 메뉴에 있는 붙이기를 선택합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247\"=================================================\" Vundle\" https://github.com/gmarik/vundle\"=================================================set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'\" All of your Plugins must be added before the following linePlugin 'altercation/vim-colors-solarized' \" solarized 테마Plugin 'scrooloose/nerdtree' \" 파일/폴더관리Plugin 'terryma/vim-multiple-cursors' \" 멀티커서 Plugin 'kien/ctrlp.vim'\"============== SnipMate ===================== # 코드단축Plugin 'MarcWeber/vim-addon-mw-utils'Plugin 'tomtom/tlib_vim'Plugin 'garbas/vim-snipmate'Plugin 'honza/vim-snippets'\"=================================================Plugin 'davidhalter/jedi-vim' \"파이썬 idePlugin 'vim-airline/vim-airline' \"vim 꾸미기Plugin 'vim-airline/vim-airline-themes' \"vim 꾸미기 테마Plugin 'tpope/vim-surround' \"문자 감싸기Plugin 'suan/vim-instant-markdown' \" 마크다운 미리보기Plugin 'VisIncr' \" 자동증감01234Plugin 'klen/python-mode' \" ide\"============== 마크다운 ======================Plugin 'godlygeek/tabular' Plugin 'plasticboy/vim-markdown'Plugin 'mzlogin/vim-markdown-toc'\"=================================================\"Plugin 'joshdick/onedark.vim'\"Plugin 'vim-pandoc/vim-pandoc'\"Plugin 'vim-pandoc/vim-pandoc-syntax' \"Plugin 'junegunn/goyo.vim'\"=====================================\"Plugin 'dbext.vim' \" dbms관리\"=====================================\"call vundle#end()filetype plugin indent on\" To ignore plugin indent changes, instead use:\" filetype plugin on\"\" Brief help\" :PluginList - 설치된 플러그인 목록 보기\" :PluginInstall - 플러그인설치; append`!` 추가된 플러그인만 설치\" :PluginUpdate - 플러그인 업데이트\" :PluginSearch foo - 플러그인 검색; append`!` 로컬 캐시를 갱신 \" :PluginClean - 플러그인 삭제; append`!` 사용하지 않은 플러그인 삭제\" .vimrc에 플러그인을 추가했으면\":w 저장 \":source % \".vimrc 다시 로드\":PluginInstall \"플러그인 설치\" http://vimawesome.com \"플러그인 조회 사이트\" http://vimcast.org \"강좌\" see :h vundle \"도움말\"=============================================================\"\" When started as \"evim\", evim.vim will already have done these settings.if v:progname =~? \"evim\" finishendif\" This must be first, because it changes other options as a side effect.set nocompatible\" allow backspacing over everything in insert modeset backspace=indent,eol,startif has(\"vms\") set nobackup \" do not keep a backup file, use versions insteadelse set backup \" keep a backup fileendifset history=50 \" keep 50 lines of command line historyset ruler \" show the cursor position all the timeset showcmd \" display incomplete commandsset incsearch \" do incremental searching\" For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries\" let &amp;guioptions = substitute(&amp;guioptions, \"t\", \"\", \"g\")\" Don't use Ex mode, use Q for formattingmap Q gq\" CTRL-U in insert mode deletes a lot. Use CTRL-G u to first break undo,\" so that you can undo CTRL-U after inserting a line break.inoremap &lt;C-U&gt; &lt;C-G&gt;u&lt;C-U&gt;\" In many terminal emulators the mouse works just fine, thus enable it.if has('mouse') set mouse=aendif\" Switch syntax highlighting on, when the terminal has colors\" Also switch on highlighting the last used search pattern.if &amp;t_Co &gt; 2 || has(\"gui_running\") syntax on set hlsearchendif\" Only do this part when compiled with support for autocommands.if has(\"autocmd\") \" Enable file type detection. \" Use the default filetype settings, so that mail gets 'tw' set to 72, \" 'cindent' is on in C files, etc. \" Also load indent files, to automatically do language-dependent indenting. filetype plugin indent on \" Put these in an autocmd group, so that we can delete them easily. augroup vimrcEx au! \" For all text files set 'textwidth' to 78 characters. autocmd FileType text setlocal textwidth=78 \" When editing a file, always jump to the last known cursor position. \" Don't do it when the position is invalid or when inside an event handler \" (happens when dropping a file on gvim). \" Also don't do it when the mark is in the first line, that is the default \" position when opening a file. autocmd BufReadPost * \\ if line(\"'\\\"\") &gt; 1 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | \\ exe \"normal! g`\\\"\" | \\ endif augroup ENDelse set autoindent \" always set autoindenting onendif \" has(\"autocmd\")\" Convenient command to see the difference between the current buffer and the\" file it was loaded from, thus the changes you made.\" Only define it when not defined already.if !exists(\":DiffOrig\") command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis \\ | wincmd p | diffthisendifset nu \" 줄번호를 보여줌\" 탭설정 하기set ts=4 \" 탭의 4의 공백 폭을 \"set sts=4 \"탭을 눌렀을 때 스페이스(ascii-0x20) 4개가 삽입되도록 합니다.set sw=4 \"'&lt;'나 '&gt;'키로 줄 전체를 밀거나 당길 때 참조되는 폭입니다.\"set et \"set expandtab 탭을 공백으로 바꿈\"retab \"vim 사용중 탭이 공백으로 바뀌지 않은 경우 et를 다시 적용set bs+=indent,eol,start \"들여쓰기된 스페이스를 지울 때 백스페이스를 여러번 누르지 않도록 하기 위해 sts 설정값만큼 백스페이스가 적용됩니다.set listchars=tab:»\\ ,extends:›,precedes:‹,nbsp:·,trail:∙set showbreak=↪\\\"========== instant_markdown ======================\"마크다운 문서를 작성시 브라우저로 미리 보기\"let g:instant_markdown_slow = 1\"자동실행 방지 0let g:instant_markdown_autostart = 1 \"============ vim_markdown =========================\" 마크다운 편집옵션let g:vim_markdown_folding_disabled = 1let g:vim_markdown_toc_autofit = 1let g:vim_markdown_math = 1let g:vim_markdown_frontmatter = 1let g:vim_markdown_toml_frontmatter = 1let g:vim_markdown_json_frontmatter = 1\"====================================================\" 컴파일 , 키맵\" c언어,pytyon\" compile and Run\" java는 eclipse에서 컴파일\" :명령줄 실행\" &lt; 백스페이스\" % 파일명\" &lt;Enter&gt; 엔터입력&lt;CR&gt;과 동일au FileType c map &lt;F5&gt; :w&lt;Enter&gt;:!gcc % -o %&lt;.o&lt;Enter&gt;:!./%&lt;.o&lt;Enter&gt;au FileType python map &lt;F5&gt; :w&lt;Enter&gt;:!python %&lt;Enter&gt;au FileType rube map &lt;F5&gt; :w&lt;Enter&gt;:!rube %&lt;Enter&gt;\"외부에서 파일변경시 자동으로 읽어들임\"이클립스, xcode 사용시 set autoread&lt; \"gvim설치시, 클립보드사용set clipboard=unnamed\"=============== airline ===============\" 화이트 스페이스 체크 안함. let g:airline#extensions#whitespace#enabled = 0 \" 확장탭라인을 사용let g:airline#extensions#tabline#enabled = 1 \" vim-airline 버퍼 목록 켜기\"let g:airline#extensions#tabline#fnamemod = ':t' \" vim-airline 버퍼 목록 파일명만 출력\" let g:airline#extensions#tabline#buffer_nr_show = 1 \" buffer number를 보여준다let g:airline#extensions#tabline#buffer_nr_format = '%s:' \" buffer number format\"let g:airline_powerline_fonts = 1let g:airline_theme='solarized'let g:airline_solarized_bg='dark'set laststatus=2colorscheme solarizedlet g:solarized_termcolors=256\"=============== airline =================let mapleader=\",\" \" 리더키를 , 로 변경 주석처리하면 원상태nnoremap &lt;Leader&gt;ex !!$SHELL&lt;CR&gt; \",ex로 외부명령을 실행\"새탭으로 오픈\"nnoremap &lt;Leader&gt;rc :tabnew $MYVIMRC&lt;CR&gt; \" 오른쪽에 오픈\"nnoremap &lt;Leader&gt;rc :rightbelow vnew $MYVIMRC&lt;CR&gt;\",rc로 .vimrc파일 오픈nnoremap &lt;Leader&gt;rc :e $MYVIMRC&lt;CR&gt; nnoremap &lt;Leader&gt;n :NERDTreeToggle&lt;CR&gt;nnoremap &lt;C-F&gt; :NERDTreeFind&lt;CR&gt;\"================ 약어 (abbreviations) ======================\" snippet은 tab을 눌러야하고 약어는 자동으로 바뀜\" snippet은 자동완성, \"ab la Los Angeles(L.A) 이렇게 사용해야함.\"한글 약어는 안되는 단어도 있음, 한글 약어가 안될땐 snippet에 추가.ab 컨브 Ctrl+vab 컨씨 Ctrl+cab 컨엠 Ctrl+mab 이시 Ctrl+[ or \\&lt;Esc\\&gt;ab 노모 Normal modeab 커모 Command modeab 비모 Visual modeab 인모 Insert modeab 로렘 정당은 법률이 정하는 바에 의하여 국가의 보호를 받으며, 국가는 법률이 정하는 바에 의하여 정당운영에 필요한 자금을 보조할 수 있다. 대통령의 임기연장 또는 중임변경을 위한 헌법개정은 그 헌법개정 제안 당시의 대통령에 대하여는 효력이 없다. 위원은 탄핵 또는 금고 이상의 형의 선고에 의하지 아니하고는 파면되지 아니한다. 제3항의 승인을 얻지 못한 때에는 그 처분 또는 명령은 그때부터 효력을 상실한다. 이 경우 그 명령에 의하여 개정 또는 폐지되었던 법률은 그 명령이 승인을 얻지 못한 때부터 당연히 효력을 회복한다.ab 배요일 \"월\", \"화\", \"수\", \"목\", \"금\", \"토\", \"일\"ab 배코이름 \"유재석\", \"박명수\", \"강호동\", \"신동엽\", \"박미선\"ab 배색깔 \"빨강\", \"주황\", \"노랑\", \"초록\", \"파랑\", \"남\", \"보라\"ab 브이아이 VIab 빔 VIM 저장하고 .vimrc를 다시 읽어들입니다. 12:w:so % 오류가 많이 나는데 무시 해도 됩니다. 아직 플러그인 설치가 되지 않아서 발생하는 오류 입니다.플러그인을 설치합니다. 1:PluginInstall vim을 종료했다 다시 시작합니다.설치가 완료 되었습니다.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"bundle","slug":"bundle","permalink":"http://korcow.github.io/tags/bundle/"},{"name":"Vundle","slug":"Vundle","permalink":"http://korcow.github.io/tags/Vundle/"}]},{"title":"vim의 고급 사용법","slug":"vim-고급-사용법","date":"2017-10-30T17:51:37.000Z","updated":"2017-11-03T12:01:52.002Z","comments":true,"path":"2017/10/31/vim-고급-사용법/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-고급-사용법/","excerpt":"","text":"vim 고급 사용법고급사용법? 프로그래밍을 하다보면 어쩌다 한번씩 vim을 사용할 때가 있습니다. 서버의 환경변수를 수정할 때… 이럴때는 몇가지 기능만 쓸수 있으면 됩니다. 불편하지만 사용하는데 문제 되지 않습니다. 여기서 조금더 나아가 필수 명령을 숙지 한다면 vim을 다른 어떤 에디터 보다 편하고 빠르게 사용할 수 있습니다. vim을 메인 에디터로 사용하기 위해 기본으로 알아야 사항을 최소한으로 요약 했읍니다. 물론 전체 기능의 10%도 안되는 내용이지만 아래 내용만 알아도 vim을 사용하는데 큰 불편함을 느끼지 않을 겁니다. 또 알아서 필요한 기능을 찾을 수 있는 레벨까지 올라 갈 겁니다. vim은 모든 사람들이 사용하는 패턴이 틀립니다. 자신만의 사용 패턴을 빨리 찾는 것이 중요합니다. Modevim은 크게 4가지 모드로 동작되어 집니다. Normal Mode Insert Mode Visual Mode Commnd-Line Mode 이중에 가장 기본이 되는 모드는 Normal Mode(command mode)라고도 합니다.언제든 Ctrl+[ 키를 입력하면 Normal Mode가 됩니다.이곳에서 Insert mode , Visual mode, Command-Line mode 로 이동이 가능합니다. 반대로 각각의 모드에서 모드 전환을 하려면 반드시 Normal mode 로 이동해서 전환 해야 합니다. Normal mode 모드이동 명령 Normal Mode : , Ctrl+[ Insert Mode : i, I, a, A, o, O Visual Mode : v, V, Ctrl+v(windows는 Ctrl+q) Command-line Mode : : 커서이동 명령 h: motion.txt h, j, k, l : 좌우로 한칸, 위아래로 한줄씩 커서를 이동합니다. 명령앞에 숫자를 입력하면 숫자 만큼 명령을 수행 합니다. 예) 10l : 오른쪽으로 10칸 이동 예) 10h : 왼쪽으로 10칸 이동 단어단위로 이동 : w, W, b, B, e, gE 0, $, ^, [, {, (, ), }, ] : 현재줄의 처음과 끝, 문장의 처음과 끝, 문단의 처음과 끝으로 이동 H, M, L H : 화면 맨위로 M : 화면 중간으로 L : 화면 끝으로 gg, nG : 줄단위로 커서를 이동 시킵니다. gg는 문서 맨 위로 커서를 이동 시킵니다. nG는 숫자 위치로 커서를 이동 시킵니다. 찾아서 커서 이동하기 명령 f, F, t, T, /, ? : 특정 문자, 키워드를 찾아 이동합니다. f : 오른쪽으로 문자를 찾아 이동합니다. F는 왼쪽으로 찾아 이동합니다. t : 오른쪽으로 문자를 찾아 찾은 문자 왼쪽에 커서를 위치 시킵니다. T는 왼쪽에서 찾아 오른쪽에 커서를 위치시킵니다. / : /는 키워드를 현재 커서 아래로 모두 찾아 하이라이트 해줍니다. n, N으로 이동 할 수 있습니다. 키워드와 단어는 조금 다릅니다. 키워드는 단어와 공백을 포함합니다. ? : ?는 현재 커서 위로 키워드를 찾아 이동합니다. 삭제 명령 :h deleting x, X, d, dd, D x는 커서위의 문자를 지웁니다. 또는 범위 설정된 부분을 지웁니다. X는 커서위의 문자를 지우고 왼쪽문자에 붙입니다. d는 삭제 대기 명령입니다. 어떻게 삭제할 지를 대기 하고 있습니다. 이동명령과 조합 가능합니다. dw : 커서 위치에서 부터 한단어 삭제, 주의 have 란 단어의 a에 커서가 있을 경우 ave만 삭제 d5l : 커서를 기준으로 오른쪽으로 5칸 삭제. daw : 커서 위치의 단어를 삭제. nd : d앞에 반복 숫자를 사용할 수 있음. 3dw : 3단어 삭제 d$ : 커서 위치부터 줄 끝까지 삭제. d0 : 커서 위치부터 줄 처음까지 삭제. dG : 커서 위치부터 마지막 까지 삭제. dd : 현재줄 모두 삭제. D : 커서 위치부터 줄끝까지 삭제. 2D: 현재 커서 위치부터 2줄을 삭제. 현재줄 끝까지 삭제되고 추가로 2줄이 삭제됨. 바꾸기 명령 s, S, c, C s : 커서위 문자를 지우고 insert mode가 됩니다. S : 줄 전체를 지우고 insert mode 가 됩니다. c : 바꾸기 대기 명령, 이동키와 조합 가능 cw : 현재 커서위치 부터 한단어를 지우고 insert mode caw : 현재 커서위치의 단어를 지우고 insert mdoe ci’ : ‘’ 안의 문자열을 지우고 insert mode ca’ : ‘’ 포함해서 지우고 insert mode ci” : “” 안의 문자열을 지우고 insert mode ca” : “” 를 포함 문자열을 지우고 insert mode C : 현재 커서부터 줄 끝까지 지우고 insert mode 덮어쓰기 명령 r, R r : 현재 커서위의 1문자를 지우고 insert mode(1문자만), 이동 명령과 조합 가능. 10r : 현재 커서위치의 1문자를 지우고 입력대기(주의 최초r을 10번 반복). v2lr : 현재 커서 위치부터 2칸을 지우고 입력대기 ==========================================위와 같은 문자를 -로 바꾸려면커서를 처음 =에 위치시키고 v$r- R : 줄전체를 지우고 insert mode 복사 명령/붙이기 명령 y, yy, Y y : 복사 대기 명령, 이동키와 조합 가능 3yW : 현재 커서 위치부터 3단어를 복사. yy : 한줄을 복사. Y : 현재 커서 줄부터 한줄을 복사. 2Y : 현재 커서 줄부터 2줄을 복사. p : 현재 커서 뒤에 붙이기. 행을 복사한 경우 아랫줄에 붙여넣음. P : 현재 커저 앞에 붙이기. 행을 복사한 경우 윗줄에 붙여넣음.(주의)붙이기를 할때 복사 한것이 열을 복사한 것인지, 줄을 복사한 것인지에 따라 기준이 앞, 뒤, 윗줄, 아랫줄로 반영됩니다. 스크롤 명령 Ctrl+u, Ctrl+d, Ctrl+e, Ctrl+y, Ctrl+f, Ctrl+b Ctrl+u : 커서를 중앙에 두고 위로 한화면 스크롤 Ctrl+d : 커서를 중앙에 두고 아래로 한화면 스크롤 Ctrl+e : 한줄씩 위로 Ctrl+y : 한줄씩 아래로 Ctrl+f : 한화면 위로 커서는 화면 상단 Ctrl+b : 한화면 아래로 커서는 화면 하단 접고 펴기 명령 :h fold zf : 폴드 생성. 여러줄을 1줄로 압축 zip fold 해줍니다. zo : 폴드를 열어줍니다. zip open zc : 폴드를 닫아줍니다. zd : 현재 위치의 폴드를 삭제해줍니다. zR : 현재 문서의 모든 폴드 열기. zM : 현재 문서의 모든 폴드 닫기. zE : 현재 문서의 모든 폴드 삭제. zD : 현재 위치의 겹쳐진 폴드 삭제. Insert Mode i, I, a, A, o, O i : i명령은 커서 앞에 입력합니다. I : 줄 처음에 입력을 합니다. a : 커서 뒤에 입력을 합니다. A : 줄 끝에 입력을 합니다. o : 커서 아래에 새줄을 만들고 입력을 합니다. O : 커서 위에 새줄을 만들고 입력을 합니다. 문자를 지우려면 백스페이스 또는 Ctrl+h를 입력합니다. 단어를 지우려면 Ctrl + w 줄을 지우려면 Ctrl + u Insert mode에서 커서이동은 마우스를 사용하거나 Normal Mode에서 하는 것이 편합니다. 단어 단위로 이동하려면 Ctrl+좌우방향키 위 아래줄로 이동하려면 Ctrl+gk , Ctrl+gj Ctrl+n 커서 이전에 입력한 단어를 모두 보여주고 자동완성 시켜줍니다. Ctrl+p는 후보를 반대로 찾음 캘리포니아 란 단어를 입력 했었고, 다시 입력하려고 하면 캘 까지만 입력하고 Ctrl + n Visual Mode v, V, Ctrl + V(windows Ctrl+q) 비주얼 모드는 범위를 지정할 때 사용하는 mode 입니다. v : 라인을 기준으로 범위를 지정합니다. V : 줄단위로 범위를 지정합니다.(단위가 줄입니다.) Ctrl + v : 열을 기준으로 범위를 지정합니다. 이동키 또는 마우스로 범위를 지정할 수 있습니다. Command-line Mode 파일관리 w, e, E, pwd, cd w : 파일을 저장합니다. e : 파일을 오픈 합니다. 파일이 존재 하면 open, 없으면 새로 만듦. E : netrw를 실행 합니다. vim용 파일 관리 매니저 입니다. 종료는 :bd pwd : 현재 작업 디렉토리를 보여줍니다. cd : 작업 디렉토리를 이동합니다. 버퍼관리 ls, bn, bd, bp, b(숫자) ls : 버퍼 목록을 보여줍니다. bn : 다음 버퍼로 이동합니다. bp : 앞에 있는 버퍼로 이동합니다. b(숫자) : 숫자에 해당하는 버퍼로 이동합니다. 창관리 vs, sp, Ctrl+w vs : 창을 세로로 나누어 줍니다. sp : 창을 가로로 나누어 줍니다. Ctrl + w : 찾을 이동합니다. 누를 때마다 창이 전환됩니다. 외부명령 ! 외부명령을 실행 합니다.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim의 기본사용법","slug":"vim-기본사용법","date":"2017-10-30T17:43:28.000Z","updated":"2017-11-03T12:02:28.482Z","comments":true,"path":"2017/10/31/vim-기본사용법/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-기본사용법/","excerpt":"","text":"기본 사용법실행하기1$vi 콘솔에서 vi를 입력하면 vi가 실행됩니다. 처음 실행이 되면 기본으로 normal mode 되고 이곳에 명령을 입력하면 됩니다. 텍스트를 입력하기 위해 i명령을 입력하면 하단의 상태줄 좌측에 입력하기 라고 변경됩니다. 이제 키보드로 타이핑하는 것이 입력이 됩니다. 텍스트를 입력해 보세요. ^^ 삭제 : 백스페이스를 누르면 키보드 앞의 1문자가 삭제되어 집니다. Ctrl + h 도 동일합니다. 이동 : 커서키 또는 마우스를 이용해서 이동합니다. 복사 : 마우스로 복사할 영역을 드래그하고 Y를 누릅니다. 이때 자동으로 visual mode 가 됩니다. 선택이 끝나면 자동으로 normal mode 가 됩니다. 다시 입력하려면 i 명령을 입력하세요. 붙여넣기 : 붙여넣기 할 위치에 마우스나 방향키를 이용해 커서를 위치시키고 P를 누릅니다. 다시 입력하려면 i 명령을 입력하세요. 저장하기 : Ctrl + [ + : w abc.txt 저장하기 명령을 내리려면 Command-lind mode로 이동해야 합니다. &lt;Esc&gt; 또는 Ctrl + [ 를 누르고 : (콜론)을 입력하면 Command-line mode 로 이동됩니다. vim 하단에 : 이 표시 되면 w 저장할파일명 을 입력합니다. 파일명을 한글로 입력하지 마세요. 파일명에 띄어 쓰기를 하지 마세요. 파일명에 특수문자를 넣지 마세요. 컴퓨터를 사용하는 기본 규칙입니다. 파일명을 한글과 공백을 써야 한다면 “한글 파일명.md” 이렇게 써야 합니다. Ctrl + [ + : 사용을 추천합니다. 종료 : Ctrl+[ + : q 저장한 후 종료 해야 합니다. 저장하지 않고 종료하려면 Ctrl+[ + : q! 종료 명령도 normal mode에서 해야 합니다. 파일 수정하기1$vi abc.txt 실행시 수정할 파일명을 같이 입력합니다. 이후 사용법은 동일합니다. 입력을 하려면 i 명령을, 이동하려면 커서키나 마우스사용…","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim 실행과 종료","slug":"vim-실행과-종료","date":"2017-10-30T17:39:33.000Z","updated":"2017-11-03T15:33:39.306Z","comments":true,"path":"2017/10/31/vim-실행과-종료/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-실행과-종료/","excerpt":"","text":"vim의 실행과 종료실행하기1$vi 콘솔에서 vi를 입력하면 vi가 실행됩니다.처음 실행이 되면 기본으로 normal mode 되고 이곳에 명령을 입력하면 됩니다. 텍스트를 입력하기 위해 i명령을 입력하면 하단의 상태줄 좌측에 입력하기 라고 변경됩니다.이제 키보드로 타이핑하는 것이 입력이 됩니다.텍스트를 입력해 보세요. ^^ 시작과 종료하기1234567텍스트를 입력하세요.백스페이스는 누르면 글자가 지워집니다.마우스나 방향키나 마우스로 커서를 이동할 수 있습니다.\"Ctrl+[ or ``Esc key`` 입력하면 명령모드:w abc.txt \"abc.txt로 저장, 저장하지 않고 종료하려면 :q!:q \"종료 수정하기1$vi abc.txt 바로 전에 작성한 파일이 열립니다. 12345678910텍스트를 입력하세요.백스페이스는 누르면 글자가 지워집니다.마우스나 방향키나 마우스로 커서를 이동할 수 있습니다.텍스트를 추가하거나 수정해 보세요.종료 하는 방법은 똑같습니다.\"Ctrl+[ or ``Esc key`` 입력하면 명령모드:w abc.txt \"abc.txt로 저장, 저장하지 않고 종료하려면 :q!:q \"종료","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim설치","slug":"vim-설치","date":"2017-10-30T11:46:09.000Z","updated":"2017-11-03T15:19:47.430Z","comments":true,"path":"2017/10/30/vim-설치/","link":"","permalink":"http://korcow.github.io/2017/10/30/vim-설치/","excerpt":"","text":"vim 설치하기 대부분의 Unix계열은 기본으로 vim이 설치 되어 있습니다.vim은 별도로 설치 하지 않아도 됩니다.윈도우 계열은 vim.org에서 자신의 운영체제에 맞는 버젼을 다운받아 설치 하면 됩니다.Unix계열은 gui를 사용 한다면 편의상 gvim을 설치하는 것이 좋습니다. 그래야 클립보드를 사용할 수 있습니다. 설치 방법은 아래와 같습니다. 12345678#red hat 계열$ sudo yum install gvim # macos$ brew install macvim-dev/macvim/macvim# debian 계열$ suso apt-get install gvim .bash_profile 또는 .zshrc에 다음과 같이 alias를 추가 합니다. sh alias vi=gvim -v","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://korcow.github.io/tags/vim/"}]},{"title":"외부명령어","slug":"centos-외부명령어","date":"2017-10-29T10:47:23.000Z","updated":"2017-11-03T12:12:15.804Z","comments":true,"path":"2017/10/29/centos-외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-외부명령어/","excerpt":"","text":"외부명령어외부 명령어는 명령라기 보다는 프로그램이라고 생각하는 것이 편합니다.운영체제의 기본 기능을 프로그램으로 만들어서 실행 하는 겁니다. /bin 또는 /usr/bin에 들어 있습니다. 파일관리 : 파일의 목록을 확인하고, 복사하고, 지우고, 링크걸고, 찾고 하는 프로그램등이 있습니다. 보안관리 : 파일의 권한(읽기, 쓰기, 실행)을 바꾸거나 , 소유권을 바꾸는 프로그램이 있습니다. 프로세스관리: 내부명령에 기본으로 포함되어 있고, 외부 명령으로 기능이 확장되거나 관리가 용이 하도록 만든 프로그램들이 있습니다. 서버관리 : ssh, web, ftp, dns, db 등 많은 서버 프로그램이 있으며, 이들 서버를 관리하는 프로그램이 있습니다. 응용프로그램 : 업무를 도와 줄수 있는 워드, 엑셀, 데이타베이스, 그래픽, 사운드 관련 프로그램이 있습니다. 프로그램의 종류가 워낙 많고 사용법 또한 외우기 쉽지 않기 때문에 최대한 man page를 사용하는 것을 추천 합니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"내부명령어","slug":"centos-내부명령어","date":"2017-10-29T10:46:54.000Z","updated":"2017-11-03T20:43:02.472Z","comments":true,"path":"2017/10/29/centos-내부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-내부명령어/","excerpt":"","text":"내부명령어내부명령은 Shell에 들어있고 별도 파일로 존재 하지 않는다고 했습니다. 내부명령어는 프로그램 언어 이기 때문에 당연히 변수, 상수, 조건문, 반복문, 배열,등이 있겠죠. 그걸 내부 명령어라고 합니다. 컴퓨터는 명령을 내리면 결과를 돌려 줍니다. 받은 결과를 다른 명령령의 인자로 돌려 줄 수 있다는 것도 꼭 기억하시기 바랍니다. Terminal에서 1# enable 위와 같이 입력하면 현재 사용자가 쓸수 있는 내부 명령어를 보여 줍니다.권한과 옵션에 따라 더많이 보일 수도 있고 적게 보일 수도 있습니다. . . . : [ alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait false 맨 마지막에 위 명령어의 설명이 있습니다. bash script 명령은 파이프라인과 리다이렉션만 설명하고 bash script를 설명할 때 다루도록 하겠습니다. cd, pwd, bg, fg, fc, echo, exec, kill, umask, export, source, logout, times, type 이 정도가 많이 쓰입니다. 명령어 설명 cd 경로를 이동합니다. pwd 현재 위치한 경로를 알려줍니다. bg &amp;를 붙여 실행시 백그라운드로 보냅니다. 인수가 없으면 백그라운드로 실행되고 있는 프로그램을 포그라운드로 실행합니다. fg 백그라운드에서 실행되는 프로그램을 포그라운드로 가져옵니다. echo 문자를 출력합니다. exec 프로그램을 실행합니다. kill 실행되고 있는 프로세스를 종료합니다. umask 사용자가 생성하는 파일을 mode로 설정합니다. export 환경변수를 등록합니다. source bash script가 있는 파일을 실행합니다. logout 현재 사용자를 로그아웃 시킵니다. 파이프라인과 리다이렉션파이프라인| 파이프라인 : 파이프라인을 기준으로 좌측 명령의 결과를 우측의 명령에 인자로 전달합니다. 리다이렉션&gt; 리다이렉션 : 왼쪽 명령 출력 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일 또는 장치(장치도 파일)&lt; 리다이렉션 : 왼쪽 명령 입력 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일 또는 장치(장치도 파일)&gt;&gt; 리다이렉션 : 왼쪽 명령 출력 방향을 오른쪽 옵션으로 바꾸어 추가해 줍니다. 옵션은 파일 또는 장치&lt;&lt; 리다이렉션 : 왼쪽 명령 입력 방향을 오른쪽 옵션으로 바꾸어 추가해 줍니다. 옵션은 파일 또는 장치 처음엔 무슨 뜻인지 햇갈릴 겁니다. 프로그램은 순차적으로 실행됩니다. 왼쪽에서 오른쪽으로. 처음 실행되는 프로그램이 출력을 한다면 출력방향을 바꾸어 줍니다. 처음 실행되는 프로그램 입력을 대기한다면 입력방향을 바꾸어 줍니다. 기본 출력방향은 모니터 입니다. 기본 입력방향은 키보드 입니다.0&lt; 표준입력: /dev/stdin 생략가능1&gt; 표준출력: /dev/stdout 생략가능2&gt; 표준에러출력: /dev/stderr 에러를 출력하기 위해서는 필수. 12345678$echo \"hello\"$echo \"hello\" &gt; aaa.txt$cat aaa.txthello$cat &lt; /dev/stdinhello worldhello world^C echo는 문자 또는 문자열을 출력해주는 프로그램입니다.기본 방향이 모니터이기 때문에 모니터에 문자열을 출력해 주겠죠.출력 방향을 aaa.txt(파일)로 바꾸면 화면에는 아무것도 출력되지 않고 aaa.txt을 생성해서 파일안에 hello라고 써 넣습니다. cat이라는 프로그램은 파일을 출력해 주는 외부 명령어 입니다.사용법은 cat 파일명 하면 파일명을 화면으로 출력해 줍니다.입력을 파일로부터 받는다는 겁니다.위 예제는 cat의 입력방향을 표준입력인 키보드로 바꾸어 준겁니다.종료하려면 Ctrl + C 를 입력합니다. 옵션이 파일명이면 파일로 만들어 주거나 파일에 덧붙여 줍니다. xNIX는 장치도 파일입니다. 파이프라인과 리다이렉션은 무척 중요합니다. 지금은 가볍게 이해 정도만 해주세요. 이해가 안되도 넘어 가도 됩니다. 와일드카드 문자 설명 * 모든 문자 ? 문자하나 [characters] characters 문자 집합에 포함된 문자 [!characters] characters 문자 집합에 포함 되지 않은 문자 [[:class:]] 아래 클래스를 사용 [:alnum:] 알파벳과 숫자를 지정 [:alpha:] 알파벳 지정 [:digit:] 숫자를 지정 [:lower:] 소문자 [:upper:] 대문자 와일드 카드도 너무 중요한 명령입니다. 지금은 이런것이 있다는 것만 너무 중요한데 그냥 넘어 가는구나 생각만 하세요. ls 명령에서 다시 알아 보겠습니다. man page 도움말 보기123# man cd# man pwd# man bash man 명령을 이용해 도움말을 볼 수 있습니다.man 도움말에서 h-key를 누르면 사용법을 볼수 있습니다.q-key를 누르면 종료됩니다. 커서키를 이용해서 위, 아래로 이동하며 스크롤도 할 수 있고, 찾기도 할 수 있습니다. BASH BUILTIN 명령어 설명 : [인수들] 아무런 효과도 없다; 인수들을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다. 종료 상태값 0 을 반환한다. . 파일명 [인수들] | 현재의 디렉토리를 나타낸다. 인수로는 디렉토리와 파일명이 올수 있다. source 파일명 [인수들] 파일명 으로부터 명령을 읽어 현재 쉘 환경 안에서 실행한다. 파일명 에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다. 파일명 에 슬래쉬가 없으면 PATH 변수에 들어있는 경로명을 사용하여 파일명 을 검색한다. PATH 변수에서 찾는 파일이 실행 파일일 필요는 없다. PATH 에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다. 인수들을 적으면 파일을 실행할 때 위치 매개변수로 사용한다. 그렇지 않으면 위치 매개변수는 변하지 않는다. 스크립트 내에서 종료한 마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0) 파일명 을 찾을 수 없으면 거짓을 반환한다. alias [이름[=값] ...] 아무런 인수 없이 Alias를 실행하면 표준 출력에 이름=값의 형식으로 앨리어스 목록을 출력해준다. 인수를 제공하면 각각의 이름에 대하여 값을 앨리어스로 정의한다. 값 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도 앨리어스 확장이 가능한지 점검하도록 할 수 있다. 인수 목록에서 값을 주지 않은 이름에 대해서는 앨리어스의 이름과 값을 출력한다. 주어진 이름에 대한 앨리어스가 정의되어 있지 않은 경우가 아니라면 참값을 반환한다. bg [작업명세] &amp; 를 붙여 실행한 것처럼 작업명세가 가리키는 작업을 백그라운드로 보낸다. 작업명세가 없으면 현재 작업에 해당하는 작업이 사용된다. bg 작업명세 는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만 작업명세를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고 0 을 반환한다. bind [-m 키맵] [-lvd] [-q 이름] bind [-m 키맵] -f 파일명 bind [-m 키맵] 키시퀀스:함수이름 readline 의 현재 키, 함수 바인딩을 표시하거나 readline 함수나 매크로에 키 시퀀스를 결합한다. 바인딩 문법은 .inputrc 의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다; 예를 들어, ‘“\\C-x\\C-r”: re-read-init-file’. 옵션을 적는 경우에는 다음과 같은 의미를 가진다:- ``-m`` 키맵 뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로 키맵 을 사용한다. 가능하 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, 그리고 vi-insert 이 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다. - -l 모든 readline 함수의 이름을 나열한다. - -v 현재 함수 이름과 바인딩을 나열한다. - -d 다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다. - -f 파일명 filename으로부터 키 바인딩을 읽는다. - -q 함수 함수를 실행시키는 키에 대하여 알아본다. 알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다. break [n] for, while, until 루프 안에서 탈출한다. n을 명시하면 n 레벨을 탈출한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다. break 이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다. builtin 쉘-내부명령 [인수들] 명시한 쉘 내부 명령에 인수들 을 주어 실행하고 종료 상태값을 반환한다. 쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의 기능을 활용하고자 할 때 유용하다. 보통 cd 내부 명령을 이런 식으로 재정의하곤 한다. 쉘-내부명령 이 쉘 내부 명령이 아닐 때 거짓을 반환한다. cd [디렉토리] 현재 디렉토리를 디렉토리로 변경한다. HOME 변수 값이 기본 디렉토리 값이다. CDPATH 변수는 디렉토리 를 포함하는 디렉토리에 대한 검색 경로를 정의한다. 서로 다른 디렉토리는 콜론(:)으로 구분한다. CDPATH 에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 .와 같다. 디렉토리 가 슬래쉬(/)로 시작하면 CDPATH 는 사용되지 않는다. 전달인수로 - 를 사용하면 $OLDPWD 와 같다. 성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다. command [-pVv] 명령 [인수 ...] 보통의 쉘 함수 찾아보기를 하지 않고 명령 을 인수 와 함께 실행한다. 내부 명령 또는 PATH 에서 찾을 수 있는 명령만을 실행한다. are executed. If the -p 옵션을 주면 PATH 의 기본값을 사용하여 명령 에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다. -V 또는 -v 옵션을 주면 명령 에 대한 설명을 출력한다. -v 옵션은 명령 을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다; -V 옵션은 좀 더 자세한 설명을 출력한다. – 를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다. -V 또는 -v 옵션을 주었을 때 종료 상태값은 명령 이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나 명령 을 찾을 수 없으면 종료 상태값은 127 이 된다. 그렇지 않을 때 command 내부 명령의 종료 상태값은 명령 의 종료 상태값이다. continue [n] 둘러 싸고 있는 for, while, until 루프의 다음 순차 작업을 재개한다. n 을 명시하면, n 번째 루프를 재개한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(최상위 레벨 루프)를 재개한다. continue 명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은 0 이다. declare [-frxi] [이름[=값]] typeset [-frxi] [이름[=값]] 변수를 선언하거나 변수에 속성을 부여한다. 아무런 이름도 주어지지 않았을 때에는 변수의 값을 표시한다. 옵션을 사용하여 특정 속성의 변수에 대해서만 출력하도록 제한할 수 있다. -f | 함수 이름만 사용 -r | 이름을 읽기 전용으로 만든다. 그 뒤에는 지정문을 사용하여 값을 지정할 수 없다. -x | 이름을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다. -i | 변수를 정수처럼 취급한다; 변수에 값을 지정하면 산술 평가( 산 이 옵션을 끄려면 - 대신 +를 사용한다. 함수 안에서 사용하면 local 명령처럼 이름을 지역적으로 만든다. 잘못된 옵션을 만났다든지, &quot;-f foo=bar&quot;를 사용하여 함수를 정의하려고 시도했다든지, 이름이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용 상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를 표시하려 한 경우가 아니라면 반환값은 0 이다. dirs [-l] [+/-n] 현재까지 기억하고 있는 디렉토리 목록을 표시한다. 디렉토리를 목록에 추가할 때에는 pushd 명령을 사용한다; popd 명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다. 옵션 | 설명 —|— +n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 왼쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 오른쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -l | 긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼 때 틸드를 사용한다. 틀린 옵션을 주거나 n 이 디렉토리 스택 범위를 넘어서는 경우가 아니라면 반환값은 0 이 된다. echo [-neE] [인수 ...] 스페이스로 구분되어 있는 인수들을 출력한다. 반환값은 항상 0 이다. -n을 명시하면 마지막의 개행문자를 출력하지 않는다. -e 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다. -E 옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도 이스케이프 문자를 해석하지 않도록 지시한다. escape 문자| 설명—|—\\a |경 고 (벨)\\b |백스페이스\\c |마지막 개행문자를 생략함\\f |폼 피드\\n |개행문자\\r |캐리지 리턴\\t |수평 탭\\v |수직 탭\\\\ |백슬래쉬\\nnn |ASCII 코드가 nnn (8진수)인 문자 enable [-n] [|-all] [이름 ...] 쉘 내부 명령을 켜거나 끈다. 이 기능을 사용하면 쉘 내부 명령과 같은 이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수 있다. -n을 사용하면 각 이름의 사용을 끈다; 그렇지 않으면 이름의 사용을 켠다. 예를 들어, 쉘 내부 명령 버전 대신 PATH 에서 찾을 수 있는 test 바이너리를 사용하려면 enable -n test 라고 실행한다. 인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다. -n만 주면 사용 불능 상태의 내부 명령 목록을 출력한다. -all만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여 출력해준다. enable 명령은 -all 대신 -a 도 받아들인다. 이름 이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다. eval [인수 ...] 모든 인수를 읽어 하나의 명령으로 결합한다. 그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을 eval 명령의 반환값으로 돌려준다. 인수가 하나도 없거나 널 인수이면 eval 은 참을 반환한다. exec [[-] 명령 [인수]] 명령 을 명시하면 그 명령으로 쉘 프로세스를 교체한다. 새로운 프로세스는 만들어지지 않는다. 인수 는 명령의 인수가 된다. 첫번째 인수가 - 이면 쉘은 명령 에 전달하는 0 번째 인수에 대쉬를 넣는다. 이 과정은 로그인이 하는 일과 같다. 어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수 no_exit_on_failed_exec가 존재하여 거짓을 반환하는 경우를 제외하고 비대화형 쉘은 종료한다. 파일을 실행할 수 없을 때 대화형 쉘은 거짓을 반환한다. 명령 을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은 0 이 된다. exit [n] 상태값 n을 가지고 쉘을 종료한다. n 을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다. 쉘을 종료하기 전에 EXIT 에 대한 트랩(trap) 루틴이 실행된다. export [-nf] [이름[=단어]] ... export -p 나열한 이름 을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다. -f 옵션을 주면 이름 은 함수를 가리킨다. 아무런 이름 도 적지 않거나 또는 -p 옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다. -n 옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다. – 인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다. 잘못된 옵션을 만나거나 이름이 적법한 쉘 변수 이름이 아니거나 또는 함수가 아닌 이 상태값 0 을 반환한다. fc [-e 편집기이름] [-nlr] [처음] [마지막] fc -s [패턴=치환텍스트] [명령] 명령을 수정한다. 첫번째 형식에서, 명령의 범위는 처음 부터 마지막 범위에 있는 명령을 히스토리 목록에서 선택한다. 처음 과 마지막 은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자 (히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터 떨어진 만큼을 뜻한다)로 명시할 수 있다. 마지막 을 명시하지 않으면 현재 명령으로 설정되고(따라서 fc -l -10 은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면 처음 까지 출력한다. If 처음 을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해 -16 을 설정한다.-n 플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다.-r 플래그는 명령의 표시 순서를 반대로 한다.-l 플래그가 있으면 명령을 표준 출력에 나열한다. 그렇지 않을 때에는 편집기이름 이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다. 편집기이름 이 없으면 FCEDIT 변수의 값을 사용하며 FCEDIT 가 설정되어 있지 않을 때에는 EDITOR 값을 사용한다. 둘 다 설정되어 있지 않으면 를 사용한다. 편집을 마친 후에는 편집한 명령들이 화면에 표시되고 실행된다.두번째 형태에서, 명령은 패턴이 치환텍스트로 교체된 후에 다시 실행된다. 유용한 앨리어스로는 r=fc -s가 있다. 앨리어스 적용 후 r cc 라고 치면 cc로 시작하는 최근 명령을 실행하고 r이라고 치면 마지막 명령을 다시 실행하게 된다.첫번째 형태를 사용하면 잘못된 옵션이 있거나 처음 또는 마지막 이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다. -e 옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서 오류가 발생하는 경우 실패 값을 가진다. 두번째 형태를 사용하면 명령 이 유효한 히스토리 행을 가리키지 못하여 fc 가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로 사용한다. fg [작업스펙] 작업스펙 이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다. 작업스펙 이 존재하지 않으면 쉘에서 현재 작업이라고 부르는 것을 사용한다. 반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서 실행된 경우에는 실패이다. 그리고 작업 제어 가능한 상태에서도 작업스펙 이 유효한 작업을 가리키지 않거나 작업스펙 이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다. getopts 옵션문자열 이름 [인수] getopts 는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다. 옵션문자열 은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에 화이트스페이스로 분리된 인수가 온다는 뜻이다. 매번 실행될 때마다, getopts 는 다음 옵션을 쉘 변수 이름 에 넣는다. 이름 이 존재하지 않을 때에는 초기화한다. 그리고 처리할 다음 인수의 인덱스는 OPTIND 변수에 넣는다. OPTIND 는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다. 옵션에서 인수를 필요로 할 때에는 getopts 에서 그 인수를 OPTARG 변수에 넣는다. 쉘이 자동으로 OPTIND 변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을 사용하려면 getopts 를 부를 때마다 수동으로 재설정해 주어야 한다.getopts 는 두 가지 방식으로 오류를 보고할 수 있다. 옵션문자열 의 첫번째 문자가 콜론이면 조용한 오류 보고가 사용된다. 정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의 경우 증상을 설명하는 메시지가 출력된다. OPTERR 변수를 0 으로 설정하면 옵션문자열 의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다.잘못된 옵션을 만나면, getopts 는 이름 에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우, 오류 메시지를 출력하고 OPTARG 를 unset 한다. getopts 이 조용한 모드에 있는 경우 찾아낸 옵션 문자를 OPTARG 에 넣고 증상 설명 메시지를 출력하지 않는다.필요한 인수를 찾을 수 없으며 getopts 가 조용한 모드에 있지 않을 때에는 물음표를 (?) 이름 에 넣고 OPTARG 를 unset 하며 증상 설명 메시지를 출력한다. getopts 가 조용한 모드에 있으면 콜론을 (:) 이름 에 넣고 OPTARG 을 찾아낸 옵션 문자로 설정한다.getopts 는 보통 위치 매개변수를 파싱하지만 인수 부분에 더 많은 인수를 주면 getopts 는 대신 그 인수를 파싱한다. getopts 는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다. 옵션의 끝이거나 에러가 발생하면 거짓을 반환한다. hash [-r] [이름] 각 이름 에 대하여, 그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다. -r 옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다. 아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다. – 라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다. 이름 이 없거나 잘못된 옵션이 주어진 경우가 아닌 경우에는 참을 반환한다. help [패턴] 내부명령에 대한 도움말을 출력한다. 패턴 을 적으면, help 는 패턴과 일치하는 모든 명령에 대하여 자세한 도움말을 준다; 패턴을 적지 않으면 모든 내부명령 목록을 출력한다. 패턴과 일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다. history [n] history -rwan [filename] 옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. * 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다 ;없으면 HISTFILE 변수의 값을 사용한다. 옵션이 있는 경우 다음과 같은 뜻을 갖는다: -a 히스토리 파일에 새로운 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다. -n 히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다. -r 히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다. -w 현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다. jobs [-lnp] [ 작업스펙 ... ] jobs -x 명령 [ 인수 ... ] 첫번째 형태는 활동 중인 작업을 나열한다. -l 옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다; -p 옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다. -n 옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다. 작업스펙 을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다. 잘못된 옵션을 적거나 잘못된 작업스펙 을 적은 경우가 아니라면 반환값은 0 이다. -x 옵션을 붙이면, jobs 명령은 명령 또는 인수 안 에서 작업스펙 을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고 명령 에 인수 를 주어 실행하고 그 종료 상태값을 반환한다. kill [-s 시 kill -l [시그널번호] pid 또는 작업스펙이 가리키는 프로세스에게 시그널스펙 이 가리키는 시그널을 보낸다. 시그널스펙 은 SIGKILL 과 같은 시그널 이름 또는 시그널 번호이다. 시그널스펙 이 시그널 이름인 경우, 대소문자는 구별하지 않으며 SIG 라는 접두어를 써도 되고 쓰지 않아도 된다. 시그널스펙 이 없으면, SIGTERM 이라고 가정한다. -l 인수를 적으면 시그널 이름을 나열해 준다. -l 이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고 반환값은 0 이다. – 인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다. kill 최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다. 오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다. let 인수 [인수 ...] 각각의 인수 는 계산한 수치 표현식이다.( 산 마지막 인수 를 평가하여 그 결과가 0 이면, let 은 1 을 반환한다; 나머지 경우에는 0 을 반환한다. local [이름[=값] ...] 각 인수에 대하여 이름 이라는 지역 변수를 만들고 값 을 할당한다. local 을 함수 안에서 사용하면, 이름 변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다. 피연산자가 없으면, local 은 지역변수 목록을 표준 출력으로 출력한다. local 를 함수 안에서 사용하지 않는 것은 오류이다. local 을 함수 외부에서 사용했거나 잘못된 이름 을 적은 경우가 아니라면 반환 상태값은 0 이다. logout 로그인 쉘을 마친다. popd [+/-n] 디렉토리 스택에서 항목을 제거한다. 인수가 없으면 스택의 최상위 디렉토리를 제거하고 그 새로운 상위 디렉토리로 cd 한다. +n dirs 명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, popd +0는 첫번째 디렉토리를, popd +1는 두번째 디렉토리를 제거한다. -n dirs 명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, popd -0는 맨 마지막 디렉토리를, popd -1는 맨 마지막 바로 전 디렉토리를 제거한다. popd 명령이 성공적이면, dirs 명령도 실행하며 반환 상태값은 0 이다. popd 는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다. pushd [디렉토리] pushd +/-n 디렉토리를 디렉토리 스택의 맨 위에 추가하거나, 스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다. 인수가 없으면, 최상위 두 디렉토리를 교환한다. 디렉토리 스택이 비어 있지 않으면 0을 반환한다. +n n번째 디렉토리( dirs 명령이 보여주는 목록의 맨 왼쪽부터 센다) 이 맨 위에 놓이도록 스택을 회전시킨다. ) -n n번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록 스택을 회전시킨다. 디렉토리를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다. pushd 명령이 성공적이면, dirs 명령도 수행한다. 첫번째 형식을 사용하면, pushd 는 디렉토리 로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다. 두번째 형식을 사용하면, pushd 는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면 0을 반환한다. pwd 현재 디레토리의 절대 경로명을 출력한다. set 내부명령의 -P 옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다. ( 쉘 현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은 0이다. read [-r] [이름 ...] 표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 첫번째 이름 에 할당하고 두번째 단어를 두번째 이름 에 할당하고 나머지 남은 단어들을 마지막 이름 에 할당한다. IFS 에 있는 단어만을 단어 구분자로 인식한다. 아무런 이름 도 적지 않으면 읽어들인 행을 REPLY 변수에 할당한다. 파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다. -r 옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로 인식한다. readonly [-f] [이름 ...] readonly -p 주어진 이름들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해 이름들의 값이 바뀌지 않도록 해 준다. -f 옵션을 더하면, 이름에 해당하는 함수를 읽기 전용으로 표기한다. 아무런 인수도 없거나 -p 옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다. – 인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다. 잘못된 옵션이 있거나 이름들 중 하나라도 적접한 쉘 변수 이름이 아닌 경우 또는 -f 다음에 나온 이름 이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다. return [n] 함수를 상태 반환값 n 을 갖고 종료하도록 한다. n 을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다. 함수 밖에서 사용했지만 . (source) 명령으로 실행한 스크립트에서 사용하면, 쉘은 그 스크립트 실행을 멈추고 n 또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로 반환한다. 함수 밖에서 사용했으며 .[uB85C] 실행한 스크립트가 아니라면 반환 상태값은 거짓이 된다. set [--abefhkmnptuvxldCHP] [-o 옵션] [인수 ...] -a 뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로 표기한다. -b 종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이 아니라 즉시 보여 주도록 한다. ( 쉘 섹션에서 notify 참고) -e 간단한-명령 ( 쉘 종료하면 즉시 종료한다. 만약 실패한 명령이 until 또는 while 루프의 일부, if 문의 일부, &amp;&amp; 의 일부, or ⎪⎪ 목록의 일부이거나 또는 명령의 반환값이 ! 으로 반전되면 종료하지 않는다. -f 경로명 확장을 하지 않는다. -h 함수를 정의할 때 함수 명령을 찾아 기억해 둔다. 함수를 실행할 때 함수 명령을 정상적으로 찾아 본다. -k 명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에 둔다. -m 모니터(감시) 모드. 작업 제어를 사용한다. 지원하는 시스템에서 실행하는 대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다. ( 작 별도의 프로세스 그룹 안에서 실행되며 실행을 완료하면 종료 상태값을 포함하는 행을 출력한다. -n 명령을 읽지만 실행하지는 않는다. 쉘 스크립트 문법 오류를 점검할 때 사용할 수 있다. 대화형 쉘에서는 무시한다. -o 옵션-이름 옵션-이름은 다음 중 한 가지이다: allexport -a 와 같다. braceexpand 쉘이 중괄호 확장을 행한다. ( 앞서 나온 중 확 emacs 이맥스 스타일의 명령행 편집 인터페이스를 사용한다. 쉘을 시작할 때 -nolineediting 옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다. errexit -e와 같다. histexpand -H와 같다. ignoreeof 마치 쉘 명령 IGNOREEOF=10을 실행한 것과 같은 효과를 발휘한다. (앞서 나온 쉘 interactive-comments 어떤 단어를 # 로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다. (앞서 나온 주 monitor -m와 같다. noclobber -C와 같다. noexec -n와 같다. noglob -f와 같다. nohash -d와 같다. notify -b와 같다. nounset -u와 같다. physical -P와 같다. posix POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을 따르도록 만든다. privileged -p와 같다. verbose -v와 같다. vi vi 스타일의 명령행 편집 인터페이스를 사용한다. xtrace -x와 같다. 옵션-이름을 적지 않으면 현재 옵션값을 출력한다. -p privileged 모드를 켠다. 이 모드에서는 $ENV 파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다. 유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때 자동으로 작동한다. 이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자, 그룹 ID로 설정한다. -t 명령 하나를 읽어 실행한 후 종료한다. -u 매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다. 미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고 대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다. -v 쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다. -x 각각의 간단한-명령 을 확장한 후, bash PS4, 의 확장값을 표시하고 명령과 확장된 인수를 표시한다. -l for 이름 [in 단 복원한다. (앞서 나온 쉘 -d 실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다. 보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할 필요 없다. -C 쉘 명령 noclobber=을 실행한 것과 같은 효력을 발휘한다. (앞서 나온 쉘 -H ! 스타일의 히스토리 치환을 사용한다. 쉘이 대화형 모드이면 기본으로 켜지는 플래그이다. -P 설정하면, 현재 디렉토리를 변경하는 cd 와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다. 대신 물리적인 디렉토리를 사용한다. – 이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다. 만약 나오면, - 로 시작하는 것이 있다 할 지라도 위치 매개변수를 인수로 설정한다. - 옵션의 끝을 나타내며, 그 뒤에 나오는 모든 인수들을 위치 매개변수로 설정한다. -x 와 -v 옵션이 꺼진다. 만약 아무런 인수도 없다면, 위치 매개변수는 그대로이다. 다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다. - 대신 + 를 사용하면 플래그를 끈다. 쉘을 실행할 때 옵션으로 적을 수 있다. 현재 플래그 상태는 $- 를 보면 알 수 있다. 옵션 인수를 처리한 후, 나머지 n 개의 인수는 위 매개변수의 값으로 간주하고 차례대로 $1, $2, ... $n 에 할당한다. 아무런 옵션도 없고 인수도 없으면 모든 쉘 변수를 출력한다. 잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다. shift [n] n+1 부터의 위치 매개변수 이름을 $1 .... 로 변경한다. $#부터 $#-n+1까지의 매개변수는 unset된다. n 이 0 이면, 매개변수의 변화는 없다. n 이 주어지지 않으면 1 로 간주한다. n 은 $#보다 작거나 같은 음수 아닌 숫자여야 한다. n 이 $#보다 크면, 위치 매개변수의 변화는 없다. n 이 $# 보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다; 그렇지 않으면 0 이다. suspend [-f] SIGCONT 시그널을 받을 때까지 쉘의 실행을 정지시킨다. -f 옵션은 로그인 쉘이라 할 지라도 불평 메시지를 출력하지 않도록 한다; 어찌 되었든 일시 정지한다. 쉘이 로그인 쉘이면서도 -f 이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은 0 이 된다. test 표현식[ 표현식 ] 조건 표현식을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다. 표현식은 일항 또는 이항 표현식일 수 있다. 일항 표현식은 주로 파일의 상태를 점검할 때 사용한다. 문자열 연산자와 수치 비교 연산자도 있다. 각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다. 파일이 /dev/fd/n의 형태일 때에는, 파일 기술자 n를 점검한다. -b 파일: 파일이 존재하고 블럭 특수 파일이면 참. -c 파일: 파일이 존재하고 문자 특수 파일이면 참. -d 파일: 파일이 존재하고 디렉토리이면 참. -e 파일: 파일이 존재하면 참. -f 파일: 파일이 존재하고 일반 파일이면 참. -g 파일: 파일이 존재하고 set-group-id이면 참. -k 파일: 파일에 스틱키(sticky)비트가 설정되어 있으면 참. -L f파일: 파일이 존재하고 심볼릭 링크이면 참. -p 파일: 파일이 존재하고 명명된(named) 파이프이면 참. -r 파일: 파일이 존재하고 읽을 수 있으면 참. -s 파일: 파일이 존재하고 그 크기가 0 보다 크면 참. -S 파일: 파일이 존재하고 소켓이면 참. -t fd fd (파일 기술자)가 열린 상태이고 터미널이면 참. -u 파일: 파일이 존재하고 set-user-id 비트가 설정되어 있으면 참. -w 파일: 파일이 존재하고 쓸 수 있으면 참. -x 파일: 파일이 존재하고 실행 가능하면 참. -O 파일: 파일이 존재하고 유효(effective) 사용자 ID의 소유이면 참. -G 파일: 파일이 존재하고 유효 그룹 ID의 소유이면 참. 파일1 -nt 파일2: 파일1이 (수정 일시에 의거하여) 파일2보다 새로운 파일이면 참. 파일1 -ot 파일2: 파일1이 파일2보다 오래 된 파일이면 참. 파일1 -ef 파일2: 파일1과 파일2가 같은 장치이며 아이노드 번호가 같으면 참. -z 문자열: 문자열의 길이가 0이면 참. -n 문자열: 문자열 문자열 의 길이가 0이 아니면 참. 문자열1 = 문자열2: 두 문자열이 같으면 참. 문자열1 != 문자열2: 두 문자열이 같지 않으면 참. ! 표현식: 표현식 이 거짓이면 참. 표현식1 -a 표현식2: 표현식1 과 표현식2 둘 다 참이면 참. 표현식1 -o 표현식2: 표현식1 또는 표현식2 둘 중 하나가 참이면 참. 인수1 연산자: 위와 같은 수치 이항 연산자는 각각 인수1이 인수2와 같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다. 인수1 과 인수2 는 양의 정수, 음의 정수 또는 -l 문자열과 같이 문자열 의 길이로 평가되는 특별한 표현식이 될 수 있다. times 쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간, 시스템 영역에서의 소모 시간을 출력한다. 반환값은 0 이다. trap [-l] [인수] [시그널스펙] 쉘이 시그널스펙 이 가리키고 있는 시그널을 받으면 인수로 주어진 명령을 읽어 실행하도록 한다. 인수 가 없거나 - 이면, 제시한 모든 시그널에 대하여 원래의 값으로 돌아간다. (즉 쉘을 시작했을 때의 값) 인수가 널 문자열이면 쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다. 시그널스펙은 에 정의되어 있으면 시그널 이름이거나, 시그널 번호이다. 시그널스펙 이 EXIT (0) 이면 인수로 주어진 명령을 쉘 종료시에 실행한다. 아무런 인수도 없으면, trap 은 각 시그널 번호와 연관된 명령 목록을 출력한다. -l 옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. 쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다. 가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다. 가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 trap 은 참을 반환한다. type [-all] [-type | -path] 이름 [이름 ...] 옵션없이 사용하면, 이름 이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다. -type 플래그를 사용하면, type 은 이름 이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때, alias, keyword, function, builtin, 그리고 file 중 하나를 출력한다. 이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다. -path 플래그를 사용하면, type 은 이름 이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나, -type 이 file 을 반환하지 않을 때에는 아무 것도 반환하지 않는다. 명령이 해쉬된 상태이면, -path 는 PATH 상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다. -all 플래그를 사용하면, type 은 이름 이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다. -path 플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다. -all 을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다. type 은 -all, -type, 과 -path 대신 각각 -a, -t, 과 -p 를 받아들인다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. type 은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을 반환한다. ulimit [-SHacdfmstpnuv [제한]] Ulimit 은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여 사용 자원을 제한할 수 있도록 해 준다. 제한 값은 각 자원에 대한 단위 값이거나 unlimited 라는 값을 가질 수 있다. H와 S 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다. 하드 제한은 일단 설정되면 더 이상 늘릴 수 없다; 한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다. H 와 S 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고 간주한다. 제한을 생략하면 H 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다. 여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다. 기타 다른 옵션은 다음과 같이 해석한다: -d 프로세스의 데이터 세그먼트의 최대 크기 -f 쉘이 만들 수 있는 파일의 최대 크기 -m 상주 설정(resident size) 최대 크기 -s 최대 스택 크기 -t 초 단위의 최대 CPU 시간 -p 512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음) -n 열 수 있는 파일 기술자의 최대 크기 (대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.) -u 단일 사용자에게 허용하는 프로세스 최대 갯수 -v 쉘에 허용하는 가상 메모리의 최대량 – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다. 제한 이 주어지면, 명시한 자원에 대한 새로운 값이 된다.( -a 옵션은 표시할 때만 사용한다.) 아무런 옵션도 없으면 -f 로 간주한다. 값은 초 단위의 -t, 512 바이트의 블럭 단위인 -p, 그리고 단위가 없는 -n 과 -u 를 제외하고, 1024 바이트 단위로 생각한다. 잘못된 옵션이 있거나, 제한 값에 unlimited 이외의 수치 아닌 인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고 반환 상태값은 0 이다. umask [-S] [모드] 사용자 파일 생성 매스크를 모드로 설정한다. 모드가 숫자로 시작하면 8 진수로 해석한다. 그렇지 않으면 chmod(1) 와 비슷한 심볼릭 매스크로 해석한다. 모드 를 생략하거나, -S 옵션을 적으면, 현재의 매스크 값을 출력한다. -S 옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다; 기본 출력 형태는 8 진수이다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. 모드를 성공적으로 변경하거나 아무런 모드 값도 적지 않으면 반환 상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다. unalias [-a] [이름 ...] 정의된 앨리어스 목록에서 이름을 제거한다. -a 를 적으면 모든 앨리어스 정의를 제거한다. 적은 이름 이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다. unset [-fv] [이름 ...] 각각의 이름 에 대하여, 해당하는 변수를 제거하거나, -f 옵션의 경우 함수를 제거한다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. PATH, IFS, PPID, PS1, PS2, UID, 그리고 EUID 는 unset할 수 없다. RANDOM, SECONDS, LINENO, 또는 HISTCMD 중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을 잃게 된다. 이름 이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다. wait [n] 특정 프로세스를 기다리다가 종료값을 반환한다. n 은 프로세스 ID이거나 작업 스펙이다; 작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다. n 을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다. n 이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다. 그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이 된다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"cd","slug":"cd","permalink":"http://korcow.github.io/tags/cd/"},{"name":"pwd","slug":"pwd","permalink":"http://korcow.github.io/tags/pwd/"},{"name":"bg","slug":"bg","permalink":"http://korcow.github.io/tags/bg/"},{"name":"fg","slug":"fg","permalink":"http://korcow.github.io/tags/fg/"},{"name":"fc","slug":"fc","permalink":"http://korcow.github.io/tags/fc/"},{"name":"echo","slug":"echo","permalink":"http://korcow.github.io/tags/echo/"},{"name":"exec","slug":"exec","permalink":"http://korcow.github.io/tags/exec/"},{"name":"kill","slug":"kill","permalink":"http://korcow.github.io/tags/kill/"},{"name":"umask","slug":"umask","permalink":"http://korcow.github.io/tags/umask/"},{"name":"export","slug":"export","permalink":"http://korcow.github.io/tags/export/"},{"name":"source","slug":"source","permalink":"http://korcow.github.io/tags/source/"},{"name":"logout","slug":"logout","permalink":"http://korcow.github.io/tags/logout/"},{"name":"리다이렉션","slug":"리다이렉션","permalink":"http://korcow.github.io/tags/리다이렉션/"},{"name":"파이프라인","slug":"파이프라인","permalink":"http://korcow.github.io/tags/파이프라인/"}]},{"title":"내부명령어와 외부명령어","slug":"centos-내부명령어와-외부명령어","date":"2017-10-29T10:46:40.000Z","updated":"2017-11-03T20:29:56.258Z","comments":true,"path":"2017/10/29/centos-내부명령어와-외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-내부명령어와-외부명령어/","excerpt":"","text":"내부명령어와 외부명령어리눅스의 명령은 내부명령과 외부명령으로 나뉘어 집니다. 내부명령은 기본적으로 별도의 파일이 존재 하지 않습니다.Shell이라고 하는 인터프리터(명령해석기)에 명령이 들어 있습니다./bin, /usr/bin에 내부 명령어가 있다면 내부명령어의 기능이 확장된 프로그램입니다. 리눅스의 터미널을 실행하면 커서가 깜빡거립니다. 명령입력 대기를 하고있는 겁니다.사용자가 명령을 내리면 Shell이 해석해서 Kernel에 전달하고kernel은 cpu에 전달하고 cpu는 명령을 처리해서결과를 최종적으로 terminal(모니터, 키보드)에 돌려줍니다. 파일 및 디렉토리 관리명령 입출력명령 각종 제어명령 프로세스관리 명령 JOB관리 명령 내부명령은 컴퓨터를 운영할 수 있는 최소한의 명령입니다.크게 위와 같이 분류 할 수 있습니다. 외부명령은 OS가 갖추어야할 기본 프로그램 입니다. /bin 과 /usr/bin에 들어 있는 파일들이 외부명령 프로그램들입니다. 내부명령의 기능이 확장되거나 컴퓨터를 관리하기 쉽게 만든 프로그램입니다. 파일 및 디렉토리 관리 명령 프로세스 관리 명령 JOB 관리 명령 보안 및 권한관리 명령 각종 service 관리 명령 크게 위와 같이 분류 할 수 있습니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"},{"name":"내부명령어","slug":"내부명령어","permalink":"http://korcow.github.io/tags/내부명령어/"}]},{"title":"디렉토리","slug":"centos-디렉토리","date":"2017-10-29T10:45:14.000Z","updated":"2017-11-03T12:09:59.414Z","comments":true,"path":"2017/10/29/centos-디렉토리/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-디렉토리/","excerpt":"","text":"/최상위 디렉토리(root directory). /bin리눅스의 외부명령 파일들이 있습니다. /boot리눅스 부팅에 관련된 파일들이 있습니다. /dev디바이스 파일들이 있습니다. /etc리눅스의 설정 파일들이 있습니다. /home일반 계정 사용자들의 홈 디렉토리가 있습니다. /lib라이브러리 파일들이 담겨 있습니다. /mnt다른 장치들을 마운트하는 디렉토리 /proc프로세스 정보를 담고 있는 파일들이 담겨 있습니다. /rootroot의 홈 디렉토리. /sbinroot가 시스템 운영을 위해 필요한 실행 파일이 있습니다. /tmp임시 디렉토리 /usr사용자들을 위한 대부분의 프로그램들과 설정 파일들이 있습니다. /var각종 로그 파일 등의 시스템 관리와 관련된 정보들이 저장되는 디렉토리. /runFHS 관련 데몬과 파일시스템 관련 파일들이 있습니다. 리눅스가 사용하는 디렉토리.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"directory","slug":"directory","permalink":"http://korcow.github.io/tags/directory/"},{"name":"디렉토리","slug":"디렉토리","permalink":"http://korcow.github.io/tags/디렉토리/"}]},{"title":"부팅 순서","slug":"centos-부팅-순서","date":"2017-10-29T10:44:38.000Z","updated":"2017-11-03T12:09:08.565Z","comments":true,"path":"2017/10/29/centos-부팅-순서/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-부팅-순서/","excerpt":"","text":"부팅순서 1. 전원on컴퓨터에 전원이 공급되면 제일 먼저 ROM BIOS의 프로그램들이 자동으로 실행됩니다. 2. BIOS 실행BIOS가 실행되면, 컴퓨터가 구동되기 위한 최소한의 장치가 있는지, 이상은 없는지를 테스트하고, 이상이 있다면 Beep음으로 알려줍니다. 이상이 없다면 BIOS에 저장된 부팅장치로 부팅을 시작합니다. 3. 부팅장치 선택부팅장치(CD-ROM, HDD…)로 부터 부트섹터를 읽어 메모리에 적재합니다. 이때 GRUB가 적재되는 겁니다. 4. 부트로더 실행GRUB가 실행되면 부트 메뉴를 보여주고 부팅할 커널을 선택합니다. 5. 커널 이미지 적재선택된 커널 이미지를 MEMORY에 적재합니다. 6. 파일시스템 마운트루트 파일시스템을 적재 합니다. 7. init 프로세스 실행시스템을 초기화 하고 사용자가 시스템을 사용할 수 있도록 해줍니다.이때 설정된 각종 DEAMON도 같이 실행 되어집니다. DAEMON : 종료되지 않고 계속 실행되는 프로그램 8. 로그인 및 사용리눅스시스템은 부팅이 완료되면 각종 설정및 SERVER등이 자동으로 실행 되어 스스로 설정된 명령에 의해 동작됩니다. 시스템에 허가된 사용자는 로그인을 이용해 컴퓨터에접속해서 컴퓨터 사용이 가능합니다. 앞으로 위 [그림1]에서 NORTH BRIDGE 와 SOUTH BRIDGE, BIOS를 생략하고 아래 [그림2]로 시스템 설명을 설명할 겁니다. 메모리와 CPU사이에는 NB, SB가 있다는것을 잊으면 안됩니다. 입력장치: RAM, HDD(각종저장장치), 마이크, 키보드, 마우스, 스케너출력장치: RAM, HDD(각종저장장치), 모니터, 스피커, 프린터처리장치: CPU","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"리눅스의 특징","slug":"centos-리눅스의-특징","date":"2017-10-29T07:29:52.000Z","updated":"2017-11-03T12:08:03.554Z","comments":true,"path":"2017/10/29/centos-리눅스의-특징/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-리눅스의-특징/","excerpt":"","text":"리눅스의 특징과 역할특징 멀티유저, 멀티태스킹, 멀티 프로세싱, 서버용 운영체제 GUI 와 CUI 를 지원 무료이며, 수많은 소스가 공개 되어 있다. 안정성, 적은 리소스 점유로 mobile, embeded에서도 사용 운영체제 역할리눅스는 많은 OS(Operating System) 운영체제중의 하나입니다. 위에 보는 그림과 같이 컴퓨터는 많은 장치로 구성되어 있습니다. 운영체제는 각각의 장치를 유기적으로 연결해서 컴퓨터를 사용할 수 있도록 해줍니다. SB는 각종 입출력 장치를 제어하고, NB는 PCI BUS 와 SB를 제어 합니다. OS가 없으면 컴퓨터는 동작 하지 않습니다. 기능 파일(디렉토리)관리 파일생성, 이동, 삭제, 복사 프로세스관리 프로그램의 실행및 종료, background, forground 메모리관리 프로그램의 메모리 적제, 사용, 삭제 스케줄관리(job management) 프로그램의 실행및 종료를 언제 할지 관리 보안관리 파일의 소유, 생성, 실행, 읽고쓰기 등…","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"터미널 단축키","slug":"centos-터미널-단축키","date":"2017-10-29T03:58:17.000Z","updated":"2017-11-03T12:06:38.306Z","comments":true,"path":"2017/10/29/centos-터미널-단축키/","link":"","permalink":"http://korcow.github.io/2017/10/29/centos-터미널-단축키/","excerpt":"","text":"터미널 단축키xNIX 계열의 터미널에서 공통적으로 사용되는 단축키 입니다.터미널과 shell에 따라 조금씩 다르고, 더많은 단축키가 있지만 아래 키는 대부분 공통적으로 동작 됩니다. 단축키 설명 TAB 자동완성(파일및디렉토리, 명령을 자동완성) Ctrl+h 백스페이와 같습니다.(더 편합니다.) Ctrl+a 처음으로 이동 Ctrl+e 행 끝으로 이동 Ctrl+b 한 문자 뒤로 이동 Alt+b 한 단어 뒤로 이동 Ctrl+f 한 문자 앞으로 이동 Alt+f 한 단어 앞으로 이동 Ctrl+u 현재줄을 삭제합니다. Ctrl+k 커서 위치에서 행 끝까지 삭제합니다. Ctrl+w 커서앞 한단어를 삭제합니다. Esc+Backspace 이전 단어 삭제 Ctrl+y 클립보드에서 텍스트를 붙여넣습니다. Ctrl+l 화면 상단에 현재 줄을 남겨두고 화면을 지웁니다. Ctrl+r 증분 검색 기록 을 역순으로 추적 Alt+p 비 증분 검색 기록을 역순으로 추적 Ctrl+p 비 증분 검색 기록을 역순으로 추적 터미널 단축키는 man page, sed, edlin, vim, python, perl, rube 에서도 동일하게 사용됩니다. TAB, Ctrl+l, Ctrl+u, Ctrl+w, Ctrl+e, Ctrl+a, Ctrl+p, Ctrl+r위 키는 반드시 손에 익히세요.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://korcow.github.io/tags/centos/"},{"name":"terminal","slug":"terminal","permalink":"http://korcow.github.io/tags/terminal/"}]},{"title":"Centos설치","slug":"centos-설치","date":"2017-10-28T04:54:29.000Z","updated":"2017-11-03T18:54:04.227Z","comments":true,"path":"2017/10/28/centos-설치/","link":"","permalink":"http://korcow.github.io/2017/10/28/centos-설치/","excerpt":"","text":"Centos설치실습의 편의를 위해 VirtualBox에 Centos를 설치하겠습니다. 1. virtualbox 다운로드http://virtualbox.org 사이트에서 자신의 운영체제에 맞는 최신 버전의 virtualbox를 다운로드 받습니다. 2. Centos 다운로드http://centos.org 에서 centos7 dvd iso 이미지를 다운로드 받습니다. 3. virtualbox 설치virtualbox를 설치합니다. 4. virtualbox 실행 및 centos설치virtualbox를 실행하고 centos를 설치합니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://korcow.github.io/tags/centos/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://korcow.github.io/tags/virtualbox/"},{"name":"리눅스설치","slug":"리눅스설치","permalink":"http://korcow.github.io/tags/리눅스설치/"}]}]}