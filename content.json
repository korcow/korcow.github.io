{"meta":{"title":"KORCOW","subtitle":"HANS","description":"테스트","author":"woo-seok Han","url":"http://korcow.github.io"},"pages":[],"posts":[{"title":"외부명령어 요약","slug":"외부명령어-요약","date":"2017-11-01T17:55:45.000Z","updated":"2017-11-02T03:22:57.503Z","comments":true,"path":"2017/11/02/외부명령어-요약/","link":"","permalink":"http://korcow.github.io/2017/11/02/외부명령어-요약/","excerpt":"","text":"외부 명령어파일 관리 명령어 ls | 파일의 리스트를 보여줌. ls -a 모든파일을 보여줌 touch | 파일의 생성일자를 변경. 파일이 없다면 새로운 파일을 만듦. touch abc.txt | 파일이 없을경우 새로운 파일을 생성 touch -t 200010100909 abc.txt | 입력한 시간으로 수정 touch -c abc.txt | 현재 시간으로 수정 cat | 파일의 내용을 보여줌. cat abc.txt abc.txt 파일의 내용을 출력 which | 명령어의 위치를 알려줌.(명령어가 어느것인지 $PATH에서만 찾음) whereis | 명령어의 위치를 알려줌.(명령어가 어디에 있는지 /bin;/etc;/man 에서찾음) file | 파일의 정보를 알려줌. cp | 파일을 복사. rm | 파일을 지움. mv | 파일을 이동시킴. more | 파일의 내용을 보여줌. grep | 단어(키워드)를 찾아줌. find | 파일을 찾아줌. ln | 링크를 만들어줌. mkdir | 디렉토리를 만들어줌. rmdir | 디렉토리를 삭제해줌. wc | 파일의 통계(라인수, 단어수, 문자수)를 보여줌. tail | head | less | 권한 소유 관리 id | whoami | finger | chmod | chown | sudo | passwd | useradd | w | who | 프로세스관리 top- 기본 응용 cal | 달력을 보여줌. time | date |","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"}]},{"title":"히스토리","slug":"히스토리","date":"2017-11-01T15:44:28.000Z","updated":"2017-11-01T16:38:36.295Z","comments":true,"path":"2017/11/02/히스토리/","link":"","permalink":"http://korcow.github.io/2017/11/02/히스토리/","excerpt":"","text":"히스토리리눅스는 명령을 수행하면 모든 명령을 history log에 담아 둡니다. history 명령히스토리를 보여줍니다. Ctrl + p 이전 명령을 프롬프트에 나타내 줍니다. !! 이전 명령을 다시 실행해 줍니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"history","slug":"history","permalink":"http://korcow.github.io/tags/history/"}]},{"title":"경로이동하기","slug":"경로이동하기","date":"2017-11-01T14:55:27.000Z","updated":"2017-11-01T15:48:39.304Z","comments":true,"path":"2017/11/01/경로이동하기/","link":"","permalink":"http://korcow.github.io/2017/11/01/경로이동하기/","excerpt":"","text":"경로이동하기 pwd 현재의 경로를 확인합니다. . 현재의 경로를 의미합니다. ./abc 현재경로에 있는 abc파일을 실행합니다. .. 상위경로를 의미합니다. cd .. 부모경로로 이동합니다. cd 디렉토리명으로 경로를 이동할 수 있습니다. cd temp 디렉토리 이름을 쓸때 Tab키를 누르면 자동완성 바로전 경로로 이동하려면 cd - 홈디렉토리로 이동하려면 cd ~ 현재의 경로를 저장하려면 pushd . 절대경로로 지정 pushd /etc/apache2/conf 저장된 경로로 이동하려면 popd 경로에는 상대 경로와 절대 경로가 있습니다.상대경로현재 위치의 경로를 기준 ##절대경로/를 기준 pushd popd","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"cd","slug":"cd","permalink":"http://korcow.github.io/tags/cd/"},{"name":"pushd","slug":"pushd","permalink":"http://korcow.github.io/tags/pushd/"},{"name":"popd","slug":"popd","permalink":"http://korcow.github.io/tags/popd/"}]},{"title":"복사하기","slug":"복사하기","date":"2017-11-01T05:42:06.000Z","updated":"2017-11-01T15:29:10.051Z","comments":true,"path":"2017/11/01/복사하기/","link":"","permalink":"http://korcow.github.io/2017/11/01/복사하기/","excerpt":"","text":"cp(복사하기)리눅스에서 파일을 복사하는 명령입니다.파일 하나만 복사할 수도 있도 여러개를 복사할 수도 있습니다.물론 디렉토리도 복사할 수 있습니다. 파일하나 복사 cp abc.txt anydir abc.txt 파일을 현재위치의 anydir/abc.txt 로 복사 cp abc.txt anydir/cde.txt 이름을 바꾸어 저장할 수도 있습니다. 여러개의 파일을 복사 cp abc.txt bcd.txt anydir 여러개의 파일을 직접 지정해서 복사 할 수 있습니다. cp * anydir 모든 파일을 anydir로 복사합니다. 와일드 카드 사용법을 참고하세요. cp *.txt anydir 모든 .txt로 끝나는 파일을 anydir로 복사합니다. cp *[[:alpha:]a][].txt anydir 모든 .txt로 끝나는 파일을 anydir로 복사합니다. cp $(ls *.txt) anydir 12$ ls *.txt$ cp !! anydir 디렉토리를 복사 cp -R sodir anydir 현재 경로의 sodir디렉토리및 하위 디렉토리 까지 anydir로 복사합니다. 파일과 디렉토리리눅스에서는 엄밀히 디렉토리라는 것이 없습니다 편의상 그렇게 부르는것 뿐입니다. 장치나 디렉토리나 모두 파일로 간주 합니다. 다만 파일의 특성이 있는 겁니다. 리눅스에서 디렉토리라고 부르는 파일의 특성은 자식파일을 갖을 수 있습니다. 자신의 권한과 소유권을 자식에게 승계 합니다. 자식 파일을 갖는 파일은 생성시 mkdir명령으로 생성합니다. ls의 -l 옵션으로 특성을 확인 할 수 있습니다. ls는 파일의 리스트를 확인 하는 프로그램입니다. 앞으로 편의상 디렉토리로 부를 겁니다. ^^; 123456789$ ``ls -l``합계 24drwxr-xr-x. 2 root root 20 11월 1 15:17 anyfolder-rw-r--r--. 1 root root 6072 11월 1 14:48 cp.doc-rw-rw-r--. 1 korcow korcow 13439 10월 28 09:33 ls.doc$ touch aaa$ mkdir aaamkdir: `aaa` 디렉토리를 만들 수 없습니다: 파일이 있습니다 cp 명령을 사용하다 에러가 나면 man page를 확인하세요. 대부분 권한, 소유권, 하위에 디렉토리 여부, 소프트링크 관련 에러 입니다.복사가 힘들다고 불평하지 마세요. 보안의 강화 때문입니다. 소중한 자료를 아무나 허락 없이 가져가면 안되죠… cp 한글 man page123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123CP(1) General Commands Manual CP(1)NAME cp - 파일 복사SYNOPSIS cp [options] source dest cp [options] source... directory Options: [-abdfilprsuvxPR] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;] [--backup] [--no-dereference] [--force] [--interactive] [--one-file- system] [--preserve] [--recursive] [--update] [--verbose] [--suf‐ fix=backup-suffix] [--version-control=&#123;numbered,existing,simple&#125;] [--archive] [--parents] [--link] [--symbolic-link] [--help] [--version]DESCRIPTION 이 문서는 더이상 최신 정보를 담고 있지않다. 그래서, 몇몇 틀릴 경우도 있고, 부족한 경우도 있을 것이다. 완전한 매뉴얼을 원하면, Texinfo 문서를 참조하기 바란다. 이 매뉴얼 페이지는 cp 명령의 GNU 버전에 대한 것이다. 마지막 명령행 인자로 경로가 지정되면, cp 명령은 지정한 source 파일들을 그 경로로 안으로 복사한다. 한편 명령행 인자로 두개의 파일 이름이 사용되면, 첫번째 파일을 두번째 파일로 복사한다. 마지막 명령행 인자가 경로가 아니고, 두개 이상의 파일이 지정되면, 오류 메시지를 보여준다. 초기값으로 경로는 복사하지 않는다. OPTIONS -a, --archive 원본 파일의 속성, 링크 정보들을 그대로 유지하면서 복사한다. 이 옵션은 -dpR 옵션과 같은 역활을 한다. -b, --backup 복사할 대상이 이미 있어, 이것을 덮어쓰거나 지울경우에 대비해 백업본을 만든다. -d, --no-dereference 만약 복사할 원본이 심블릭 파일이면, cp 명령은 그 심블릭 대상이 되는 파일을 복사한다. 이렇게 하지 않고, 단지 그 심블릭 파일 자체를 심블릭 정보와 함께 복사하고 할 때, 이 옵션을 사용한다. -f, --force 만약 복사 대상 파일이 이미 있으면 강제로 지우고 복사한다. -i, --interactive 만약 복사 대상 파일 이미 있으면 사용자에게 어떻게 처리 할 것인지 물어보는 프롬프트를 나타나게 한다. -l, --link 하드링크 형식으로 복사한다. 물론 하드 링크형식이기에 경로는 복사할 수 없다. -P, --parents 원본 파일에 지정을 경로와 같이 했을 경우, 그 경로 그대로 복사 된다. 이때는 대상으로 사용될 수 있는 것은 경로 이름이어야만 한다. 예를 들어, ``cp --parents a/b/c existing_dir`` 명령이 사용된다면, 이것의 결과는 existing_dir/a/b/c 이런 식이 된다. -p, --preserve 원본 파일의 소유주, 그룹, 권한, 시간정보들이 그대로 보존되어 복사된다. -r 일반 파일이면, 그냥 복사되고, 만약 원본이 경로면, 그 경로와 함께 경로 안에 있는 모든 하위경로, 파일들이 복사된다. -s, --symbolic-link 경로가 아닌 일반 파일을 심블릭 링크 형식으로 복사한다. 이때는 복사할 원본 파일 이름은 절대경로(``/``로 시작하는 경로)로 지정된 파일이름이어야 한다. 심블릭 링크를 지원하지 않는 시스템에서 이옵션을 사용할 경우에는 오류 메시지를 보여준다. -u, --update 복사할 대상이 이미 있는데, 이 파일의 변경 날짜가 같거나, 더 최근의 것이면 복사하지 않는다. -v, --verbose 각 파일의 복사 상태를 자세히 보여준다. -x, --one-file-system 원복과 대상 파일의 파일 시스템이 다를 경우에는 복사하지 않는다. -R, --recursive 경로를 복사할 경우에는 그 안에 포함된 모든 하위경로와 파일들을 모두 복사한다. --help 도움말을 보여주고 마친다. --version 버전 정보를 보여주고 마친다. -S, --suffix backup-suffix 만약에 복사 대상이 이미 있어, 백업을 해야할 경우에 그 백업 파일에서 사용할 파일 이름의 꼬리 문자를 지정한다. 이것은 이미 지정되어 있는 SIMPLE_BACKUP_SUFFIX 환경 변수를 무시하게 된다. 만약 이 환경변수도 지정되어 있지 않고, 이 옵션도 사용하지 않는다면, 초기값으로 Emacs과 같이 ``~`` 문자를 사용한다. -V, --version-control &#123;numbered,existing,simple&#125; 백업하는 방법을 지정하는데, 이 옵션은 이미 지정되어 있는 VER‐ SION_CONTROL 환경 변수를 무시한다. 만약 이 환경 변수도 지정되어 있지 않고, 이 옵션도 사용하지 않는다면, 초기값으로 ``existing``을 사용한다. 여기서 사용하는 백업방법은 GNU Emacs의 ``version-con‐ trol`` 값과 같다. 아래와 같이 보다 짧은 지시어들도 사용될 수 있다. 여기서 사용될 수 있는 백업 방법은 아래와 같다. ``t`` 또는 ``numbered`` 항상 번호 있는 백업본을 만든다. ``nil`` or ``existing`` 대상 파일이 이미 있을 경우에만 백업본을 만든다. ``never`` or ``simple`` 간단한 백업을 만듬.FSF GNU File Utilities CP(1)---","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"cp","slug":"cp","permalink":"http://korcow.github.io/tags/cp/"}]},{"title":"CtrlP 플러그인","slug":"CtrlP-플러그인","date":"2017-10-31T13:22:20.000Z","updated":"2017-11-01T05:10:00.906Z","comments":true,"path":"2017/10/31/CtrlP-플러그인/","link":"","permalink":"http://korcow.github.io/2017/10/31/CtrlP-플러그인/","excerpt":"","text":"기본사용법 Ctrl+p를 누르면 하단에 파일검색 모드가 열립니다. Ctrl+f를 누르면 모드가 바뀝니다. 현재열린 버퍼 &gt; 파일 &gt; 전체 Ctrl+j, Ctrl+k 아래, 위로 이동(파일선택) Command-line에서는 아래와 같이 Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode. Run :CtrlPBuffer or :CtrlPMRU to invoke CtrlP in find buffer or find MRU file mode. Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time. Check :help ctrlp-commands and :help ctrlp-extensions for other commands.Once CtrlP is open: Press &lt;F5&gt; to purge the cache for the current directory to get new files, remove deleted files and apply new ignore options. Press &lt;c-f&gt; and &lt;c-b&gt; to cycle between modes. Press &lt;c-d&gt; to switch to filename only search instead of full path. Press &lt;c-r&gt; to switch to regexp mode. Use &lt;c-j&gt;, &lt;c-k&gt; or the arrow keys to navigate the result list. Use &lt;c-t&gt; or &lt;c-v&gt;, &lt;c-x&gt; to open the selected entry in a new tab or in a new split. Use &lt;c-n&gt;, &lt;c-p&gt; to select the next/previous string in the prompt’s history. Use &lt;c-y&gt; to create a new file and its parent directories. Use &lt;c-z&gt; to mark/unmark multiple files and &lt;c-o&gt; to open them. Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help. Submit two or more dots .. to go up the directory tree by one or multiple levels. End the input string with a colon : followed by a command to execute it on the opening file(s): Use :25 to jump to line 25. Use :diffthis when opening multiple files to run :diffthis on the first 4 files.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"vundle","slug":"vundle","permalink":"http://korcow.github.io/tags/vundle/"},{"name":"ctrlp","slug":"ctrlp","permalink":"http://korcow.github.io/tags/ctrlp/"}]},{"title":"shell이란","slug":"shell이란","date":"2017-10-31T07:02:59.000Z","updated":"2017-11-01T05:10:46.129Z","comments":true,"path":"2017/10/31/shell이란/","link":"","permalink":"http://korcow.github.io/2017/10/31/shell이란/","excerpt":"","text":"리눅스 시스템이 부팅이 완료되고 로그인을 하면 커서가 깜빡이며 명령 수행을 대기합니다. 이것을 shell prompt 라고합니다.shell은 interpreter 입니다. 명령을 해석하고 올바른 명령이라면 kernel로 명령을 전달하고 처리 합니다. shell이 interpreter라고 했습니다. 컴파일러는 명령을 모두 해석해서 한번에 처리합니다.인터프리터는 명령을 한줄씩 해석해서 처리 합니다. 둘다 컴퓨터 언어 이기 때문에 변수, 상수, 자료형, 연산자, 예약어, 조건문, 반복문, 함수, 배열등이 존재 합니다. shell의 내부명령어는 예약어 입니다. cd, pwd, type, bg, fg 등… 언어 이기 때문에 계산도 가능합니다. 123$echo $((1+1))2$ 사칙연산과 우선순위도 있습니다.프로그래밍도 가능합니다.bash script programming 부분에서 프로그래밍을 다루고 지금은 shell은 인터프리터라는 것만 기억 하시면 됩니다. 컴퓨터를 켜면 커서가 깜빡이는데 우리가 입력하는 것은 프로그램 명령이구나 이정도만 기억 하시면 됩니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://korcow.github.io/tags/shell/"}]},{"title":"와일드카드","slug":"와일드카드","date":"2017-10-31T06:29:20.000Z","updated":"2017-11-01T07:30:42.651Z","comments":true,"path":"2017/10/31/와일드카드/","link":"","permalink":"http://korcow.github.io/2017/10/31/와일드카드/","excerpt":"","text":"와일드카드 문자 설명 * 모든 문자 0개 이상 ? 문자하나 반드시 1문자 [characters] characters 문자 집합에 포함된 1문자 [!characters] characters 문자 집합에 포함 되지 않은 1문자 [[:class:]] 알파벳과 숫자를 지정 [:alnum:] 알파벳과 숫자를 지정 [:alpha:] 알파벳 지정 [:digit:] 숫자를 지정 [:lower:] 모든 소문자 [:upper:] 모든 대문자 ls 명령을 사용해 와일드 카드를 사용해 보겠습니다.ls명령과 와일드카드 명령 2개를 같이 사용하는 겁니다. 테스트용 디렉토리와 파일 만들기1234$cd ~$mkdir myTest$cd test$touch a&#123;a..d&#125;&#123;a..c&#125;&#123;1..3&#125;.txt ls a*a로 시작하는 모든 파일을 보여줍니다. ls a*.txta로 시작하고 .txt로 끝나는 모든 파일을 보여줍니다. ls ?b?.txt첫문자는 아무 문자나 와도 되고 두번째는 b 세번째는 아무문자 마지막에 .txt로 끝나는 파일을 보여줍니다. ls *.txt.txt로 끝나는 모든 파일을 보여줍니다. ls *[[:digit:]1].txt1.txt앞에 숫자 1만 있으면 그앞에 어떤 문자가 와도 모두 보여줍니다. ls *[abc]*파일명 중간이 abc로 된 파일을 모두 보여줍니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"와일드카드","slug":"와일드카드","permalink":"http://korcow.github.io/tags/와일드카드/"}]},{"title":"ls","slug":"ls","date":"2017-10-31T04:27:36.000Z","updated":"2017-11-01T17:19:20.101Z","comments":true,"path":"2017/10/31/ls/","link":"","permalink":"http://korcow.github.io/2017/10/31/ls/","excerpt":"","text":"외부명령어ls디렉토리의 파일 목록을 보는 명령입니다. 파일의 목록을 볼때 어떻게 확인할지 옵션을 주어 파일을 볼수 있습니다. ls –help 또는 man ls로 설명을 볼 수 있습니다. 내부명령의 파이프라인과 리다이렉션을 이용해 목록의 출력 방향을 조정 하거나 리스트 결과를 다른 프로그램의 인자로 전달 할 수 있습니다. ls: 디렉토리의 파일 리스트를 출력합니다. ls a*: a로 시작하는 모든 파일을 보여 달라는 명령입니다. ls a???: a로 시작하고 문자의 길이가 총4개인 파일만 보여 달라는 명령입니다. ls -a: 숨김 파일도 보여 줍니다. ls -ld .?* 숨김 파일만 보여줍니다. ls -l: 리스트의 형태로 목록을 보여 줍니다. ls -al: 옵션을 조합해서 사용할 수 있습니다. 리스트의 형태로 숨김파일까지 보여 달라는 명령입니다. ls 명령은 find, grep, more, sed, vim 등 외부 명령과 조합 해서 사용할 수 있어야 합니다. 단순히 파일 목록만 확인 하는 것이 아니라 파일을 찾은후 파일에 문자열을 추가, 삭제, 실행 등의 작업을 할 수 있습니다. 이부분은 해당 명령에서 다루도록 하겠습니다. 리눅의 명령은 유닉스, macos의 명령과 100% 같지 않습니다. 기본적인 기능은 거의 같지만 옵션이 틀릴수 있으니 동작이 안된다면 해당 OS의 man page를 참고해야 합니다. 참고로 아래는 centos의 한글 man page 입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291LS(1) General Commands Manual LS(1)NAME ls, dir, vdir - 경로의 내용을 나열한다.SYNOPSIS ls [-abcdfgiklmnpqrstuxABCFGLNQRSUX1] [-w cols] [-T cols] [-I pattern] [--all] [--escape] [--directory] [--inode] [--kilobytes] [--numeric-uid-gid] [--no-group] [--hide-control-chars] [--reverse] [--size] [--width=cols] [--tabsize=cols] [--almost-all] [--ignore-backups] [--classify] [--file-type] [--full- time] [--ignore=pattern] [--dereference] [--literal] [--quote-name] [--recursive] [--sort=&#123;none,time,size,extension&#125;] [--format=&#123;long,ver‐ bose,commas,across,vertical,single-column&#125;] [--time=&#123;atime,access,use,ctime,status&#125;] [--help] [--version] [--color[=&#123;yes,no,tty&#125;]] [--colour[=&#123;yes,no,tty&#125;]] [name...]DESCRIPTION 이 문서는 더이상 최신 정보를 담고 있지않다. 그래서, 몇몇 틀릴 경우도 있고, 부족한 경우도 있을 것이다. 완전한 매뉴얼을 원하면, Texinfo 문서를 참조하기 바란다. 이 매뉴얼 페이지는 ls 명령의 GNU 버전에 대한 것이다. dir과 vdir 명령은 ls 명령의 심블릭 파일로 그 출력 양식을 다르게 보여주는 풀그림들이다. 인자로 파일이름이나, 경로 이름이 사용된다. 경로의 내용은 초기값으로 알파벳 순으로 나열된다. ls의 경우는 출력이 표준 출력(터미날 화면)이면, 세로로 정열된 것이 가로로 나열된다. 다른 방식의 출력이면 한줄에 하나씩 나열된다. dir의 경우는, 초기값으로 ls와 같으나, 모든 출력에서 세로로 정열해서 가로로 나열한다.(다른 방식의 출력에서도 항상 같음) vdir의 경우는, 초기값으로 목록을 자세히 나열한다. OPTIONS -a, --all 경로안의 모든 파일을 나열한다. ``.``으로 시작하는 파일 들도 포함된다. -b, --escape 알파벳 형식을 사용하는 파일 이름안에서 그래픽 문자가 아닌 문자들을 사용한다. C와 같이 여덟가지 역슬래쉬 문자(`\\&apos;)와 함께 오는 문자들을 사용한다. -c, --time=ctime, --time=status 파일 최근 변경 시간에 따라 정열 해서 보여준다. 자세한 나열(-l 옵션)이면, 그 파일의 최근 변경 시간을 보여준다. -d, --directory 경로안의 내용을 나열하지 않고, 그 경로를 보여준다.(이것은 쉘 스크립트에서 유용하게 쓰인다.) -f 경로 내용을 정열하지 않는다: 이것은 디스크에 저장된 순으로 보여준다. -a와 -U 옵션과 같은 뜻이며, -l, -s, -t. 옵션과 반대뜻이다. --full-time 시간을 간략히 표시하지 않고, 모두 보여 준다. -g 무시: 유닉스 호환을 위해서 있음. -i, --inode 파일 왼쪽에 색인 번호를 보여준다. -k, --kilobytes 파일 크기가 나열되면, kb 단위로 보여준다. 이 옵션은 POSIXLY_CORRECT 환경 변수를 무시한다. -l, --format=long, --format=verbose 파일 나열에 있어, 파일 형태, 사용권한, 하드링크 번호, owner 이름, group 이름, 파일 크기, 시간(따로 지정하지 않으면 파일이 만들어진 날자다)을 자세하게 나열한다. 시간은 여섯달 이전 것이면, 시간이 생략되고, 파일의 연도가 포함된다. -m, --format=commas 파일을 가로로 나열한다. 가로로 나열할 수 있는 만큼 최대한 나열한다. -n, --numeric-uid-gid 이름의 나열에서 UID,GID 번호를 사용한다. -p 파일 형태를 지시하는 문자를 각파일에 추가한다. -q, --hide-control-chars 파일 이름에 그래픽 문자가 아닌 것이 있으면, ``?``로 표시한다. -r, --reverse 정열 순서를 내림차순으로 한다. -s, --size 파일 크기를 1Kb 단위로 나타낸다. POSIXLY_CORRECT 환경 변수가 지정되면, 512b 단위로 지정된다. -t, --sort=time 파일 시간 순으로 정열한다. 최근 파일이 제일 먼저. -u, --time=atime, --time=access, --time=use 파일 사용 시간 순으로 정열한다. 자세한 나열이면, 시간 표시는 만들어진 날자대신, 사용된 날자를 보여준다. -x, --format=across, --format=horizontal 정열 방식을 가로로 한다. -A, --almost-all ``.``, ``..`` 경로를 제외하고 디렉토리안의 모든 파일을 나열한다. -B, --ignore-backups 파일 끝이 `~&apos;인 파일은 목록 나열에 제외된다. -C, --format=vertical 정열 방식을 세로로 한다. -F, --classify 파일 형식을 알리는 문자를 각 파일 뒤에 추가한다. 일반적으로 실행파일은 &quot;*&quot;, 경로는 &quot;/&quot;, 심블릭 링크는 &quot;@&quot;, FIFO는 &quot;|&quot;, 소켓은 &quot;=&quot;, 일반적인 파일은 없다. -G, --no-group 자세한 목록 나열에서 group 정보를 제외한다. -L, --dereference 심블릭 링크 파일들을 그냥 파일로 보여준다. -N, --literal 이름이 영문이 아닌 경우, C에서 사용하는 역슬래쉬 문자(`\\&apos;)와 함께 사용하는 표기 대신 그대로 출력한다. -Q, --quote-name -N 옵션과 반대. -R, --recursive 하위 경로와 그 안에 있는 모든 파일들도 나열한다. -S, --sort=size 파일 크기가 가장 큰 것 부터 정열해서 나열한다. -U, --sort=none 정열을 하지 않고, 디스크에 저장된 순서대로 보여준다. 이 옵션은 -f 옵션을 사용할 수 없다. 유닉스 용 ls -f는 -a 옵션은 가능하나, -l, -s, -t 옵션이 불가능하기 때문이다. -X, --sort=extension 파일 확장자 순으로 정열한다. 확장자가 없는 파일이 제일 먼저 나열된다. -1, --format=single-column 한 줄에 한 파일씩 나열. -w, --width cols 가로 길이를 값으로 지정한다. 기본적으로는 한 화면의 가로 값이된다. 또한 COLUMNS 환경 변수 값으로 지정할 수 있다. 초기값은 80이다. -T, --tabsize cols 탭이 사용될 때, cols 값으로 지정한다. 초기값은 8이다. 0으로 지정되면 탭 문자는 무시된다. -I, --ignore pattern pattern 패턴으로 지정된 파일들은 목록에서 제외된다. 이때, 명령행에서 그 파일이 지정되면 물론 나열된다. --color, --colour, --color=yes, --colour=yes 파일의 형태에 따라 그 파일의 색깔을 다르게 보여주는 기능한다. 자세한 이야기는 아래 DISPLAY COLORIZATION 부분을 참조한다. --color=tty, --colour=tty --color 옵션과 같으나, 단지 표준 출력에서만 색깔을 사용한다. 이 옵션은 칼라 제어 코드를 지원하지 않는 보기 풀그림을 사용하는 쉘 스크립트나, 명령행 사용에서 아주 유용하게 쓰인다. --color=no, --colour=no 색깔 사용하지 않는다. 이것이 초기값이다. 이옵션은 색깔 사용을 이미 하고 있다면, 이 값을 무시한다. --help 도움말을 보여주고 마친다. --version 버전 정보를 보여주고 마친다. DISPLAY COLORIZATION --color 옵션을 사용할 때, 이 버전의 ls 명령은 파일 이름이나, 파일 형태에 따라 파일의 색깔별로 나열할 수 있다. 이 칼라화는 초기값으로 파일 형태에 따라서만 사용된다. 사용되는 코드는 ISO 6429 (ANSI)이다. 이런 초기 색깔 지정은 LS_COLORS (또는 LS_COLOURS) 환경 변수 지정으로 바꿀 수 있다. 이 변수들의 형식은 term‐ cap(5) 파일 포멧의 방식을 사용한다. 각 항목은 &quot;:&quot;으로 하며, 각 항목은 &quot;xx=문자열&quot;로 한다. xx에는 두개의 문자가 오는데, 여기서 사용할 수 있는 문자는 다음과 같다. no 0 파일 이름이 아닌 일반 텍스트 fi 0 일반 파일 di 32 경로 ln 36 심블릭 링크 pi 31 FIFO(파이프) so 33 소켓 bd 44;37 블럭 장치 cd 44;37 캐릭터 장치 ex 35 실행 파일 mi (없음) 잃어버린 파일 (초기값은 fi) or (없음) 심블릭 링크 대상이 없는 파일(초기값은 ln) lc \\e[ 왼쪽 코드 rc m 오른쪽 코드 ec (없음) 마침 코드 (lc+no+rc로 바뀜) 색깔을 바꿀 경우는 그 해당 변수만 바꾸면 된다. 파일 이름은 파일의 확장자에 따라 색깔을 지정할 수 있다. LS_COLORS 환경 변수에 포함하면 되고, 그 사용법은 위와 같다. 문법은 &quot;*ext=문자열&quot;이다. 예를 들어, C 소스 파일을 파란색으로 지정하려면, &quot;*.c=34&quot;이다. 제어 문자는 C에서와 갈이 `\\&apos;문자로 시작하는 문자를 사용하거나, stty와 같이 `^&apos;문자로 시작하는 문자를 사용할 수 있다. C 스타일일 경우는 \\e는 Esc, \\_ 공백문자, \\? Delete 이다. 추가로, \\ escape 문자는 \\, ^, :, =의 초기 처리 방식을 무시하는데 사용될 수 있다. 각 파일은 &lt;lc&gt; &lt;색깔값&gt; &lt;rc&gt; &lt;파일이름&gt; &lt;ec&gt; 형태로 지정 된다. 만약 &lt;ec&gt; 코드를 지엉하지 않으면, &lt;lc&gt; &lt;no&gt; &lt;rc&gt; 가 대치된다. 이 방법은 보다 많은 변환을 하지만 일반적인 방법은 아니다. 왼쪽, 오른쪽, 마지막 코드는 일반적인 ISO 6429 코드를 지원하지 않는 터미날을 위한 값으로 특별한 경우가 아니면, 사용할 필요가 없다. ISO 6429 코드일 경우 사용될 수 있는 코드값은 다음과 같다. (물론 lc, rc, ec 값은 제외된다.) 0 초기 색깔로 다시 돌린다. 1 강조색 4 밑줄 5 깜빡이는 글자. 30 까만색 전경 31 빨강 전경 32 녹색 전경 33 노랑(또는 갈색) 전경 34 파랑 전경 35 보라 전경 36 청록색 전경 37 흰색(또는 회색) 전경 40 까만색 배경 41 빨강 배경 42 녹색 배경 43 노랭(또는 갈색) 배경 44 파랑 배경 45 보라 배경 46 청록색 배경 47 흰색(또는 회색) 배경 모든 명령이 모든 시스템이나 디스플레이 장치에서 제대로 동작하는 것은 아니다. 몇 터미날은 초기 마지막코드(ec)가 인식되지 않을 수 있다. 만약, 색들을 사용했다면, no, fi 값을 0으로 지정해 초기값으로 되돌려 놓아야 한다.BUGS BSD 시스템에서는, -s 옵션이 HP-UX 시스템으로 부터 NFS 마운트된 파일을 위한 파일 크기가 반으로 잘못 보여진다고 한다. HP-UX 시스템에서는, BSD 시스템으로 부터 NFS 마운트된 파일을 위한 파일의 크기가 반대로 두배로 나타난다. 이런 현상은 HP-UX ls 풀그림도 마찬가지라고 한다. 영어권 문자셋을 사용할 경우는 별 문제가 없지만, 한국어와 같이 2바이트 문자권에서는 자국어로 된 파일 이름을 보기 위해 특별한 옵션을 지정해 주어야한다. ``-N --color=tty`` 옵션이 그 옵션이다.FSF GNU File Utilities LS(1)","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"},{"name":"ls","slug":"ls","permalink":"http://korcow.github.io/tags/ls/"},{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"}]},{"title":"외부명령어","slug":"외부명령어-1","date":"2017-10-31T04:18:25.000Z","updated":"2017-10-31T04:18:25.437Z","comments":true,"path":"2017/10/31/외부명령어-1/","link":"","permalink":"http://korcow.github.io/2017/10/31/외부명령어-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"solarized_theme적용하기","slug":"solarized-theme적용하기","date":"2017-10-30T18:01:54.000Z","updated":"2017-11-01T05:11:00.772Z","comments":true,"path":"2017/10/31/solarized-theme적용하기/","link":"","permalink":"http://korcow.github.io/2017/10/31/solarized-theme적용하기/","excerpt":"","text":"터미널 Solarized Theme 적용12345678910111213141516171819202122232425262728293031323334353637$mkdir -p ~/.mysetting/Solarized$cd ~/.mysetting/Solarized$git clone https://github.com/sigurdga/gnome-terminal-colors-solarized.git$cd gnome-terminal-colors-solarized$./install.sh그럼 다음과 같은 순서 대로 물어 물어 옵니다.색상 선택: 1번을 선택Please select a color scheme:1) dark2) dark_alternative3) light#? 1프로파일 선택: 1번을 선택Please select a Gnome Terminal profile:1) 이름 없음#? 1You have selected: Scheme: dark Profile: 이름 없음 (b1dcc9dd-5262-4d8d-a863-c897e6d979b9)프로파일을 덮어쓰겠냐고 물으면 yes를 입력Are you sure you want to overwrite the selected profile?(YES to continue) yesConfirmation received -- applying settingsA dircolors adapted to solarized can be automatically downloaded.1) Download seebi' dircolors-solarized: https://github.com/seebi/dircolors-solarized2) [DEFAULT] I don't need any dircolors.디렉토리및파일 색상 변경을 설치하겠냐고 물으면 2번을 눌러 설치 안함을 선택.Enter your choice : [2] 2 터미널을 종료했다 다시 실행하면 됩니다. 터미널 디렉토리및 파일 색상 설정(CentOS 만)1234$cd ~/.mysetting/solarized$git clone https://github.com/seebi/dircolors-solarized$vi ~/.bash_profile 맨밑에 아래 줄을 붙여 넣으세요. 123eval `dircolors ~/.mysetting/solarized/dircolors-solarized/dircolors.ansi`:wq 터미널을 종료 하고 재실행하면 반영됩니다.또는 1$suource ~/.bash_profile","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"vundle","slug":"vundle","permalink":"http://korcow.github.io/tags/vundle/"},{"name":"solarized","slug":"solarized","permalink":"http://korcow.github.io/tags/solarized/"},{"name":"theme","slug":"theme","permalink":"http://korcow.github.io/tags/theme/"}]},{"title":"Vundle 설치","slug":"Vundle-설치","date":"2017-10-30T17:53:54.000Z","updated":"2017-11-01T04:43:56.192Z","comments":true,"path":"2017/10/31/Vundle-설치/","link":"","permalink":"http://korcow.github.io/2017/10/31/Vundle-설치/","excerpt":"","text":"프로그래밍을 위한 vim 세팅복사/붙여넣기 vi가 익숙하지 않을 경우 gedit을 이용해도 됩니다. 맥용 virtualbox 5.1.28에서 macos용이 게스트 확장이 안되고 있습니다. 클립보드 공유와 화면크기 자동조정, 마우스 통합등. 맥사용자는 불편하더라도 당분간 아래 방법을 써야 합니다. 아님 paralls, vmware를 이용하는 것도 무방합니다. centOS에서 브라우저 내용을 복사해서 터미널로 붙여 넣을 때는 Shift+Ctrl+v 또는 Alt + 마우스 왼쪽클릭 하면 팝업메뉴가 나옵니다. 붙여넣기 선택 또는 터미널 메뉴의 편집 &gt; 붙여넣기를 선택합니다. git 설치12345678# centos$sudo yum install git# ubuntu$sudo apt_get install git# macos$brew install git sudo 가붙은 명령은 관리자 비밀번호 입력해야 합니다. gvim설치(설치 되어 있다면 통과)12345678# centos$sudo yum install gvim# ubuntu$sudo apt_get install gvim# macos$brew install macvim gvim을 설치하는 이유는 클립보드로 복사, 붙여넣기를 해야 하기 때문입니다. vim에서 클립보드 내용을 붙여 넣으려면 “+P vim의 내용을 클립보드로 복사 하려면 “+Y 이 동작은 .vimrc 에 set clipboard=unnamed 를 추가해야 동작 됩니다. 이 후 한꺼번에 추가하도록 하겠습니다. 터미널에서 vi를 실행하면 gvim이 실행되도록 .bash_profile을 수정합니다. .bash_profile 수정12$cd ~$vi .bash_profile 1234\" 마지막에 줄에 아래문장을 붙여 넣습니다.alias vi=\"gvim -v\":wq 1$source .bash_profile .vim 디렉토리 생성 및 vundle clone123$mkdir -p .vim/bundle$git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim .vimrc 생성.vimrc 파일을 오픈합니다. 123$gvim:e ~/.vimrc .vimrc 파일이 열리면 아래 내용을 복사해서 붙여 넣습니다.vim에서 붙여넣기 할 때는 편집 메뉴에 있는 붙이기를 선택합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247\"=================================================\" Vundle\" https://github.com/gmarik/vundle\"=================================================set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'Plugin 'tpope/vim-fugitive'\" All of your Plugins must be added before the following linePlugin 'altercation/vim-colors-solarized' \" solarized 테마Plugin 'scrooloose/nerdtree' \" 파일/폴더관리Plugin 'terryma/vim-multiple-cursors' \" 멀티커서 Plugin 'kien/ctrlp.vim'\"============== SnipMate ===================== # 코드단축Plugin 'MarcWeber/vim-addon-mw-utils'Plugin 'tomtom/tlib_vim'Plugin 'garbas/vim-snipmate'Plugin 'honza/vim-snippets'\"=================================================Plugin 'davidhalter/jedi-vim' \"파이썬 idePlugin 'vim-airline/vim-airline' \"vim 꾸미기Plugin 'vim-airline/vim-airline-themes' \"vim 꾸미기 테마Plugin 'tpope/vim-surround' \"문자 감싸기Plugin 'suan/vim-instant-markdown' \" 마크다운 미리보기Plugin 'VisIncr' \" 자동증감01234Plugin 'klen/python-mode' \" ide\"============== 마크다운 ======================Plugin 'godlygeek/tabular' Plugin 'plasticboy/vim-markdown'Plugin 'mzlogin/vim-markdown-toc'\"=================================================\"Plugin 'joshdick/onedark.vim'\"Plugin 'vim-pandoc/vim-pandoc'\"Plugin 'vim-pandoc/vim-pandoc-syntax' \"Plugin 'junegunn/goyo.vim'\"=====================================\"Plugin 'dbext.vim' \" dbms관리\"=====================================\"call vundle#end()filetype plugin indent on\" To ignore plugin indent changes, instead use:\" filetype plugin on\"\" Brief help\" :PluginList - 설치된 플러그인 목록 보기\" :PluginInstall - 플러그인설치; append`!` 추가된 플러그인만 설치\" :PluginUpdate - 플러그인 업데이트\" :PluginSearch foo - 플러그인 검색; append`!` 로컬 캐시를 갱신 \" :PluginClean - 플러그인 삭제; append`!` 사용하지 않은 플러그인 삭제\" .vimrc에 플러그인을 추가했으면\":w 저장 \":source % \".vimrc 다시 로드\":PluginInstall \"플러그인 설치\" http://vimawesome.com \"플러그인 조회 사이트\" http://vimcast.org \"강좌\" see :h vundle \"도움말\"=============================================================\"\" When started as \"evim\", evim.vim will already have done these settings.if v:progname =~? \"evim\" finishendif\" This must be first, because it changes other options as a side effect.set nocompatible\" allow backspacing over everything in insert modeset backspace=indent,eol,startif has(\"vms\") set nobackup \" do not keep a backup file, use versions insteadelse set backup \" keep a backup fileendifset history=50 \" keep 50 lines of command line historyset ruler \" show the cursor position all the timeset showcmd \" display incomplete commandsset incsearch \" do incremental searching\" For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries\" let &amp;guioptions = substitute(&amp;guioptions, \"t\", \"\", \"g\")\" Don't use Ex mode, use Q for formattingmap Q gq\" CTRL-U in insert mode deletes a lot. Use CTRL-G u to first break undo,\" so that you can undo CTRL-U after inserting a line break.inoremap &lt;C-U&gt; &lt;C-G&gt;u&lt;C-U&gt;\" In many terminal emulators the mouse works just fine, thus enable it.if has('mouse') set mouse=aendif\" Switch syntax highlighting on, when the terminal has colors\" Also switch on highlighting the last used search pattern.if &amp;t_Co &gt; 2 || has(\"gui_running\") syntax on set hlsearchendif\" Only do this part when compiled with support for autocommands.if has(\"autocmd\") \" Enable file type detection. \" Use the default filetype settings, so that mail gets 'tw' set to 72, \" 'cindent' is on in C files, etc. \" Also load indent files, to automatically do language-dependent indenting. filetype plugin indent on \" Put these in an autocmd group, so that we can delete them easily. augroup vimrcEx au! \" For all text files set 'textwidth' to 78 characters. autocmd FileType text setlocal textwidth=78 \" When editing a file, always jump to the last known cursor position. \" Don't do it when the position is invalid or when inside an event handler \" (happens when dropping a file on gvim). \" Also don't do it when the mark is in the first line, that is the default \" position when opening a file. autocmd BufReadPost * \\ if line(\"'\\\"\") &gt; 1 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | \\ exe \"normal! g`\\\"\" | \\ endif augroup ENDelse set autoindent \" always set autoindenting onendif \" has(\"autocmd\")\" Convenient command to see the difference between the current buffer and the\" file it was loaded from, thus the changes you made.\" Only define it when not defined already.if !exists(\":DiffOrig\") command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis \\ | wincmd p | diffthisendifset nu \" 줄번호를 보여줌\" 탭설정 하기set ts=4 \" 탭의 4의 공백 폭을 \"set sts=4 \"탭을 눌렀을 때 스페이스(ascii-0x20) 4개가 삽입되도록 합니다.set sw=4 \"'&lt;'나 '&gt;'키로 줄 전체를 밀거나 당길 때 참조되는 폭입니다.\"set et \"set expandtab 탭을 공백으로 바꿈\"retab \"vim 사용중 탭이 공백으로 바뀌지 않은 경우 et를 다시 적용set bs+=indent,eol,start \"들여쓰기된 스페이스를 지울 때 백스페이스를 여러번 누르지 않도록 하기 위해 sts 설정값만큼 백스페이스가 적용됩니다.set listchars=tab:»\\ ,extends:›,precedes:‹,nbsp:·,trail:∙set showbreak=↪\\\"========== instant_markdown ======================\"마크다운 문서를 작성시 브라우저로 미리 보기\"let g:instant_markdown_slow = 1\"자동실행 방지 0let g:instant_markdown_autostart = 1 \"============ vim_markdown =========================\" 마크다운 편집옵션let g:vim_markdown_folding_disabled = 1let g:vim_markdown_toc_autofit = 1let g:vim_markdown_math = 1let g:vim_markdown_frontmatter = 1let g:vim_markdown_toml_frontmatter = 1let g:vim_markdown_json_frontmatter = 1\"====================================================\" 컴파일 , 키맵\" c언어,pytyon\" compile and Run\" java는 eclipse에서 컴파일\" :명령줄 실행\" &lt; 백스페이스\" % 파일명\" &lt;Enter&gt; 엔터입력&lt;CR&gt;과 동일au FileType c map &lt;F5&gt; :w&lt;Enter&gt;:!gcc % -o %&lt;.o&lt;Enter&gt;:!./%&lt;.o&lt;Enter&gt;au FileType python map &lt;F5&gt; :w&lt;Enter&gt;:!python %&lt;Enter&gt;au FileType rube map &lt;F5&gt; :w&lt;Enter&gt;:!rube %&lt;Enter&gt;\"외부에서 파일변경시 자동으로 읽어들임\"이클립스, xcode 사용시 set autoread&lt; \"gvim설치시, 클립보드사용set clipboard=unnamed\"=============== airline ===============\" 화이트 스페이스 체크 안함. let g:airline#extensions#whitespace#enabled = 0 \" 확장탭라인을 사용let g:airline#extensions#tabline#enabled = 1 \" vim-airline 버퍼 목록 켜기\"let g:airline#extensions#tabline#fnamemod = ':t' \" vim-airline 버퍼 목록 파일명만 출력\" let g:airline#extensions#tabline#buffer_nr_show = 1 \" buffer number를 보여준다let g:airline#extensions#tabline#buffer_nr_format = '%s:' \" buffer number format\"let g:airline_powerline_fonts = 1let g:airline_theme='solarized'let g:airline_solarized_bg='dark'set laststatus=2colorscheme solarizedlet g:solarized_termcolors=256\"=============== airline =================let mapleader=\",\" \" 리더키를 , 로 변경 주석처리하면 원상태nnoremap &lt;Leader&gt;ex !!$SHELL&lt;CR&gt; \",ex로 외부명령을 실행\"새탭으로 오픈\"nnoremap &lt;Leader&gt;rc :tabnew $MYVIMRC&lt;CR&gt; \" 오른쪽에 오픈\"nnoremap &lt;Leader&gt;rc :rightbelow vnew $MYVIMRC&lt;CR&gt;\",rc로 .vimrc파일 오픈nnoremap &lt;Leader&gt;rc :e $MYVIMRC&lt;CR&gt; nnoremap &lt;Leader&gt;n :NERDTreeToggle&lt;CR&gt;nnoremap &lt;C-F&gt; :NERDTreeFind&lt;CR&gt;\"================ 약어 (abbreviations) ======================\" snippet은 tab을 눌러야하고 약어는 자동으로 바뀜\" snippet은 자동완성, \"ab la Los Angeles(L.A) 이렇게 사용해야함.\"한글 약어는 안되는 단어도 있음, 한글 약어가 안될땐 snippet에 추가.ab 컨브 Ctrl+vab 컨씨 Ctrl+cab 컨엠 Ctrl+mab 이시 Ctrl+[ or \\&lt;Esc\\&gt;ab 노모 Normal modeab 커모 Command modeab 비모 Visual modeab 인모 Insert modeab 로렘 정당은 법률이 정하는 바에 의하여 국가의 보호를 받으며, 국가는 법률이 정하는 바에 의하여 정당운영에 필요한 자금을 보조할 수 있다. 대통령의 임기연장 또는 중임변경을 위한 헌법개정은 그 헌법개정 제안 당시의 대통령에 대하여는 효력이 없다. 위원은 탄핵 또는 금고 이상의 형의 선고에 의하지 아니하고는 파면되지 아니한다. 제3항의 승인을 얻지 못한 때에는 그 처분 또는 명령은 그때부터 효력을 상실한다. 이 경우 그 명령에 의하여 개정 또는 폐지되었던 법률은 그 명령이 승인을 얻지 못한 때부터 당연히 효력을 회복한다.ab 배요일 \"월\", \"화\", \"수\", \"목\", \"금\", \"토\", \"일\"ab 배코이름 \"유재석\", \"박명수\", \"강호동\", \"신동엽\", \"박미선\"ab 배색깔 \"빨강\", \"주황\", \"노랑\", \"초록\", \"파랑\", \"남\", \"보라\"ab 브이아이 VIab 빔 VIM 저장하고 .vimrc를 다시 읽어들입니다. 12:w:so % 오류가 많이 나는데 무시 해도 됩니다. 아직 플러그인 설치가 되지 않아서 발생하는 오류 입니다.플러그인을 설치합니다. 1:PluginInstall vim을 종료했다 다시 시작합니다.설치가 완료 되었습니다.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"},{"name":"bundle","slug":"bundle","permalink":"http://korcow.github.io/tags/bundle/"},{"name":"Vundle","slug":"Vundle","permalink":"http://korcow.github.io/tags/Vundle/"}]},{"title":"vim의 고급 사용법","slug":"vim의-고급-사용법","date":"2017-10-30T17:51:37.000Z","updated":"2017-11-01T04:31:07.740Z","comments":true,"path":"2017/10/31/vim의-고급-사용법/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim의-고급-사용법/","excerpt":"","text":"vim 고급 사용법고급사용법? 프로그래밍을 하다보면 어쩌다 한번씩 vim을 사용할 때가 있습니다. 서버의 환경변수를 수정할 때… 이럴때는 몇가지 기능만 쓸수 있으면 됩니다. 불편하지만 사용하는데 문제 되지 않습니다. 여기서 조금더 나아가 필수 명령을 숙지 한다면 vim을 다른 어떤 에디터 보다 편하고 빠르게 사용할 수 있습니다. vim을 메인 에디터로 사용하기 위해 기본으로 알아야 사항을 최소한으로 요약 했읍니다. 물론 전체 기능의 10%도 안되는 내용이지만 아래 내용만 알아도 vim을 사용하는데 큰 불편함을 느끼지 않을 겁니다. 또 알아서 필요한 기능을 찾을 수 있는 레벨까지 올라 갈 겁니다. vim은 모든 사람들이 사용하는 패턴이 틀립니다. 자신만의 사용 패턴을 빨리 찾는 것이 중요합니다. Modevim은 크게 4가지 모드로 동작되어 집니다. Normal Mode Insert Mode Visual Mode Commnd-Line Mode 이중에 가장 기본이 되는 모드는 Normal Mode(command mode)라고도 합니다.언제든 Ctrl+[ 키를 입력하면 Normal Mode가 됩니다.이곳에서 Insert mode , Visual mode, Command-Line mode 로 이동이 가능합니다. 반대로 각각의 모드에서 모드 전환을 하려면 반드시 Normal mode 로 이동해서 전환 해야 합니다. Normal mode 모드이동 명령 Normal Mode : , Ctrl+[ Insert Mode : i, I, a, A, o, O Visual Mode : v, V, Ctrl+v(windows는 Ctrl+q) Command-line Mode : : 커서이동 명령 h: motion.txt h, j, k, l : 좌우로 한칸, 위아래로 한줄씩 커서를 이동합니다. 명령앞에 숫자를 입력하면 숫자 만큼 명령을 수행 합니다. 예) 10l : 오른쪽으로 10칸 이동 예) 10h : 왼쪽으로 10칸 이동 단어단위로 이동 : w, W, b, B, e, gE 0, $, ^, [, {, (, ), }, ] : 현재줄의 처음과 끝, 문장의 처음과 끝, 문단의 처음과 끝으로 이동 H, M, L H : 화면 맨위로 M : 화면 중간으로 L : 화면 끝으로 gg, nG : 줄단위로 커서를 이동 시킵니다. gg는 문서 맨 위로 커서를 이동 시킵니다. nG는 숫자 위치로 커서를 이동 시킵니다. 찾아서 커서 이동하기 명령 f, F, t, T, /, ? : 특정 문자, 키워드를 찾아 이동합니다. f : 오른쪽으로 문자를 찾아 이동합니다. F는 왼쪽으로 찾아 이동합니다. t : 오른쪽으로 문자를 찾아 찾은 문자 왼쪽에 커서를 위치 시킵니다. T는 왼쪽에서 찾아 오른쪽에 커서를 위치시킵니다. / : /는 키워드를 현재 커서 아래로 모두 찾아 하이라이트 해줍니다. n, N으로 이동 할 수 있습니다. 키워드와 단어는 조금 다릅니다. 키워드는 단어와 공백을 포함합니다. ? : ?는 현재 커서 위로 키워드를 찾아 이동합니다. 삭제 명령 :h deleting x, X, d, dd, D x는 커서위의 문자를 지웁니다. 또는 범위 설정된 부분을 지웁니다. X는 커서위의 문자를 지우고 왼쪽문자에 붙입니다. d는 삭제 대기 명령입니다. 어떻게 삭제할 지를 대기 하고 있습니다. 이동명령과 조합 가능합니다. dw : 커서 위치에서 부터 한단어 삭제, 주의 have 란 단어의 a에 커서가 있을 경우 ave만 삭제 d5l : 커서를 기준으로 오른쪽으로 5칸 삭제. daw : 커서 위치의 단어를 삭제. nd : d앞에 반복 숫자를 사용할 수 있음. 3dw : 3단어 삭제 d$ : 커서 위치부터 줄 끝까지 삭제. d0 : 커서 위치부터 줄 처음까지 삭제. dG : 커서 위치부터 마지막 까지 삭제. dd : 현재줄 모두 삭제. D : 커서 위치부터 줄끝까지 삭제. 2D: 현재 커서 위치부터 2줄을 삭제. 현재줄 끝까지 삭제되고 추가로 2줄이 삭제됨. 바꾸기 명령 s, S, c, C s : 커서위 문자를 지우고 insert mode가 됩니다. S : 줄 전체를 지우고 insert mode 가 됩니다. c : 바꾸기 대기 명령, 이동키와 조합 가능 cw : 현재 커서위치 부터 한단어를 지우고 insert mode caw : 현재 커서위치의 단어를 지우고 insert mdoe ci’ : ‘’ 안의 문자열을 지우고 insert mode ca’ : ‘’ 포함해서 지우고 insert mode ci” : “” 안의 문자열을 지우고 insert mode ca” : “” 를 포함 문자열을 지우고 insert mode C : 현재 커서부터 줄 끝까지 지우고 insert mode 덮어쓰기 명령 r, R r : 현재 커서위의 1문자를 지우고 insert mode(1문자만), 이동 명령과 조합 가능. 10r : 현재 커서위치의 1문자를 지우고 입력대기(주의 최초r을 10번 반복). v2lr : 현재 커서 위치부터 2칸을 지우고 입력대기 ==========================================위와 같은 문자를 -로 바꾸려면커서를 처음 =에 위치시키고 v$r- R : 줄전체를 지우고 insert mode 복사 명령/붙이기 명령 y, yy, Y y : 복사 대기 명령, 이동키와 조합 가능 3yW : 현재 커서 위치부터 3단어를 복사. yy : 한줄을 복사. Y : 현재 커서 줄부터 한줄을 복사. 2Y : 현재 커서 줄부터 2줄을 복사. p : 현재 커서 뒤에 붙이기. 행을 복사한 경우 아랫줄에 붙여넣음. P : 현재 커저 앞에 붙이기. 행을 복사한 경우 윗줄에 붙여넣음.(주의)붙이기를 할때 복사 한것이 열을 복사한 것인지, 줄을 복사한 것인지에 따라 기준이 앞, 뒤, 윗줄, 아랫줄로 반영됩니다. 스크롤 명령 Ctrl+u, Ctrl+d, Ctrl+e, Ctrl+y, Ctrl+f, Ctrl+b Ctrl+u : 커서를 중앙에 두고 위로 한화면 스크롤 Ctrl+d : 커서를 중앙에 두고 아래로 한화면 스크롤 Ctrl+e : 한줄씩 위로 Ctrl+y : 한줄씩 아래로 Ctrl+f : 한화면 위로 커서는 화면 상단 Ctrl+b : 한화면 아래로 커서는 화면 하단 접고 펴기 명령 :h fold zf : 폴드 생성. 여러줄을 1줄로 압축 zip fold 해줍니다. zo : 폴드를 열어줍니다. zip open zc : 폴드를 닫아줍니다. zd : 현재 위치의 폴드를 삭제해줍니다. zR : 현재 문서의 모든 폴드 열기. zM : 현재 문서의 모든 폴드 닫기. zE : 현재 문서의 모든 폴드 삭제. zD : 현재 위치의 겹쳐진 폴드 삭제. Insert Mode i, I, a, A, o, O i : i명령은 커서 앞에 입력합니다. I : 줄 처음에 입력을 합니다. a : 커서 뒤에 입력을 합니다. A : 줄 끝에 입력을 합니다. o : 커서 아래에 새줄을 만들고 입력을 합니다. O : 커서 위에 새줄을 만들고 입력을 합니다. 문자를 지우려면 백스페이스 또는 Ctrl+h를 입력합니다. 단어를 지우려면 Ctrl + w 줄을 지우려면 Ctrl + u Insert mode에서 커서이동은 마우스를 사용하거나 Normal Mode에서 하는 것이 편합니다. 단어 단위로 이동하려면 Ctrl+좌우방향키 위 아래줄로 이동하려면 Ctrl+gk , Ctrl+gj Ctrl+n 커서 이전에 입력한 단어를 모두 보여주고 자동완성 시켜줍니다. Ctrl+p는 후보를 반대로 찾음 캘리포니아 란 단어를 입력 했었고, 다시 입력하려고 하면 캘 까지만 입력하고 Ctrl + n Visual Mode v, V, Ctrl + V(windows Ctrl+q) 비주얼 모드는 범위를 지정할 때 사용하는 mode 입니다. v : 라인을 기준으로 범위를 지정합니다. V : 줄단위로 범위를 지정합니다.(단위가 줄입니다.) Ctrl + v : 열을 기준으로 범위를 지정합니다. 이동키 또는 마우스로 범위를 지정할 수 있습니다. Command-line Mode 파일관리 w, e, E, pwd, cd w : 파일을 저장합니다. e : 파일을 오픈 합니다. 파일이 존재 하면 open, 없으면 새로 만듦. E : netrw를 실행 합니다. vim용 파일 관리 매니저 입니다. 종료는 :bd pwd : 현재 작업 디렉토리를 보여줍니다. cd : 작업 디렉토리를 이동합니다. 버퍼관리 ls, bn, bd, bp, b(숫자) ls : 버퍼 목록을 보여줍니다. bn : 다음 버퍼로 이동합니다. bp : 앞에 있는 버퍼로 이동합니다. b(숫자) : 숫자에 해당하는 버퍼로 이동합니다. 창관리 vs, sp, Ctrl+w vs : 창을 세로로 나누어 줍니다. sp : 창을 가로로 나누어 줍니다. Ctrl + w : 찾을 이동합니다. 누를 때마다 창이 전환됩니다. 외부명령 ! 외부명령을 실행 합니다.","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim의 기본사용법","slug":"vim의-기본사용법","date":"2017-10-30T17:43:28.000Z","updated":"2017-11-01T04:32:04.262Z","comments":true,"path":"2017/10/31/vim의-기본사용법/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim의-기본사용법/","excerpt":"","text":"기본 사용법실행하기1$vi 콘솔에서 vi를 입력하면 vi가 실행됩니다. 처음 실행이 되면 기본으로 normal mode 되고 이곳에 명령을 입력하면 됩니다. 텍스트를 입력하기 위해 i명령을 입력하면 하단의 상태줄 좌측에 입력하기 라고 변경됩니다. 이제 키보드로 타이핑하는 것이 입력이 됩니다. 텍스트를 입력해 보세요. ^^ 삭제 : 백스페이스를 누르면 키보드 앞의 1문자가 삭제되어 집니다. Ctrl + h 도 동일합니다. 이동 : 커서키 또는 마우스를 이용해서 이동합니다. 복사 : 마우스로 복사할 영역을 드래그하고 Y를 누릅니다. 이때 자동으로 visual mode 가 됩니다. 선택이 끝나면 자동으로 normal mode 가 됩니다. 다시 입력하려면 i 명령을 입력하세요. 붙여넣기 : 붙여넣기 할 위치에 마우스나 방향키를 이용해 커서를 위치시키고 P를 누릅니다. 다시 입력하려면 i 명령을 입력하세요. 저장하기 : Ctrl + [ + : w abc.txt 저장하기 명령을 내리려면 Command-lind mode로 이동해야 합니다. &lt;Esc&gt; 또는 Ctrl + [ 를 누르고 : (콜론)을 입력하면 Command-line mode 로 이동됩니다. vim 하단에 : 이 표시 되면 w 저장할파일명 을 입력합니다. 파일명을 한글로 입력하지 마세요. 파일명에 띄어 쓰기를 하지 마세요. 파일명에 특수문자를 넣지 마세요. 컴퓨터를 사용하는 기본 규칙입니다. 파일명을 한글과 공백을 써야 한다면 “한글 파일명.md” 이렇게 써야 합니다. Ctrl + [ + : 사용을 추천합니다. 종료 : Ctrl+[ + : q 저장한 후 종료 해야 합니다. 저장하지 않고 종료하려면 Ctrl+[ + : q! 종료 명령도 normal mode에서 해야 합니다. 파일 수정하기1$vi abc.txt 실행시 수정할 파일명을 같이 입력합니다. 이후 사용법은 동일합니다. 입력을 하려면 i 명령을, 이동하려면 커서키나 마우스사용…","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim 실행과 종료","slug":"vim-실행과-종료","date":"2017-10-30T17:39:33.000Z","updated":"2017-11-01T05:13:00.212Z","comments":true,"path":"2017/10/31/vim-실행과-종료/","link":"","permalink":"http://korcow.github.io/2017/10/31/vim-실행과-종료/","excerpt":"","text":"vim의 실행과 종료실행하기1$vi 콘솔에서 vi를 입력하면 vi가 실행됩니다. 처음 실행이 되면 기본으로 normal mode 되고 이곳에 명령을 입력하면 됩니다. 텍스트를 입력하기 위해 i명령을 입력하면 하단의 상태줄 좌측에 입력하기 라고 변경됩니다. 이제 키보드로 타이핑하는 것이 입력이 됩니다. 텍스트를 입력해 보세요. ^^ 종료하기123\"Ctrl+[ or ``Esc key`` 입력:w abc.txt \"abc.txt로 저장, 저장하지 않고 종료하려면 :q!:q \"종료 수정하기1$vi abc.txt","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/tags/Vim/"}]},{"title":"vim설치","slug":"vim설치","date":"2017-10-30T11:46:09.000Z","updated":"2017-11-01T13:12:54.603Z","comments":true,"path":"2017/10/30/vim설치/","link":"","permalink":"http://korcow.github.io/2017/10/30/vim설치/","excerpt":"","text":"vim 설치하기 대부분의 Unix계열은 기본으로 vim이 설치 되어 있습니다.vim은 별도로 설치 하지 않아도 됩니다.윈도우 계열은 vim.org에서 자신의 운영체제에 맞는 버젼을 다운받아 설치 하면 됩니다.Unix계열은 gui를 사용 한다면 편의상 gvim을 설치하는 것이 좋습니다. 그래야 클립보드를 사용할 수 있습니다. 설치 방법은 아래와 같습니다. 12345678#red hat 계열$ sudo yum install gvim # macos$ brew install macvim-dev/macvim/macvim# debian 계열$ suso apt-get install gvim .bash_profile 또는 .profile에 다음과 같이 alias를 추가 합니다. sh alias vi=gvim -v","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://korcow.github.io/tags/vim/"}]},{"title":"외부명령어","slug":"외부명령어","date":"2017-10-29T10:47:23.000Z","updated":"2017-11-01T05:08:49.087Z","comments":true,"path":"2017/10/29/외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/외부명령어/","excerpt":"","text":"외부명령어외부 명령어는 명령라기 보다는 프로그램이라고 생각하는 것이 편합니다.운영체제의 기본 기능을 프로그램으로 만들어서 실행 하는 겁니다. /bin 또는 /usr/bin에 들어 있습니다. 파일관리 : 파일의 목록을 확인하고, 복사하고, 지우고, 링크걸고, 찾고 하는 프로그램등이 있습니다. 보안관리 : 파일의 권한(읽기, 쓰기, 실행)을 바꾸거나 , 소유권을 바꾸는 프로그램이 있습니다. 프로세스관리: 내부명령에 기본으로 포함되어 있고, 외부 명령으로 기능이 확장되거나 관리가 용이 하도록 만든 프로그램들이 있습니다. 서버관리 : ssh, web, ftp, dns, db 등 많은 서버 프로그램이 있으며, 이들 서버를 관리하는 프로그램이 있습니다. 응용프로그램 : 업무를 도와 줄수 있는 워드, 엑셀, 데이타베이스, 그래픽, 사운드 관련 프로그램이 있습니다. 프로그램의 종류가 워낙 많고 사용법 또한 외우기 쉽지 않기 때문에 최대한 man page를 사용하는 것을 추천 합니다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"내부명령어","slug":"내부명령어","date":"2017-10-29T10:46:54.000Z","updated":"2017-11-01T04:14:03.821Z","comments":true,"path":"2017/10/29/내부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/내부명령어/","excerpt":"","text":"내부명령어내부명령은 Shell에 들어있고 별도 파일로 존재 하지 않는다고 했습니다. 내부명령어는 프로그램 언어 이기 때문에 당연히 변수, 상수, 조건문, 반복문, 배열,등이 있겠죠. 그걸 내부 명령어라고 합니다. 컴퓨터는 명령을 내리면 결과를 돌려 줍니다. 받은 결과를 다른 명령령의 인자로 돌려 줄 수 있다는 것도 꼭 기억하시기 바랍니다. Terminal에서 1# enable 위와 같이 입력하면 현재 사용자가 쓸수 있는 내부 명령어를 보여 줍니다.권한과 옵션에 따라 더많이 보일 수도 있고 적게 보일 수도 있습니다. . . . : [ alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait false 맨 마지막에 위 명령어의 설명이 있습니다. bash script 명령은 파이프라인과 리다이렉션만 설명하고 bash script를 설명할 때 다루도록 하겠습니다. cd, pwd, bg, fg, fc, echo, exec, kill, umask, export, source, logout 이 정도가 많이 쓰입니다. 명령어 설명 cd 경로를 이동합니다. pwd 현재 위치한 경로를 알려줍니다. bg &amp;를 붙여 실행시 백그라운드로 보냅니다. 인수가 없으면 백그라운드로 실행되고 있는 프로그램을 포그라운드로 실행합니다. fg 백그라운드에서 실행되는 프로그램을 포그라운드로 가져옵니다. echo 문자를 출력합니다. exec 프로그램을 실행한다. kill 실행되고 있는 프로세스를 종료합니다. umask 사용자가 생성하는 파일을 mode로 설정한다. export 환경변수를 등록합니다. source bash script가 있는 파일을 실행합니다. logout 현재 사용자를 로그아웃 시킵니다. 파이프라인과 리다이렉션파이프라인| 파이프라인 : 파이프라인을 기준으로 좌측 명령의 결과를 우측의 명령에 인자로 전달합니다. 리다이렉션&gt; 리다이렉션 : 왼쪽 명령 처리 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일 또는 장치(장치도 파일)&gt;&gt; 리다이렉션 : 왼쪽 명령 처리 방향을 오른쪽 옵션으로 추가해 바꾸어 줍니다. 옵션은 파일 또는 장치 처음엔 무슨 뜻인지 햇갈릴 겁니다. 프로그램은 순차적으로 실행됩니다. 왼쪽에서 오른쪽으로. 처음 실행되는 프로그램이 출력을 한다면 출력방향을 바꾸어 줍니다. 처음 실행되는 프로그램 입력을 대기한다면 입력방향을 바꾸어 줍니다. 기본 출력방향은 모니터 입니다. 기본 입력방향은 키보드 입니다.0 표준입력: /dev/stdin 생략가능1 표준출력: /dev/stdout 생략가능2 표준에러출력: /dev/stderr 에러를 출력하기 위해서는 필수. 12345678$echo \"hello\"$echo \"hello\" &gt; aaa.txt$cat aaa.txthello$cat &lt; /dev/stdinhello worldhello world^C echo는 문자 또는 문자열을 출력해주는 프로그램입니다.기본 방향이 모니터이기 때문에 모니터에 문자열을 출력해 주겠죠.출력 방향을 aaa.txt(파일)로 바꾸면 화면에는 아무것도 출력되지 않고 aaa.txt을 생성해서 파일안에 hello라고 써 넣습니다. cat이라는 프로그램은 파일을 출력해 주는 외부 명령어 입니다.사용법은 cat 파일명 하면 파일명을 화면으로 출력해 줍니다.입력을 파일로부터 받는다는 겁니다.위 예제는 cat의 입력방향을 표준입력인 키보드로 바꾸어 준겁니다.종료하려면 Ctrl + C 를 입력합니다. 옵션이 파일명이면 파일로 만들어 주거나 파일에 덧붙여 줍니다. xNIX는 장치도 파일입니다. 파이프라인과 리다이렉션은 무척 중요합니다. 지금은 가볍게 이해 정도만 해주세요. 이해가 안되도 넘어 가도 됩니다. 와일드카드 문자 설명 * 모든 문자 ? 문자하나 [characters] characters 문자 집합에 포함된 문자 [!characters] characters 문자 집합에 포함 되지 않은 문자 [[:class:]] 알파벳과 숫자를 지정 [:alnum:] 알파벳과 숫자를 지정 [:alpha:] 알파벳 지정 [:digit:] 숫자를 지정 [:lower:] 모든 소문자 [:upper:] 모든 대문자 와일드 카드도 너무 중요한 명령입니다. 지금은 이런것이 있다는 것만 너무 중요한데 그냥 넘어 가는구나 생각만 하세요. ls 명령에서 다시 알아 보겠습니다. man page 도움말 보기123# man cd# man pwd# man bash man 명령을 이용해 도움말을 볼 수 있습니다.man 도움말에서 h-key를 누르면 사용법을 볼수 있습니다.q-key를 누르면 종료됩니다. 커서키를 이용해서 위, 아래로 이동하며 스크롤도 할 수 있고, 찾기도 할 수 있습니다. BASH BUILTIN 명령어 설명 : [인수들] 아무런 효과도 없다; 인수들을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다. 종료 상태값 0 을 반환한다. . 파일명 [인수들] | 현재의 디렉토리를 나타낸다. 인수로는 디렉토리와 파일명이 올수 있다. source 파일명 [인수들] 파일명 으로부터 명령을 읽어 현재 쉘 환경 안에서 실행한다. 파일명 에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다. 파일명 에 슬래쉬가 없으면 PATH 변수에 들어있는 경로명을 사용하여 파일명 을 검색한다. PATH 변수에서 찾는 파일이 실행 파일일 필요는 없다. PATH 에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다. 인수들을 적으면 파일을 실행할 때 위치 매개변수로 사용한다. 그렇지 않으면 위치 매개변수는 변하지 않는다. 스크립트 내에서 종료한 마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0) 파일명 을 찾을 수 없으면 거짓을 반환한다. alias [이름[=값] ...] 아무런 인수 없이 Alias를 실행하면 표준 출력에 이름=값의 형식으로 앨리어스 목록을 출력해준다. 인수를 제공하면 각각의 이름에 대하여 값을 앨리어스로 정의한다. 값 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도 앨리어스 확장이 가능한지 점검하도록 할 수 있다. 인수 목록에서 값을 주지 않은 이름에 대해서는 앨리어스의 이름과 값을 출력한다. 주어진 이름에 대한 앨리어스가 정의되어 있지 않은 경우가 아니라면 참값을 반환한다. bg [작업명세] &amp; 를 붙여 실행한 것처럼 작업명세가 가리키는 작업을 백그라운드로 보낸다. 작업명세가 없으면 현재 작업에 해당하는 작업이 사용된다. bg 작업명세 는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만 작업명세를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고 0 을 반환한다. bind [-m 키맵] [-lvd] [-q 이름] bind [-m 키맵] -f 파일명 bind [-m 키맵] 키시퀀스:함수이름 readline 의 현재 키, 함수 바인딩을 표시하거나 readline 함수나 매크로에 키 시퀀스를 결합한다. 바인딩 문법은 .inputrc 의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다; 예를 들어, ‘“\\C-x\\C-r”: re-read-init-file’. 옵션을 적는 경우에는 다음과 같은 의미를 가진다:- ``-m`` 키맵 뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로 키맵 을 사용한다. 가능하 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, 그리고 vi-insert 이 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다. - -l 모든 readline 함수의 이름을 나열한다. - -v 현재 함수 이름과 바인딩을 나열한다. - -d 다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다. - -f 파일명 filename으로부터 키 바인딩을 읽는다. - -q 함수 함수를 실행시키는 키에 대하여 알아본다. 알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다. break [n] for, while, until 루프 안에서 탈출한다. n을 명시하면 n 레벨을 탈출한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다. break 이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다. builtin 쉘-내부명령 [인수들] 명시한 쉘 내부 명령에 인수들 을 주어 실행하고 종료 상태값을 반환한다. 쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의 기능을 활용하고자 할 때 유용하다. 보통 cd 내부 명령을 이런 식으로 재정의하곤 한다. 쉘-내부명령 이 쉘 내부 명령이 아닐 때 거짓을 반환한다. cd [디렉토리] 현재 디렉토리를 디렉토리로 변경한다. HOME 변수 값이 기본 디렉토리 값이다. CDPATH 변수는 디렉토리 를 포함하는 디렉토리에 대한 검색 경로를 정의한다. 서로 다른 디렉토리는 콜론(:)으로 구분한다. CDPATH 에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 .와 같다. 디렉토리 가 슬래쉬(/)로 시작하면 CDPATH 는 사용되지 않는다. 전달인수로 - 를 사용하면 $OLDPWD 와 같다. 성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다. command [-pVv] 명령 [인수 ...] 보통의 쉘 함수 찾아보기를 하지 않고 명령 을 인수 와 함께 실행한다. 내부 명령 또는 PATH 에서 찾을 수 있는 명령만을 실행한다. are executed. If the -p 옵션을 주면 PATH 의 기본값을 사용하여 명령 에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다. -V 또는 -v 옵션을 주면 명령 에 대한 설명을 출력한다. -v 옵션은 명령 을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다; -V 옵션은 좀 더 자세한 설명을 출력한다. – 를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다. -V 또는 -v 옵션을 주었을 때 종료 상태값은 명령 이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나 명령 을 찾을 수 없으면 종료 상태값은 127 이 된다. 그렇지 않을 때 command 내부 명령의 종료 상태값은 명령 의 종료 상태값이다. continue [n] 둘러 싸고 있는 for, while, until 루프의 다음 순차 작업을 재개한다. n 을 명시하면, n 번째 루프를 재개한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(최상위 레벨 루프)를 재개한다. continue 명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은 0 이다. declare [-frxi] [이름[=값]] typeset [-frxi] [이름[=값]] 변수를 선언하거나 변수에 속성을 부여한다. 아무런 이름도 주어지지 않았을 때에는 변수의 값을 표시한다. 옵션을 사용하여 특정 속성의 변수에 대해서만 출력하도록 제한할 수 있다. -f | 함수 이름만 사용 -r | 이름을 읽기 전용으로 만든다. 그 뒤에는 지정문을 사용하여 값을 지정할 수 없다. -x | 이름을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다. -i | 변수를 정수처럼 취급한다; 변수에 값을 지정하면 산술 평가( 산 이 옵션을 끄려면 - 대신 +를 사용한다. 함수 안에서 사용하면 local 명령처럼 이름을 지역적으로 만든다. 잘못된 옵션을 만났다든지, &quot;-f foo=bar&quot;를 사용하여 함수를 정의하려고 시도했다든지, 이름이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용 상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를 표시하려 한 경우가 아니라면 반환값은 0 이다. dirs [-l] [+/-n] 현재까지 기억하고 있는 디렉토리 목록을 표시한다. 디렉토리를 목록에 추가할 때에는 pushd 명령을 사용한다; popd 명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다. 옵션 | 설명 —|— +n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 왼쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 오른쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -l | 긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼 때 틸드를 사용한다. 틀린 옵션을 주거나 n 이 디렉토리 스택 범위를 넘어서는 경우가 아니라면 반환값은 0 이 된다. echo [-neE] [인수 ...] 스페이스로 구분되어 있는 인수들을 출력한다. 반환값은 항상 0 이다. -n을 명시하면 마지막의 개행문자를 출력하지 않는다. -e 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다. -E 옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도 이스케이프 문자를 해석하지 않도록 지시한다. escape 문자| 설명—|—\\a |경 고 (벨)\\b |백스페이스\\c |마지막 개행문자를 생략함\\f |폼 피드\\n |개행문자\\r |캐리지 리턴\\t |수평 탭\\v |수직 탭\\\\ |백슬래쉬\\nnn |ASCII 코드가 nnn (8진수)인 문자 enable [-n] [|-all] [이름 ...] 쉘 내부 명령을 켜거나 끈다. 이 기능을 사용하면 쉘 내부 명령과 같은 이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수 있다. -n을 사용하면 각 이름의 사용을 끈다; 그렇지 않으면 이름의 사용을 켠다. 예를 들어, 쉘 내부 명령 버전 대신 PATH 에서 찾을 수 있는 test 바이너리를 사용하려면 enable -n test 라고 실행한다. 인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다. -n만 주면 사용 불능 상태의 내부 명령 목록을 출력한다. -all만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여 출력해준다. enable 명령은 -all 대신 -a 도 받아들인다. 이름 이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다. eval [인수 ...] 모든 인수를 읽어 하나의 명령으로 결합한다. 그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을 eval 명령의 반환값으로 돌려준다. 인수가 하나도 없거나 널 인수이면 eval 은 참을 반환한다. exec [[-] 명령 [인수]] 명령 을 명시하면 그 명령으로 쉘 프로세스를 교체한다. 새로운 프로세스는 만들어지지 않는다. 인수 는 명령의 인수가 된다. 첫번째 인수가 - 이면 쉘은 명령 에 전달하는 0 번째 인수에 대쉬를 넣는다. 이 과정은 로그인이 하는 일과 같다. 어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수 no_exit_on_failed_exec가 존재하여 거짓을 반환하는 경우를 제외하고 비대화형 쉘은 종료한다. 파일을 실행할 수 없을 때 대화형 쉘은 거짓을 반환한다. 명령 을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은 0 이 된다. exit [n] 상태값 n을 가지고 쉘을 종료한다. n 을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다. 쉘을 종료하기 전에 EXIT 에 대한 트랩(trap) 루틴이 실행된다. export [-nf] [이름[=단어]] ... export -p 나열한 이름 을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다. -f 옵션을 주면 이름 은 함수를 가리킨다. 아무런 이름 도 적지 않거나 또는 -p 옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다. -n 옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다. – 인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다. 잘못된 옵션을 만나거나 이름이 적법한 쉘 변수 이름이 아니거나 또는 함수가 아닌 이 상태값 0 을 반환한다. fc [-e 편집기이름] [-nlr] [처음] [마지막] fc -s [패턴=치환텍스트] [명령] 명령을 수정한다. 첫번째 형식에서, 명령의 범위는 처음 부터 마지막 범위에 있는 명령을 히스토리 목록에서 선택한다. 처음 과 마지막 은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자 (히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터 떨어진 만큼을 뜻한다)로 명시할 수 있다. 마지막 을 명시하지 않으면 현재 명령으로 설정되고(따라서 fc -l -10 은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면 처음 까지 출력한다. If 처음 을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해 -16 을 설정한다.-n 플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다.-r 플래그는 명령의 표시 순서를 반대로 한다.-l 플래그가 있으면 명령을 표준 출력에 나열한다. 그렇지 않을 때에는 편집기이름 이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다. 편집기이름 이 없으면 FCEDIT 변수의 값을 사용하며 FCEDIT 가 설정되어 있지 않을 때에는 EDITOR 값을 사용한다. 둘 다 설정되어 있지 않으면 를 사용한다. 편집을 마친 후에는 편집한 명령들이 화면에 표시되고 실행된다.두번째 형태에서, 명령은 패턴이 치환텍스트로 교체된 후에 다시 실행된다. 유용한 앨리어스로는 r=fc -s가 있다. 앨리어스 적용 후 r cc 라고 치면 cc로 시작하는 최근 명령을 실행하고 r이라고 치면 마지막 명령을 다시 실행하게 된다.첫번째 형태를 사용하면 잘못된 옵션이 있거나 처음 또는 마지막 이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다. -e 옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서 오류가 발생하는 경우 실패 값을 가진다. 두번째 형태를 사용하면 명령 이 유효한 히스토리 행을 가리키지 못하여 fc 가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로 사용한다. fg [작업스펙] 작업스펙 이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다. 작업스펙 이 존재하지 않으면 쉘에서 현재 작업이라고 부르는 것을 사용한다. 반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서 실행된 경우에는 실패이다. 그리고 작업 제어 가능한 상태에서도 작업스펙 이 유효한 작업을 가리키지 않거나 작업스펙 이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다. getopts 옵션문자열 이름 [인수] getopts 는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다. 옵션문자열 은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에 화이트스페이스로 분리된 인수가 온다는 뜻이다. 매번 실행될 때마다, getopts 는 다음 옵션을 쉘 변수 이름 에 넣는다. 이름 이 존재하지 않을 때에는 초기화한다. 그리고 처리할 다음 인수의 인덱스는 OPTIND 변수에 넣는다. OPTIND 는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다. 옵션에서 인수를 필요로 할 때에는 getopts 에서 그 인수를 OPTARG 변수에 넣는다. 쉘이 자동으로 OPTIND 변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을 사용하려면 getopts 를 부를 때마다 수동으로 재설정해 주어야 한다.getopts 는 두 가지 방식으로 오류를 보고할 수 있다. 옵션문자열 의 첫번째 문자가 콜론이면 조용한 오류 보고가 사용된다. 정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의 경우 증상을 설명하는 메시지가 출력된다. OPTERR 변수를 0 으로 설정하면 옵션문자열 의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다.잘못된 옵션을 만나면, getopts 는 이름 에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우, 오류 메시지를 출력하고 OPTARG 를 unset 한다. getopts 이 조용한 모드에 있는 경우 찾아낸 옵션 문자를 OPTARG 에 넣고 증상 설명 메시지를 출력하지 않는다.필요한 인수를 찾을 수 없으며 getopts 가 조용한 모드에 있지 않을 때에는 물음표를 (?) 이름 에 넣고 OPTARG 를 unset 하며 증상 설명 메시지를 출력한다. getopts 가 조용한 모드에 있으면 콜론을 (:) 이름 에 넣고 OPTARG 을 찾아낸 옵션 문자로 설정한다.getopts 는 보통 위치 매개변수를 파싱하지만 인수 부분에 더 많은 인수를 주면 getopts 는 대신 그 인수를 파싱한다. getopts 는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다. 옵션의 끝이거나 에러가 발생하면 거짓을 반환한다. hash [-r] [이름] 각 이름 에 대하여, 그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다. -r 옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다. 아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다. – 라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다. 이름 이 없거나 잘못된 옵션이 주어진 경우가 아닌 경우에는 참을 반환한다. help [패턴] 내부명령에 대한 도움말을 출력한다. 패턴 을 적으면, help 는 패턴과 일치하는 모든 명령에 대하여 자세한 도움말을 준다; 패턴을 적지 않으면 모든 내부명령 목록을 출력한다. 패턴과 일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다. history [n] history -rwan [filename] 옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. * 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다 ;없으면 HISTFILE 변수의 값을 사용한다. 옵션이 있는 경우 다음과 같은 뜻을 갖는다: -a 히스토리 파일에 새로운 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다. -n 히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다. -r 히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다. -w 현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다. jobs [-lnp] [ 작업스펙 ... ] jobs -x 명령 [ 인수 ... ] 첫번째 형태는 활동 중인 작업을 나열한다. -l 옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다; -p 옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다. -n 옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다. 작업스펙 을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다. 잘못된 옵션을 적거나 잘못된 작업스펙 을 적은 경우가 아니라면 반환값은 0 이다. -x 옵션을 붙이면, jobs 명령은 명령 또는 인수 안 에서 작업스펙 을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고 명령 에 인수 를 주어 실행하고 그 종료 상태값을 반환한다. kill [-s 시 kill -l [시그널번호] pid 또는 작업스펙이 가리키는 프로세스에게 시그널스펙 이 가리키는 시그널을 보낸다. 시그널스펙 은 SIGKILL 과 같은 시그널 이름 또는 시그널 번호이다. 시그널스펙 이 시그널 이름인 경우, 대소문자는 구별하지 않으며 SIG 라는 접두어를 써도 되고 쓰지 않아도 된다. 시그널스펙 이 없으면, SIGTERM 이라고 가정한다. -l 인수를 적으면 시그널 이름을 나열해 준다. -l 이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고 반환값은 0 이다. – 인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다. kill 최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다. 오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다. let 인수 [인수 ...] 각각의 인수 는 계산한 수치 표현식이다.( 산 마지막 인수 를 평가하여 그 결과가 0 이면, let 은 1 을 반환한다; 나머지 경우에는 0 을 반환한다. local [이름[=값] ...] 각 인수에 대하여 이름 이라는 지역 변수를 만들고 값 을 할당한다. local 을 함수 안에서 사용하면, 이름 변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다. 피연산자가 없으면, local 은 지역변수 목록을 표준 출력으로 출력한다. local 를 함수 안에서 사용하지 않는 것은 오류이다. local 을 함수 외부에서 사용했거나 잘못된 이름 을 적은 경우가 아니라면 반환 상태값은 0 이다. logout 로그인 쉘을 마친다. popd [+/-n] 디렉토리 스택에서 항목을 제거한다. 인수가 없으면 스택의 최상위 디렉토리를 제거하고 그 새로운 상위 디렉토리로 cd 한다. +n dirs 명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, popd +0는 첫번째 디렉토리를, popd +1는 두번째 디렉토리를 제거한다. -n dirs 명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, popd -0는 맨 마지막 디렉토리를, popd -1는 맨 마지막 바로 전 디렉토리를 제거한다. popd 명령이 성공적이면, dirs 명령도 실행하며 반환 상태값은 0 이다. popd 는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다. pushd [디렉토리] pushd +/-n 디렉토리를 디렉토리 스택의 맨 위에 추가하거나, 스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다. 인수가 없으면, 최상위 두 디렉토리를 교환한다. 디렉토리 스택이 비어 있지 않으면 0을 반환한다. +n n번째 디렉토리( dirs 명령이 보여주는 목록의 맨 왼쪽부터 센다) 이 맨 위에 놓이도록 스택을 회전시킨다. ) -n n번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록 스택을 회전시킨다. 디렉토리를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다. pushd 명령이 성공적이면, dirs 명령도 수행한다. 첫번째 형식을 사용하면, pushd 는 디렉토리 로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다. 두번째 형식을 사용하면, pushd 는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면 0을 반환한다. pwd 현재 디레토리의 절대 경로명을 출력한다. set 내부명령의 -P 옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다. ( 쉘 현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은 0이다. read [-r] [이름 ...] 표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 첫번째 이름 에 할당하고 두번째 단어를 두번째 이름 에 할당하고 나머지 남은 단어들을 마지막 이름 에 할당한다. IFS 에 있는 단어만을 단어 구분자로 인식한다. 아무런 이름 도 적지 않으면 읽어들인 행을 REPLY 변수에 할당한다. 파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다. -r 옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로 인식한다. readonly [-f] [이름 ...] readonly -p 주어진 이름들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해 이름들의 값이 바뀌지 않도록 해 준다. -f 옵션을 더하면, 이름에 해당하는 함수를 읽기 전용으로 표기한다. 아무런 인수도 없거나 -p 옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다. – 인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다. 잘못된 옵션이 있거나 이름들 중 하나라도 적접한 쉘 변수 이름이 아닌 경우 또는 -f 다음에 나온 이름 이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다. return [n] 함수를 상태 반환값 n 을 갖고 종료하도록 한다. n 을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다. 함수 밖에서 사용했지만 . (source) 명령으로 실행한 스크립트에서 사용하면, 쉘은 그 스크립트 실행을 멈추고 n 또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로 반환한다. 함수 밖에서 사용했으며 .[uB85C] 실행한 스크립트가 아니라면 반환 상태값은 거짓이 된다. set [--abefhkmnptuvxldCHP] [-o 옵션] [인수 ...] -a 뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로 표기한다. -b 종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이 아니라 즉시 보여 주도록 한다. ( 쉘 섹션에서 notify 참고) -e 간단한-명령 ( 쉘 종료하면 즉시 종료한다. 만약 실패한 명령이 until 또는 while 루프의 일부, if 문의 일부, &amp;&amp; 의 일부, or ⎪⎪ 목록의 일부이거나 또는 명령의 반환값이 ! 으로 반전되면 종료하지 않는다. -f 경로명 확장을 하지 않는다. -h 함수를 정의할 때 함수 명령을 찾아 기억해 둔다. 함수를 실행할 때 함수 명령을 정상적으로 찾아 본다. -k 명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에 둔다. -m 모니터(감시) 모드. 작업 제어를 사용한다. 지원하는 시스템에서 실행하는 대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다. ( 작 별도의 프로세스 그룹 안에서 실행되며 실행을 완료하면 종료 상태값을 포함하는 행을 출력한다. -n 명령을 읽지만 실행하지는 않는다. 쉘 스크립트 문법 오류를 점검할 때 사용할 수 있다. 대화형 쉘에서는 무시한다. -o 옵션-이름 옵션-이름은 다음 중 한 가지이다: allexport -a 와 같다. braceexpand 쉘이 중괄호 확장을 행한다. ( 앞서 나온 중 확 emacs 이맥스 스타일의 명령행 편집 인터페이스를 사용한다. 쉘을 시작할 때 -nolineediting 옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다. errexit -e와 같다. histexpand -H와 같다. ignoreeof 마치 쉘 명령 IGNOREEOF=10을 실행한 것과 같은 효과를 발휘한다. (앞서 나온 쉘 interactive-comments 어떤 단어를 # 로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다. (앞서 나온 주 monitor -m와 같다. noclobber -C와 같다. noexec -n와 같다. noglob -f와 같다. nohash -d와 같다. notify -b와 같다. nounset -u와 같다. physical -P와 같다. posix POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을 따르도록 만든다. privileged -p와 같다. verbose -v와 같다. vi vi 스타일의 명령행 편집 인터페이스를 사용한다. xtrace -x와 같다. 옵션-이름을 적지 않으면 현재 옵션값을 출력한다. -p privileged 모드를 켠다. 이 모드에서는 $ENV 파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다. 유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때 자동으로 작동한다. 이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자, 그룹 ID로 설정한다. -t 명령 하나를 읽어 실행한 후 종료한다. -u 매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다. 미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고 대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다. -v 쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다. -x 각각의 간단한-명령 을 확장한 후, bash PS4, 의 확장값을 표시하고 명령과 확장된 인수를 표시한다. -l for 이름 [in 단 복원한다. (앞서 나온 쉘 -d 실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다. 보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할 필요 없다. -C 쉘 명령 noclobber=을 실행한 것과 같은 효력을 발휘한다. (앞서 나온 쉘 -H ! 스타일의 히스토리 치환을 사용한다. 쉘이 대화형 모드이면 기본으로 켜지는 플래그이다. -P 설정하면, 현재 디렉토리를 변경하는 cd 와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다. 대신 물리적인 디렉토리를 사용한다. – 이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다. 만약 나오면, - 로 시작하는 것이 있다 할 지라도 위치 매개변수를 인수로 설정한다. - 옵션의 끝을 나타내며, 그 뒤에 나오는 모든 인수들을 위치 매개변수로 설정한다. -x 와 -v 옵션이 꺼진다. 만약 아무런 인수도 없다면, 위치 매개변수는 그대로이다. 다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다. - 대신 + 를 사용하면 플래그를 끈다. 쉘을 실행할 때 옵션으로 적을 수 있다. 현재 플래그 상태는 $- 를 보면 알 수 있다. 옵션 인수를 처리한 후, 나머지 n 개의 인수는 위 매개변수의 값으로 간주하고 차례대로 $1, $2, ... $n 에 할당한다. 아무런 옵션도 없고 인수도 없으면 모든 쉘 변수를 출력한다. 잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다. shift [n] n+1 부터의 위치 매개변수 이름을 $1 .... 로 변경한다. $#부터 $#-n+1까지의 매개변수는 unset된다. n 이 0 이면, 매개변수의 변화는 없다. n 이 주어지지 않으면 1 로 간주한다. n 은 $#보다 작거나 같은 음수 아닌 숫자여야 한다. n 이 $#보다 크면, 위치 매개변수의 변화는 없다. n 이 $# 보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다; 그렇지 않으면 0 이다. suspend [-f] SIGCONT 시그널을 받을 때까지 쉘의 실행을 정지시킨다. -f 옵션은 로그인 쉘이라 할 지라도 불평 메시지를 출력하지 않도록 한다; 어찌 되었든 일시 정지한다. 쉘이 로그인 쉘이면서도 -f 이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은 0 이 된다. test 표현식[ 표현식 ] 조건 표현식을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다. 표현식은 일항 또는 이항 표현식일 수 있다. 일항 표현식은 주로 파일의 상태를 점검할 때 사용한다. 문자열 연산자와 수치 비교 연산자도 있다. 각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다. 파일이 /dev/fd/n의 형태일 때에는, 파일 기술자 n를 점검한다. -b 파일: 파일이 존재하고 블럭 특수 파일이면 참. -c 파일: 파일이 존재하고 문자 특수 파일이면 참. -d 파일: 파일이 존재하고 디렉토리이면 참. -e 파일: 파일이 존재하면 참. -f 파일: 파일이 존재하고 일반 파일이면 참. -g 파일: 파일이 존재하고 set-group-id이면 참. -k 파일: 파일에 스틱키(sticky)비트가 설정되어 있으면 참. -L f파일: 파일이 존재하고 심볼릭 링크이면 참. -p 파일: 파일이 존재하고 명명된(named) 파이프이면 참. -r 파일: 파일이 존재하고 읽을 수 있으면 참. -s 파일: 파일이 존재하고 그 크기가 0 보다 크면 참. -S 파일: 파일이 존재하고 소켓이면 참. -t fd fd (파일 기술자)가 열린 상태이고 터미널이면 참. -u 파일: 파일이 존재하고 set-user-id 비트가 설정되어 있으면 참. -w 파일: 파일이 존재하고 쓸 수 있으면 참. -x 파일: 파일이 존재하고 실행 가능하면 참. -O 파일: 파일이 존재하고 유효(effective) 사용자 ID의 소유이면 참. -G 파일: 파일이 존재하고 유효 그룹 ID의 소유이면 참. 파일1 -nt 파일2: 파일1이 (수정 일시에 의거하여) 파일2보다 새로운 파일이면 참. 파일1 -ot 파일2: 파일1이 파일2보다 오래 된 파일이면 참. 파일1 -ef 파일2: 파일1과 파일2가 같은 장치이며 아이노드 번호가 같으면 참. -z 문자열: 문자열의 길이가 0이면 참. -n 문자열: 문자열 문자열 의 길이가 0이 아니면 참. 문자열1 = 문자열2: 두 문자열이 같으면 참. 문자열1 != 문자열2: 두 문자열이 같지 않으면 참. ! 표현식: 표현식 이 거짓이면 참. 표현식1 -a 표현식2: 표현식1 과 표현식2 둘 다 참이면 참. 표현식1 -o 표현식2: 표현식1 또는 표현식2 둘 중 하나가 참이면 참. 인수1 연산자: 위와 같은 수치 이항 연산자는 각각 인수1이 인수2와 같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다. 인수1 과 인수2 는 양의 정수, 음의 정수 또는 -l 문자열과 같이 문자열 의 길이로 평가되는 특별한 표현식이 될 수 있다. times 쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간, 시스템 영역에서의 소모 시간을 출력한다. 반환값은 0 이다. trap [-l] [인수] [시그널스펙] 쉘이 시그널스펙 이 가리키고 있는 시그널을 받으면 인수로 주어진 명령을 읽어 실행하도록 한다. 인수 가 없거나 - 이면, 제시한 모든 시그널에 대하여 원래의 값으로 돌아간다. (즉 쉘을 시작했을 때의 값) 인수가 널 문자열이면 쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다. 시그널스펙은 에 정의되어 있으면 시그널 이름이거나, 시그널 번호이다. 시그널스펙 이 EXIT (0) 이면 인수로 주어진 명령을 쉘 종료시에 실행한다. 아무런 인수도 없으면, trap 은 각 시그널 번호와 연관된 명령 목록을 출력한다. -l 옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. 쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다. 가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다. 가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 trap 은 참을 반환한다. type [-all] [-type | -path] 이름 [이름 ...] 옵션없이 사용하면, 이름 이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다. -type 플래그를 사용하면, type 은 이름 이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때, alias, keyword, function, builtin, 그리고 file 중 하나를 출력한다. 이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다. -path 플래그를 사용하면, type 은 이름 이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나, -type 이 file 을 반환하지 않을 때에는 아무 것도 반환하지 않는다. 명령이 해쉬된 상태이면, -path 는 PATH 상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다. -all 플래그를 사용하면, type 은 이름 이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다. -path 플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다. -all 을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다. type 은 -all, -type, 과 -path 대신 각각 -a, -t, 과 -p 를 받아들인다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. type 은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을 반환한다. ulimit [-SHacdfmstpnuv [제한]] Ulimit 은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여 사용 자원을 제한할 수 있도록 해 준다. 제한 값은 각 자원에 대한 단위 값이거나 unlimited 라는 값을 가질 수 있다. H와 S 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다. 하드 제한은 일단 설정되면 더 이상 늘릴 수 없다; 한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다. H 와 S 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고 간주한다. 제한을 생략하면 H 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다. 여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다. 기타 다른 옵션은 다음과 같이 해석한다: -d 프로세스의 데이터 세그먼트의 최대 크기 -f 쉘이 만들 수 있는 파일의 최대 크기 -m 상주 설정(resident size) 최대 크기 -s 최대 스택 크기 -t 초 단위의 최대 CPU 시간 -p 512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음) -n 열 수 있는 파일 기술자의 최대 크기 (대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.) -u 단일 사용자에게 허용하는 프로세스 최대 갯수 -v 쉘에 허용하는 가상 메모리의 최대량 – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다. 제한 이 주어지면, 명시한 자원에 대한 새로운 값이 된다.( -a 옵션은 표시할 때만 사용한다.) 아무런 옵션도 없으면 -f 로 간주한다. 값은 초 단위의 -t, 512 바이트의 블럭 단위인 -p, 그리고 단위가 없는 -n 과 -u 를 제외하고, 1024 바이트 단위로 생각한다. 잘못된 옵션이 있거나, 제한 값에 unlimited 이외의 수치 아닌 인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고 반환 상태값은 0 이다. umask [-S] [모드] 사용자 파일 생성 매스크를 모드로 설정한다. 모드가 숫자로 시작하면 8 진수로 해석한다. 그렇지 않으면 chmod(1) 와 비슷한 심볼릭 매스크로 해석한다. 모드 를 생략하거나, -S 옵션을 적으면, 현재의 매스크 값을 출력한다. -S 옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다; 기본 출력 형태는 8 진수이다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. 모드를 성공적으로 변경하거나 아무런 모드 값도 적지 않으면 반환 상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다. unalias [-a] [이름 ...] 정의된 앨리어스 목록에서 이름을 제거한다. -a 를 적으면 모든 앨리어스 정의를 제거한다. 적은 이름 이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다. unset [-fv] [이름 ...] 각각의 이름 에 대하여, 해당하는 변수를 제거하거나, -f 옵션의 경우 함수를 제거한다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. PATH, IFS, PPID, PS1, PS2, UID, 그리고 EUID 는 unset할 수 없다. RANDOM, SECONDS, LINENO, 또는 HISTCMD 중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을 잃게 된다. 이름 이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다. wait [n] 특정 프로세스를 기다리다가 종료값을 반환한다. n 은 프로세스 ID이거나 작업 스펙이다; 작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다. n 을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다. n 이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다. 그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이 된다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"pwd","slug":"pwd","permalink":"http://korcow.github.io/tags/pwd/"},{"name":"cd","slug":"cd","permalink":"http://korcow.github.io/tags/cd/"},{"name":"bg","slug":"bg","permalink":"http://korcow.github.io/tags/bg/"},{"name":"fg","slug":"fg","permalink":"http://korcow.github.io/tags/fg/"},{"name":"fc","slug":"fc","permalink":"http://korcow.github.io/tags/fc/"},{"name":"echo","slug":"echo","permalink":"http://korcow.github.io/tags/echo/"},{"name":"exec","slug":"exec","permalink":"http://korcow.github.io/tags/exec/"},{"name":"kill","slug":"kill","permalink":"http://korcow.github.io/tags/kill/"},{"name":"umask","slug":"umask","permalink":"http://korcow.github.io/tags/umask/"},{"name":"export","slug":"export","permalink":"http://korcow.github.io/tags/export/"},{"name":"source","slug":"source","permalink":"http://korcow.github.io/tags/source/"},{"name":"logout","slug":"logout","permalink":"http://korcow.github.io/tags/logout/"},{"name":"리다이렉션","slug":"리다이렉션","permalink":"http://korcow.github.io/tags/리다이렉션/"},{"name":"파이프라인","slug":"파이프라인","permalink":"http://korcow.github.io/tags/파이프라인/"}]},{"title":"내부명령어와 외부명령어","slug":"내부명령어와-외부명령어","date":"2017-10-29T10:46:40.000Z","updated":"2017-11-01T05:07:07.773Z","comments":true,"path":"2017/10/29/내부명령어와-외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/내부명령어와-외부명령어/","excerpt":"","text":"내부명령어와 외부명령어리눅스의 명령은 내부명령과 외부명령으로 나뉘어 집니다. 내부명령은 별도의 파일이 존재 하지 않습니다.Shell이라고 하는 인터프리터(명령해석기)에 명령이 들어 있습니다.리눅스의 터미널을 실행하면 커서가 깜빡거립니다. 명령입력 대기를 하고있는 겁니다.사용자가 명령을 내리면 Shell이 해석해서 Kernel에 전달하고kernel은 cpu에 전달하고 cpu는 명령을 처리해서 다시Kernel로 전달해 최종적으로 Shell에 돌려줍니다. 외부명령은 OS가 갖추어야할 기본 프로그램이 존재하며 /bin 과 /usr/bin에 들어 있는 파일들이 외부명령 프로그램들입니다. 파일 및 디렉토리 관리 명령 프로세스 관리 명령 JOB 관리 명령 보안 및 권한관리 명령","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"외부명령어","slug":"외부명령어","permalink":"http://korcow.github.io/tags/외부명령어/"},{"name":"내부명령어","slug":"내부명령어","permalink":"http://korcow.github.io/tags/내부명령어/"}]},{"title":"디렉토리","slug":"디렉토리","date":"2017-10-29T10:45:14.000Z","updated":"2017-11-01T05:07:21.421Z","comments":true,"path":"2017/10/29/디렉토리/","link":"","permalink":"http://korcow.github.io/2017/10/29/디렉토리/","excerpt":"","text":"/최상위 디렉토리(root directory). /bin리눅스의 외부명령 파일들이 있습니다. /boot리눅스 부팅에 관련된 파일들이 있습니다. /dev디바이스 파일들이 있습니다. /etc리눅스의 설정 파일들이 있습니다. /home일반 계정 사용자들의 홈 디렉토리가 있습니다. /lib라이브러리 파일들이 담겨 있습니다. /mnt다른 장치들을 마운트하는 디렉토리 /proc프로세스 정보를 담고 있는 파일들이 담겨 있습니다. /rootroot의 홈 디렉토리. /sbinroot가 시스템 운영을 위해 필요한 실행 파일이 있습니다. /tmp임시 디렉토리 /usr사용자들을 위한 대부분의 프로그램들과 설정 파일들이 있습니다. /var각종 로그 파일 등의 시스템 관리와 관련된 정보들이 저장되는 디렉토리. /runFHS 관련 데몬과 파일시스템 관련 파일들이 있습니다. 리눅스가 사용하는 디렉토리.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"directory","slug":"directory","permalink":"http://korcow.github.io/tags/directory/"},{"name":"디렉토리","slug":"디렉토리","permalink":"http://korcow.github.io/tags/디렉토리/"}]},{"title":"부팅 순서","slug":"부팅-순서","date":"2017-10-29T10:44:38.000Z","updated":"2017-11-01T05:08:22.567Z","comments":true,"path":"2017/10/29/부팅-순서/","link":"","permalink":"http://korcow.github.io/2017/10/29/부팅-순서/","excerpt":"","text":"부팅순서 1. 전원on컴퓨터에 전원이 공급되면 제일 먼저 ROM BIOS의 프로그램들이 자동으로 실행됩니다. 2. BIOS 실행BIOS가 실행되면, 컴퓨터가 구동되기 위한 최소한의 장치가 있는지, 이상은 없는지를 테스트하고, 이상이 있다면 Beep음으로 알려줍니다. 이상이 없다면 BIOS에 저장된 부팅장치로 부팅을 시작합니다. 3. 부팅장치 선택부팅장치(CD-ROM, HDD…)로 부터 부트섹터를 읽어 메모리에 적재합니다. 이때 GRUB가 적재되는 겁니다. 4. 부트로더 실행GRUB가 실행되면 부트 메뉴를 보여주고 부팅할 커널을 선택합니다. 5. 커널 이미지 적재선택된 커널 이미지를 MEMORY에 적재합니다. 6. 파일시스템 마운트루트 파일시스템을 적재 합니다. 7. init 프로세스 실행시스템을 초기화 하고 사용자가 시스템을 사용할 수 있도록 해줍니다.이때 설정된 각종 DEAMON도 같이 실행 되어집니다. DAEMON : 종료되지 않고 계속 실행되는 프로그램 8. 로그인 및 사용리눅스시스템은 부팅이 완료되면 각종 설정및 SERVER등이 자동으로 실행 되어 스스로 설정된 명령에 의해 동작됩니다. 시스템에 허가된 사용자는 로그인을 이용해 컴퓨터에접속해서 컴퓨터 사용이 가능합니다. 앞으로 위 [그림1]에서 NORTH BRIDGE 와 SOUTH BRIDGE, BIOS를 생략하고 아래 [그림2]로 시스템 설명을 설명할 겁니다. 메모리와 CPU사이에는 NB, SB가 있다는것을 잊으면 안됩니다. 입력장치: RAM, HDD(각종저장장치), 마이크, 키보드, 마우스, 스케너출력장치: RAM, HDD(각종저장장치), 모니터, 스피커, 프린터처리장치: CPU","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"리눅스의 특징","slug":"리눅스의-특징","date":"2017-10-29T07:29:52.000Z","updated":"2017-11-01T05:08:01.166Z","comments":true,"path":"2017/10/29/리눅스의-특징/","link":"","permalink":"http://korcow.github.io/2017/10/29/리눅스의-특징/","excerpt":"","text":"리눅스의 특징과 역할특징 멀티유저, 멀티태스킹, 멀티 프로세싱, 서버용 운영체제 GUI 와 CUI 를 지원 무료이며, 수많은 소스가 공개 되어 있다. 안정성, 적은 리소스 점유로 mobile, embeded에서도 사용 운영체제 역할리눅스는 많은 OS(Operating System) 운영체제중의 하나입니다. 위에 보는 그림과 같이 컴퓨터는 많은 장치로 구성되어 있습니다. 운영체제는 각각의 장치를 유기적으로 연결해서 컴퓨터를 사용할 수 있도록 해줍니다. SB는 각종 입출력 장치를 제어하고, NB는 PCI BUS 와 SB를 제어 합니다. OS가 없으면 컴퓨터는 동작 하지 않습니다. 기능 파일(디렉토리)관리 파일생성, 이동, 삭제, 복사 프로세스관리 프로그램의 실행및 종료, background, forground 메모리관리 프로그램의 메모리 적제, 사용, 삭제 스케줄관리(job management) 프로그램의 실행및 종료를 언제 할지 관리 보안관리 파일의 소유, 생성, 실행, 읽고쓰기 등…","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"터미널 단축키","slug":"터미널-단축키","date":"2017-10-29T03:58:17.000Z","updated":"2017-11-01T05:09:24.544Z","comments":true,"path":"2017/10/29/터미널-단축키/","link":"","permalink":"http://korcow.github.io/2017/10/29/터미널-단축키/","excerpt":"","text":"터미널 단축키xNIX 계열의 터미널에서 공통적으로 사용되는 단축키 입니다.터미널과 shell에 따라 조금씩 다르고, 더많은 단축키가 있지만 아래 키는 대부분 공통적으로 동작 됩니다. 단축키 설명 TAB 자동완성(파일및디렉토리, 명령을 자동완성) Ctrl+h 백스페이와 같습니다.(더 편합니다.) Ctrl+a 처음으로 이동 Ctrl+e 행 끝으로 이동 Ctrl+b 한 문자 뒤로 이동 Alt+b 한 단어 뒤로 이동 Ctrl+f 한 문자 앞으로 이동 Alt+f 한 단어 앞으로 이동 Ctrl+u 현재줄을 삭제합니다. Ctrl+k 커서 위치에서 행 끝까지 삭제합니다. Ctrl+w 커서앞 한단어를 삭제합니다. Esc+Backspace 이전 단어 삭제 Ctrl+y 클립보드에서 텍스트를 붙여넣습니다. Ctrl+l 화면 상단에 현재 줄을 남겨두고 화면을 지웁니다. Ctrl+r 증분 검색 기록 을 역순으로 추적 Alt+p 비 증분 검색 기록을 역순으로 추적 Ctrl+p 비 증분 검색 기록을 역순으로 추적 터미널 단축키는 man page, sed, edlin, vim, python, perl, rube 에서도 동일하게 사용됩니다. TAB, Ctrl+l, Ctrl+u, Ctrl+w, Ctrl+e, Ctrl+a, Ctrl+p, Ctrl+r위 키는 반드시 손에 익히세요.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://korcow.github.io/tags/centos/"},{"name":"terminal","slug":"terminal","permalink":"http://korcow.github.io/tags/terminal/"}]},{"title":"Centos설치","slug":"Centos설치","date":"2017-10-28T04:54:29.000Z","updated":"2017-11-01T05:09:44.848Z","comments":true,"path":"2017/10/28/Centos설치/","link":"","permalink":"http://korcow.github.io/2017/10/28/Centos설치/","excerpt":"","text":"Centos설치실습의 편의를 위해 VirtualBox에 Centos를 설치하겠습니다. 1. virtualbox 다운로드http://virtualbox.org 사이트에서 자신의 운영체제에 맞는 최신 버전의 virtualbox를 다운로드 받습니다. 2. Centos 다운로드http://centos.org 에서 centos7 dvd iso 이미지를 다운로드 받습니다. 3. virtualbox 설치4. virtualbox 실행 및 centos설치","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://korcow.github.io/tags/centos/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://korcow.github.io/tags/virtualbox/"},{"name":"리눅스설치","slug":"리눅스설치","permalink":"http://korcow.github.io/tags/리눅스설치/"}]},{"title":"post","slug":"post","date":"2017-10-28T04:27:35.000Z","updated":"2017-10-28T04:27:35.594Z","comments":true,"path":"2017/10/28/post/","link":"","permalink":"http://korcow.github.io/2017/10/28/post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"clang","slug":"clang","date":"2017-10-24T04:34:48.000Z","updated":"2017-10-28T04:01:26.820Z","comments":true,"path":"2017/10/24/clang/","link":"","permalink":"http://korcow.github.io/2017/10/24/clang/","excerpt":"","text":"포스트를 수정합니다. 설치1234#include &lt;stdio.h&gt;int main()&#123; printf(\"hi\");&#125;","categories":[],"tags":[]},{"title":"test new","slug":"test-new","date":"2017-10-07T06:42:13.000Z","updated":"2017-10-07T06:44:38.000Z","comments":true,"path":"2017/10/07/test-new/","link":"","permalink":"http://korcow.github.io/2017/10/07/test-new/","excerpt":"","text":"hexo","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-07T06:08:34.000Z","updated":"2017-10-07T06:08:34.000Z","comments":true,"path":"2017/10/07/hello-world/","link":"","permalink":"http://korcow.github.io/2017/10/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}