{"meta":{"title":"KORCOW","subtitle":null,"description":null,"author":"woo-seok Han","url":"http://korcow.github.io"},"pages":[],"posts":[{"title":"vim설치","slug":"vim설치","date":"2017-10-30T11:46:09.000Z","updated":"2017-10-30T17:35:22.177Z","comments":true,"path":"2017/10/30/vim설치/","link":"","permalink":"http://korcow.github.io/2017/10/30/vim설치/","excerpt":"","text":"vim 설치하기 대부분의 Unix계열은 기본으로 vim이 설치 되어 있습니다.vim은 별도로 설치 하지 않아도 됩니다.윈도우 계열은 vim.org에서 자신의 운영체제에 맞는 버젼을 다운받아 설치 하면 됩니다.Unix계열은 gui를 사용 한다면 편의상 gvim을 설치하는 것이 좋습니다. 그래야 클립보드를 사용할 수 있습니다. 설치 방법은 아래와 같습니다. 12345678#red hat 계열$ sudo yum install gvim # macos$ brew install macvim# debian 계열$ suso apt-get install gvim .bash_profile 또는 .profile에 다음과 같이 alias를 추가 합니다. sh alias vi=gvim -v","categories":[{"name":"Vim","slug":"Vim","permalink":"http://korcow.github.io/categories/Vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://korcow.github.io/tags/vim/"}]},{"title":"외부명령어","slug":"외부명령어","date":"2017-10-29T10:47:23.000Z","updated":"2017-10-29T10:47:23.309Z","comments":true,"path":"2017/10/29/외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/외부명령어/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"내부명령어","slug":"내부명령어","date":"2017-10-29T10:46:54.000Z","updated":"2017-10-30T11:17:30.856Z","comments":true,"path":"2017/10/29/내부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/내부명령어/","excerpt":"","text":"내부명령어내부명령은 Shell에 들어있고 별도 파일로 존재 하지 않는다고 했습니다. 내부명령어는 프로그램 언어 이기 때문에 당연히 변수, 상수, 조건문, 반복문, 배열,등이 있겠죠. 그걸 내부 명령어라고 합니다. 컴퓨터는 명령을 내리면 결과를 돌려 줍니다. 받은 결과를 다른 명령령의 인자로 돌려 줄 수 있다는 것도 꼭 기억하시기 바랍니다. Terminal에서1# enable 위와 같이 입력하면 현재 사용자가 쓸수 있는 내부 명령어를 보여 줍니다.권한과 옵션에 따라 더많이 보일 수도 있고 적게 보일 수도 있습니다. . . . : [ alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait false 맨 마지막에 위 명령어의 설명이 있습니다. bash script 명령은 파이프라인과 리다이렉션만 설명하고 bash script를 설명할 때 다루도록 하겠습니다. cd, pwd, bg, fg, fc, echo, exec, kill, umask, export, source, logout 이 정도가 많이 쓰입니다. 명령어 설명 cd 경로를 이동합니다. pwd 현재 위치한 경로를 알려줍니다. bg &amp;를 붙여 실행시 백그라운드로 보냅니다. 인수가 없으면 백그라운드로 실행되고 있는 프로그램을 포그라운드로 실행합니다. fg 백그라운드에서 실행되는 프로그램을 포그라운드로 가져옵니다. echo 문자를 출력합니다. exec 프로그램을 실행한다. kill 실행되고 있는 프로세스를 종료합니다. umask 사용자가 생성하는 파일을 mode로 설정한다. export 환경변수를 등록합니다. source bash script가 있는 파일을 실행합니다. logout 현재 사용자를 로그아웃 시킵니다. | 파이프라인 : 파이프라인을 기준으로 좌측 명령의 결과를 우측의 명령에 인자로 전달합니다. &gt; 리다이렉션 : 왼쪽 명령 결과의 출력 방향을 오른쪽 옵션으로 바꾸어 줍니다. 옵션은 파일또는 장치&gt;&gt; 리다이렉션 : 왼쪽 명령 결과의 출력 방향을 오른쪽 옵션으로 추가해 바꾸어 줍니다. 옵션은 파일 또는 장치 기본 출력방향은 모니터 입니다. 기본 입력방향은 키보드 입니다.0&gt; 표준입력: /dev/stdin1&gt; 표준출력: /dev/stdout2&gt; 표준에러출력: /dev/stderr 12$echo \"hello\"$echo \"hello\" &gt; /dev/stdout 옵션이 파일명이면 파일로 만들어 주거나 파일에 덧붙여 줍니다. xNIX는 장치도 파일입니다. 파이프와 리다이렉션은 무척 중요합니다. 지금은 가볍게 이해 정도만 해주세요. 리다이렉션은 &lt;, &lt;&lt; 도 가능합니다. 와일드카드 문자 설명 * 모든 문자 ? 문자하나 [characters] characters 문자 집합에 포함된 문자 [!characters] characters 문자 집합에 포함 되지 않은 문자 [[:class:]] 클래스에 포함된 문자 [[:alphanumeric:]] 알파벳과 숫자를 지정 [[:alpha:]] 알파벳 지정 [[:digit:]] 숫자를 지정 123# man cd# man pwd# man bash man 명령을 이용해 도움말을 볼 수 있습니다.man 도움말에서 h-key를 누르면 사용법을 볼수 있습니다.q-key를 누르면 종료됩니다. 커서키를 이용해서 위, 아래로 이동하며 볼 수 있습니다. BASH BUILTIN 명령어 설명 : [인수들] 아무런 효과도 없다; 인수들을 확장하고 명시된 리다이렉션을 행하는 것을 제외하고 아무 일도 하지 않는다. 종료 상태값 0 을 반환한다. . 파일명 [인수들] | 현재의 디렉토리를 나타낸다. 인수로는 디렉토리와 파일명이 올수 있다. source 파일명 [인수들] 파일명 으로부터 명령을 읽어 현재 쉘 환경 안에서 실행한다. 파일명 에서 읽어 수행한 마지막 명령의 종료 상태값을 반환한다. 파일명 에 슬래쉬가 없으면 PATH 변수에 들어있는 경로명을 사용하여 파일명 을 검색한다. PATH 변수에서 찾는 파일이 실행 파일일 필요는 없다. PATH 에서 파일을 찾을 수 없으면 현재 디렉토리를 찾는다. 인수들을 적으면 파일을 실행할 때 위치 매개변수로 사용한다. 그렇지 않으면 위치 매개변수는 변하지 않는다. 스크립트 내에서 종료한 마지막 명령의 상태값을 반환하고(아무 명령도 실행되지 않았으면 0) 파일명 을 찾을 수 없으면 거짓을 반환한다. alias [이름[=값] ...] 아무런 인수 없이 Alias를 실행하면 표준 출력에 이름=값의 형식으로 앨리어스 목록을 출력해준다. 인수를 제공하면 각각의 이름에 대하여 값을 앨리어스로 정의한다. 값 뒤에 스페이스를 두면 앨리어스 확장 시 그 다음 단어에 대해서도 앨리어스 확장이 가능한지 점검하도록 할 수 있다. 인수 목록에서 값을 주지 않은 이름에 대해서는 앨리어스의 이름과 값을 출력한다. 주어진 이름에 대한 앨리어스가 정의되어 있지 않은 경우가 아니라면 참값을 반환한다. bg [작업명세] &amp; 를 붙여 실행한 것처럼 작업명세가 가리키는 작업을 백그라운드로 보낸다. 작업명세가 없으면 현재 작업에 해당하는 작업이 사용된다. bg 작업명세 는 작업 제어가 불가능한 상태에서 실행하거나, 작업 제어는 가능하지만 작업명세를 찾을 수 없거나 작업 제어 없이 시작한 경우를 제외하고 0 을 반환한다. bind [-m 키맵] [-lvd] [-q 이름] bind [-m 키맵] -f 파일명 bind [-m 키맵] 키시퀀스:함수이름 readline 의 현재 키, 함수 바인딩을 표시하거나 readline 함수나 매크로에 키 시퀀스를 결합한다. 바인딩 문법은 .inputrc 의 문법과 같지만 각 바인딩을 개별적인 인수로 전달해야 한다; 예를 들어, ‘“\\C-x\\C-r”: re-read-init-file’. 옵션을 적는 경우에는 다음과 같은 의미를 가진다: 옵션 | 설명 —|—-m | 키맵 뒤이어 나오는 바인딩에 의해 영향을 받는 키맵으로 키맵 을 사용한다. 가능하 키맵 이름으로는 emacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move, vi-command, 그리고 vi-insert 이 있다. vi는 vi-command와 같다; emacs는 emacs-standard와 같다.-l | 모든 readline 함수의 이름을 나열한다.-v | 현재 함수 이름과 바인딩을 나열한다.-d | 다시 읽을 수 있는 형태로 함수 이름과 바인딩을 덤프한다.-f 파일명 | filename으로부터 키 바인딩을 읽는다.-q 함수 | 함수를 실행시키는 키에 대하여 알아본다. 알 수 없는 옵션이 주어졌거나 에러가 발생한 경우가 아닐 때에는 0 이 반환된다. break [n] for, while, until 루프 안에서 탈출한다. n을 명시하면 n 레벨을 탈출한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프의 갯수보다 크면 모든 루프를 탈출한다. break 이 실행될 때 루프를 실행 중이 아닌 경우를 제외하고 0 을 반환한다. builtin 쉘-내부명령 [인수들] 명시한 쉘 내부 명령에 인수들 을 주어 실행하고 종료 상태값을 반환한다. 쉘 내부 명령과 같은 이름의 함수를 정의하고 그 함수 안에서 내부 명령의 기능을 활용하고자 할 때 유용하다. 보통 cd 내부 명령을 이런 식으로 재정의하곤 한다. 쉘-내부명령 이 쉘 내부 명령이 아닐 때 거짓을 반환한다. cd [디렉토리] 현재 디렉토리를 디렉토리로 변경한다. HOME 변수 값이 기본 디렉토리 값이다. CDPATH 변수는 디렉토리 를 포함하는 디렉토리에 대한 검색 경로를 정의한다. 서로 다른 디렉토리는 콜론(:)으로 구분한다. CDPATH 에 널 디렉토리 이름을 넣으면 현재 디렉토리 즉 .와 같다. 디렉토리 가 슬래쉬(/)로 시작하면 CDPATH 는 사용되지 않는다. 전달인수로 - 를 사용하면 $OLDPWD 와 같다. 성공적으로 디렉토리를 변경하면 참, 그렇지 않으면 거짓을 반환한다. command [-pVv] 명령 [인수 ...] 보통의 쉘 함수 찾아보기를 하지 않고 명령 을 인수 와 함께 실행한다. 내부 명령 또는 PATH 에서 찾을 수 있는 명령만을 실행한다. are executed. If the -p 옵션을 주면 PATH 의 기본값을 사용하여 명령 에 대한 검색을 하므로 표준 유틸리티를 찾을 수 있도록 보장해 준다. -V 또는 -v 옵션을 주면 명령 에 대한 설명을 출력한다. -v 옵션은 명령 을 호출할 때 사용할 명령 또는 경로명을 가리키는 간단한 단어를 출력한다; -V 옵션은 좀 더 자세한 설명을 출력한다. – 를 전달 인수로 적으면 나머지 인수에 대한 옵션 점검을 하지 않는다. -V 또는 -v 옵션을 주었을 때 종료 상태값은 명령 이 발견되면 0, 그렇지 않으면 1 이 된다. 두 옵션 모두 없고 에러가 발생하거나 명령 을 찾을 수 없으면 종료 상태값은 127 이 된다. 그렇지 않을 때 command 내부 명령의 종료 상태값은 명령 의 종료 상태값이다. continue [n] 둘러 싸고 있는 for, while, until 루프의 다음 순차 작업을 재개한다. n 을 명시하면, n 번째 루프를 재개한다. n 은 ≥ 1 여야 한다. n 이 둘러 싸고 있는 루프 갯수보다 크면 가장 바깥쪽의 루프(최상위 레벨 루프)를 재개한다. continue 명령을 실행할 때 쉘이 루프를 실행하고 있지 않은 경우가 아니라면 반환값은 0 이다. declare [-frxi] [이름[=값]] typeset [-frxi] [이름[=값]] 변수를 선언하거나 변수에 속성을 부여한다. 아무런 이름도 주어지지 않았을 때에는 변수의 값을 표시한다. 옵션을 사용하여 특정 속성의 변수에 대해서만 출력하도록 제한할 수 있다. 옵션 | 설명 —|— -f | 함수 이름만 사용 -r | 이름을 읽기 전용으로 만든다. 그 뒤에는 지정문을 사용하여 값을 지정할 수 없다. -x | 이름을 그 뒤에 나오는 명령에게 환경을 통해 export하도록 한다. -i | 변수를 정수처럼 취급한다; 변수에 값을 지정하면 산술 평가( 산 이 옵션을 끄려면 - 대신 +를 사용한다. 함수 안에서 사용하면 local 명령처럼 이름을 지역적으로 만든다. 잘못된 옵션을 만났다든지, &quot;-f foo=bar&quot;를 사용하여 함수를 정의하려고 시도했다든지, 이름이 적접한 쉘 변수 이름이 아니라든지, 읽기 전용 변수의 읽기 전용 상태를 해제하려 한다든지, 또는 -f 를 가지고 존재하지 않은 함수를 표시하려 한 경우가 아니라면 반환값은 0 이다. dirs [-l] [+/-n] 현재까지 기억하고 있는 디렉토리 목록을 표시한다. 디렉토리를 목록에 추가할 때에는 pushd 명령을 사용한다; popd 명령은 목록으로부터 최근 디렉토리를 꺼내고 그 디렉토리로 이동하도록 한다. 옵션 | 설명 —|— +n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 왼쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -n | 옵션은 아무 옵션 없이 dirs 를 실행했을 때 보이는 목록의 오른쪽부터 세어 n번째 항목을 보여준다. 0 부터 시작한다. -l | 긴 목록을 만들어 보여준다; 기본 목록 나열 형식에서는 홈 디렉토리를 나타낼 때 틸드를 사용한다. 틀린 옵션을 주거나 n 이 디렉토리 스택 범위를 넘어서는 경우가 아니라면 반환값은 0 이 된다. echo [-neE] [인수 ...] 스페이스로 구분되어 있는 인수들을 출력한다. 반환값은 항상 0 이다. -n을 명시하면 마지막의 개행문자를 출력하지 않는다. -e 옵션을 주면 백슬래쉬 이스케이프 문자를 해석할 수 있도록 해준다. -E 옵션은 시스템에서 기본적으로 이스케이프 문자를 해석하는 상황이라 할 지라도 이스케이프 문자를 해석하지 않도록 지시한다. escape 문자| 설명 —|— \\a |경 고 (벨) \\b |백스페이스 \\c |마지막 개행문자를 생략함 \\f |폼 피드 \\n |개행문자 \\r |캐리지 리턴 \\t |수평 탭 \\v |수직 탭 \\\\ |백슬래쉬 \\nnn |ASCII 코드가 nnn (8진수)인 문자 enable [-n] [|-all] [이름 ...] 쉘 내부 명령을 켜거나 큰다. 이 기능을 사용하면 쉘 내부 명령과 같은 이름을 갖는 디스크 명령에 대하여 완전한 경로명을 적지 않고도 실행할 수 있다. -n을 사용하면 각 이름의 사용을 끈다; 그렇지 않으면 이름의 사용을 켠다. 예를 들어, 쉘 내부 명령 버전 대신 PATH 에서 찾을 수 있는 test 바이너리를 사용하려면 enable -n test 라고 실행한다. 인수가 없으면 사용 가능한 모든 쉘 내부 명령 목록을 출력한다. -n만 주면 사용 불능 상태의 내부 명령 목록을 출력한다. -all만 주면 모두 내부 명령에 대하여 가능, 불가능 여부를 표시하여 출력해준다. enable 명령은 -all 대신 -a 도 받아들인다. 이름 이 쉘 내부 명령이 아닌 경우를 제외하고 반환값은 0 이다. eval [인수 ...] 모든 인수를 읽어 하나의 명령으로 결합한다. 그 다음 이 명령을 읽어 쉘에서 실행하고 종료 상태값을 eval 명령의 반환값으로 돌려준다. 인수가 하나도 없거나 널 인수이면 eval 은 참을 반환한다. exec [[-] 명령 [인수]] 명령 을 명시하면 그 명령으로 쉘 프로세스를 교체한다. 새로운 프로세스는 만들어지지 않는다. 인수 는 명령의 인수가 된다. 첫번째 인수가 - 이면 쉘은 명령 에 전달하는 0 번째 인수에 대쉬를 넣는다. 이 과정은 로그인이 하는 일과 같다. 어떤 이유에서든 파일을 실행할 수 없으면 쉘 변수 no_exit_on_failed_exec가 존재하여 거짓을 반환하는 경우를 제외하고 비대화형 쉘은 종료한다. 파일을 실행할 수 없을 때 대화형 쉘은 거짓을 반환한다. 명령 을 명시하지 않으면 현재 쉘에서 리다이렉션만 효력을 발휘하고 반환값은 0 이 된다. exit [n] 상태값 n을 가지고 쉘을 종료한다. n 을 생략하면 실행한 마지막 명령의 종료 상태값을 갖는다. 쉘을 종료하기 전에 EXIT 에 대한 트랩(trap) 루틴이 실행된다. export [-nf] [이름[=단어]] ... export -p 나열한 이름 을 그 다음에 나오는 명령들의 환경에 자동적으로 export되도록 기억해 둔다. -f 옵션을 주면 이름 은 함수를 가리킨다. 아무런 이름 도 적지 않거나 또는 -p 옵션을 주면 쉘에서 export되는 모든 이름 목록을 출력한다. -n 옵션은 주어진 이름의 변수로부터 export 속성을 제거하도록 한다. – 인수를 주면 그 나머지 인수에 대한 옵션 점검을 하지 않도록 한다. 잘못된 옵션을 만나거나 이름이 적법한 쉘 변수 이름이 아니거나 또는 함수가 아닌 이 상태값 0 을 반환한다. fc [-e 편집기이름] [-nlr] [처음] [마지막] fc -s [패턴=치환텍스트] [명령] 명령을 수정한다. 첫번째 형식에서, 명령의 범위는 처음 부터 마지막 범위에 있는 명령을 히스토리 목록에서 선택한다. 처음 과 마지막 은 문자열(그 문자열로 시작하는 최근 명령을 찾고자 할 때) 또는 숫자 (히스토리 목록의 인덱스로 사용하며 음수일 때에는 현재 명령 번호로부터 떨어진 만큼을 뜻한다)로 명시할 수 있다. 마지막 을 명시하지 않으면 현재 명령으로 설정되고(따라서 fc -l -10 은 최근 10 개의 명령을 출력하게 된다) 그렇지 않으면 처음 까지 출력한다. If 처음 을 명시하지 않으면 편집을 위해 이전 명령으로 설정하고 표시를 위해 -16 을 설정한다.-n 플래그를 적으면 나열할 때 명령 번호가 나타나지 않게 한다.-r 플래그는 명령의 표시 순서를 반대로 한다.-l 플래그가 있으면 명령을 표준 출력에 나열한다. 그렇지 않을 때에는 편집기이름 이 가리키는 편집기에서 이 명령들을 포함하는 파일을 열면서 시작한다. 편집기이름 이 없으면 FCEDIT 변수의 값을 사용하며 FCEDIT 가 설정되어 있지 않을 때에는 EDITOR 값을 사용한다. 둘 다 설정되어 있지 않으면 를 사용한다. 편집을 마친 후에는 편집한 명령들이 화면에 표시되고 실행된다.두번째 형태에서, 명령은 패턴이 치환텍스트로 교체된 후에 다시 실행된다. 유용한 앨리어스로는 r=fc -s가 있다. 앨리어스 적용 후 r cc 라고 치면 cc로 시작하는 최근 명령을 실행하고 r이라고 치면 마지막 명령을 다시 실행하게 된다.첫번째 형태를 사용하면 잘못된 옵션이 있거나 처음 또는 마지막 이 히스토리 행 범위를 벗어나지만 않으면 반환값 0 을 갖는다. -e 옵션을 주면 마지막 실행 명령의 값이 반환값이 되거나 명령의 임시 파일에서 오류가 발생하는 경우 실패 값을 가진다. 두번째 형태를 사용하면 명령 이 유효한 히스토리 행을 가리키지 못하여 fc 가 실패를 반환하는 경우가 아니라면 재실행한 명령의 반환값을 반환값으로 사용한다. fg [작업스펙] 작업스펙 이 가리키는 바를 포그라운드에 놓고 현재 작업이 되도록 한다. 작업스펙 이 존재하지 않으면 쉘에서 현재 작업이라고 부르는 것을 사용한다. 반환값은 포그라운드에 놓인 명령의 반환값이거나 작업 제어 불가능 상태에서 실행된 경우에는 실패이다. 그리고 작업 제어 가능한 상태에서도 작업스펙 이 유효한 작업을 가리키지 않거나 작업스펙 이 작업 제어 없이 실행된 작업을 가리킬 때에도 실패이다. getopts 옵션문자열 이름 [인수] getopts 는 위치 매개변수를 파싱하기 위해 사용하는 쉘 프로시져이다. 옵션문자열 은 인식하고자 하는 옵션 문자를 포함한다; 문자 뒤에 콜론이 오면 옵션 다음에 화이트스페이스로 분리된 인수가 온다는 뜻이다. 매번 실행될 때마다, getopts 는 다음 옵션을 쉘 변수 이름 에 넣는다. 이름 이 존재하지 않을 때에는 초기화한다. 그리고 처리할 다음 인수의 인덱스는 OPTIND 변수에 넣는다. OPTIND 는 쉘 또는 쉘 스크립트가 실행될 때마다 1 로 초기화된다. 옵션에서 인수를 필요로 할 때에는 getopts 에서 그 인수를 OPTARG 변수에 넣는다. 쉘이 자동으로 OPTIND 변수를 재설정하지는 않는다;같은 쉘 실행 상태에서 새로운 매개변수 집합을 사용하려면 getopts 를 부를 때마다 수동으로 재설정해 주어야 한다.getopts 는 두 가지 방식으로 오류를 보고할 수 있다. 옵션문자열 의 첫번째 문자가 콜론이면 조용한 오류 보고가 사용된다. 정상 동작 상태에서는 잘못된 옵션 또는 누락된 인수의 경우 증상을 설명하는 메시지가 출력된다. OPTERR 변수를 0 으로 설정하면 옵션문자열 의 첫번째 문자가 콜론이 아니라 하더라도 오류 메시지를 출력하지 않는다.잘못된 옵션을 만나면, getopts 는 이름 에 ? 를 넣고 조용하게 보고하는 상태가 아닌 경우, 오류 메시지를 출력하고 OPTARG 를 unset 한다. getopts 이 조용한 모드에 있는 경우 찾아낸 옵션 문자를 OPTARG 에 넣고 증상 설명 메시지를 출력하지 않는다.필요한 인수를 찾을 수 없으며 getopts 가 조용한 모드에 있지 않을 때에는 물음표를 (?) 이름 에 넣고 OPTARG 를 unset 하며 증상 설명 메시지를 출력한다. getopts 가 조용한 모드에 있으면 콜론을 (:) 이름 에 넣고 OPTARG 을 찾아낸 옵션 문자로 설정한다.getopts 는 보통 위치 매개변수를 파싱하지만 인수 부분에 더 많은 인수를 주면 getopts 는 대신 그 인수를 파싱한다. getopts 는 명시한 것이든 명시하지 않은 것이든 옵션을 찾으면 참을 반환한다. 옵션의 끝이거나 에러가 발생하면 거짓을 반환한다. hash [-r] [이름] 각 이름 에 대하여, 그 이름이 가리키는 명령의 완전한 경로명을 결정하여 기억해 둔다. -r 옵션을 주면 기억해 둔 위치를 모두 잊도록 지시한다. 아무런 인수도 적지 않으면 기억해 둔 명령에 대한 정보를 출력한다. – 라는 인수를 주면 그 뒤에 있는 인수에 점검을 하지 않도록 지시한다. 이름 이 없거나 잘못된 옵션이 주어진 경우가 아닌 경우에는 참을 반환한다. help [패턴] 내부명령에 대한 도움말을 출력한다. 패턴 을 적으면, help 는 패턴과 일치하는 모든 명령에 대하여 자세한 도움말을 준다; 패턴을 적지 않으면 모든 내부명령 목록을 출력한다. 패턴과 일치하는 명령이 없는 경우를 제외하고 반환값은 0 이다. history [n] history -rwan [filename] 옵션이 없으면, 행 번호와 함께 명령 히스토리 목록을 표시한다. * 표시가 있는 행은 수정한 적이 있다는 뜻이다. n 인수를 주면 최근 n 행만을 표시한다. 옵션이 아닌 인수를 적으면, 히스토리 파일 이름으로 간주한다 ;없으면 HISTFILE 변수의 값을 사용한다. 옵션이 있는 경우 다음과 같은 뜻을 갖는다: -a 히스토리 파일에 ``새로운`` 히스토리 행(현재 bash 세션의 시작부터 입력한 히스토리 행)을 추가한다. -n 히스토리 파일로부터 현재 히스토리 목록으로 아직 읽어들이지 않는 히스토리 행을 읽어들인다. 현재 bash 세션 시작부터 히스토리 파일에 추가한 행을 말한다. -r 히스토리 파일의 내용을 읽어 현재 히스토리로 사용한다. -w 현재 히스토리를 히스토리 파일의 기존 내용에 덮어 쓴다. 옵션을 잘못 적거나 히스토리 파일을 읽거나 쓰는 도중 오류가 발생한 경우를 제외하고 반환값은 0 이다. jobs [-lnp] [ 작업스펙 ... ] jobs -x 명령 [ 인수 ... ] 첫번째 형태는 활동 중인 작업을 나열한다. -l 옵션을 더하면 일반적인 정보에 프로세스 ID까지 더하여 나열하도록 한다; -p 옵션은 작업의 프로세스 그룹 리더의 프로세스 ID만 나열하도록 한다. -n 옵션은 지난 번 통보 이후 상태 변화를 일으킨 작업만 표시하도록 한다. 작업스펙 을 적으면, 작업스펙에 맞는 작업에 대한 정보만으로 출력을 제한한다. 잘못된 옵션을 적거나 잘못된 작업스펙 을 적은 경우가 아니라면 반환값은 0 이다. -x 옵션을 붙이면, jobs 명령은 명령 또는 인수 안 에서 작업스펙 을 발견할 때마다 해당 프로세스 그룹 ID로 치환하고 명령 에 인수 를 주어 실행하고 그 종료 상태값을 반환한다. kill [-s 시 kill -l [시그널번호] pid 또는 작업스펙이 가리키는 프로세스에게 시그널스펙 이 가리키는 시그널을 보낸다. 시그널스펙 은 SIGKILL 과 같은 시그널 이름 또는 시그널 번호이다. 시그널스펙 이 시그널 이름인 경우, 대소문자는 구별하지 않으며 SIG 라는 접두어를 써도 되고 쓰지 않아도 된다. 시그널스펙 이 없으면, SIGTERM 이라고 가정한다. -l 인수를 적으면 시그널 이름을 나열해 준다. -l 이 있을 때에는 어떤 인수가 있으면, 특정 시그널의 이름을 나열하고 반환값은 0 이다. – 인수를 주면 그 후 나머지 인수에 대한 옵션 점검을 하지 않도록 강제한다. kill 최소한 한 개의 시그널을 성공적으로 전송했으면 참을 반환한다. 오류가 발생하거나 잘못된 옵션을 만나면 거짓을 반환한다. let 인수 [인수 ...] 각각의 인수 는 계산한 수치 표현식이다.( 산 마지막 인수 를 평가하여 그 결과가 0 이면, let 은 1 을 반환한다; 나머지 경우에는 0 을 반환한다. local [이름[=값] ...] 각 인수에 대하여 이름 이라는 지역 변수를 만들고 값 을 할당한다. local 을 함수 안에서 사용하면, 이름 변수의 가시 범위(scope)를 그 함수와 자식 함수로 제한한다. 피연산자가 없으면, local 은 지역변수 목록을 표준 출력으로 출력한다. local 를 함수 안에서 사용하지 않는 것은 오류이다. local 을 함수 외부에서 사용했거나 잘못된 이름 을 적은 경우가 아니라면 반환 상태값은 0 이다. logout 로그인 쉘을 마친다. popd [+/-n] 디렉토리 스택에서 항목을 제거한다. 인수가 없으면 스택의 최상위 디렉토리를 제거하고 그 새로운 상위 디렉토리로 cd 한다. +n dirs 명령 결과 보이는 목록의 왼쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, ``popd +0``는 첫번째 디렉토리를, ``popd +1``는 두번째 디렉토리를 제거한다. -n dirs 명령 결과 보이는 목록의 오른쪽부터 세기 시작하여 n번째 항목을 제거한다. 0 부터 센다. 예를 들어, ``popd -0``는 맨 마지막 디렉토리를, ``popd -1``는 맨 마지막 바로 전 디렉토리를 제거한다. popd 명령이 성공적이면, dirs 명령도 실행하며 반환 상태값은 0 이다. popd 는 잘못된 옵션을 적거나, 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 명시하거나 디렉토리 이동이 실패할 경우 거짓을 반환한다. pushd [디렉토리] pushd +/-n 디렉토리를 디렉토리 스택의 맨 위에 추가하거나, 스택을 회전시켜 스택의 최 상위 항목을 현재 작업 디렉토리로 만든다. 인수가 없으면, 최상위 두 디렉토리를 교환한다. 디렉토리 스택이 비어 있지 않으면 0을 반환한다. +n n번째 디렉토리( dirs 명령이 보여주는 목록의 맨 왼쪽부터 센다) 이 맨 위에 놓이도록 스택을 회전시킨다. ) -n n번째 디렉토리(오른쪽부터 센다)가 맨 위에 놓이도록 스택을 회전시킨다. 디렉토리 를 디렉토리 스택 맨 위에 추가하여 새로운 작업 디렉토리가 되도록 한다. pushd 명령이 성공적이면, dirs 명령도 수행한다. 첫번째 형식을 사용하면, pushd 는 디렉토리 로 cd 하는 것을 실패하지 않는 한, 0 을 반환한다. 두번째 형식을 사용하면, pushd 는 디렉토리 스택이 비어 있거나, 존재하지 않는 디렉토리 스택 항목을 선택하거나, 지정한 새 현재 디렉토리로 이동하는데 실패한 경우가 아니면 0을 반환한다. pwd 현재 디레토리의 절대 경로명을 출력한다. set 내부명령의 -P 옵션이 설정되어 있으면 경로명에 심볼릭 링크를 포함하지 않는다. ( 쉘 현재 디렉토리의 경로명을 읽는 도중 오류가 발생하지 않았다면 결과 반환값은 0이다. read [-r] [이름 ...] 표준 입력으로부터 한 줄을 읽어들여 그 첫번째 단어를 첫번째 이름 에 할당하고 두번째 단어를 두번째 이름 에 할당하고 나머지 남은 단어들을 마지막 이름 에 할당한다. IFS 에 있는 단어만을 단어 구분자로 인식한다. 아무런 이름 도 적지 않으면 읽어들인 행을 REPLY 변수에 할당한다. 파일 끝 문자를 만난 경우를 제외하고 반환값은 0 이다. -r 옵션을 주면 백슬래쉬-개행 문자 쌍을 무시하지 않고 백슬래쉬를 행의 일부로 인식한다. readonly [-f] [이름 ...] readonly -p 주어진 이름들을 읽기 전용으로 표기하고 다음에 나올 대입문에 의해 이름들의 값이 바뀌지 않도록 해 준다. -f 옵션을 더하면, 이름에 해당하는 함수를 읽기 전용으로 표기한다. 아무런 인수도 없거나 -p 옵션을 주어져 있는 경우에는, 모든 읽기 전용 변수 목록을 출력한다. – 인수는 나머지 인수에 대한 점검을 하지 않도록 지시한다. 잘못된 옵션이 있거나 이름들 중 하나라도 적접한 쉘 변수 이름이 아닌 경우 또는 -f 다음에 나온 이름 이 함수가 아닌 경우를 제외하고는 반환 상태값이 0 이다. return [n] 함수를 상태 반환값 n 을 갖고 종료하도록 한다. n 을 생략하면 함수 몸체 안에서 실행한 마지막 명령의 반환 상태값을 사용한다. 함수 밖에서 사용했지만 . (source) 명령으로 실행한 스크립트에서 사용하면, 쉘은 그 스크립트 실행을 멈추고 n 또는 스크립트에서 실행한 마지막 명령의 종료 상태값을 스크립트의 종료 상태값으로 반환한다. 함수 밖에서 사용했으며 .[uB85C] 실행한 스크립트가 아니라면 반환 상태값은 거짓이 된다. set [--abefhkmnptuvxldCHP] [-o 옵션] [인수 ...] -a 뒤이어 나올 명령의 환경으로 export하기 위해 수정 또는 생성할 변수를 자동으로 표기한다. -b 종료한 백그라운드 작업의 상태를 다음 번 주 프롬프트 전에 보여 주는 것이 아니라 즉시 보여 주도록 한다. ( 쉘 섹션에서 notify 참고) -e 간단한-명령 ( 쉘 종료하면 즉시 종료한다. 만약 실패한 명령이 until 또는 while 루프의 일부, if 문의 일부, &amp;&amp; 의 일부, or ⎪⎪ 목록의 일부이거나 또는 명령의 반환값이 ! 으로 반전되면 종료하지 않는다. -f 경로명 확장을 하지 않는다. -h 함수를 정의할 때 함수 명령을 찾아 기억해 둔다. 함수를 실행할 때 함수 명령을 정상적으로 찾아 본다. -k 명령 이름 앞에 적은 것 뿐 아니라, 모든 키워드 인수를 명령의 환경에 둔다. -m 모니터(감시) 모드. 작업 제어를 사용한다. 지원하는 시스템에서 실행하는 대화형 쉘에 대해서는 이 플래그가 자동으로 켜진다. ( 작 별도의 프로세스 그룹 안에서 실행되며 실행을 완료하면 종료 상태값을 포함하는 행을 출력한다. -n 명령을 읽지만 실행하지는 않는다. 쉘 스크립트 문법 오류를 점검할 때 사용할 수 있다. 대화형 쉘에서는 무시한다. -o 옵션-이름 옵션-이름은 다음 중 한 가지이다: allexport -a 와 같다. braceexpand 쉘이 중괄호 확장을 행한다. ( 앞서 나온 중 확 emacs 이맥스 스타일의 명령행 편집 인터페이스를 사용한다. 쉘을 시작할 때 -nolineediting 옵션을 붙이지 않은 한, 쉘이 대화형 모드일 때의 기본값이다. errexit -e와 같다. histexpand -H와 같다. ignoreeof 마치 쉘 명령 IGNOREEOF=10을 실행한 것과 같은 효과를 발휘한다. (앞서 나온 쉘 interactive-comments 어떤 단어를 # 로 시작하면 그 단어와 그 뒤의 모든 문자를 대화형 쉘에서 무시하도록 한다. (앞서 나온 주 monitor -m와 같다. noclobber -C와 같다. noexec -n와 같다. noglob -f와 같다. nohash -d와 같다. notify -b와 같다. nounset -u와 같다. physical -P와 같다. posix POSIX 1003.2 표준과 기본적으로 다른 bash의 행동방식을 POSIX 표준을 따르도록 만든다. privileged -p와 같다. verbose -v와 같다. vi vi 스타일의 명령행 편집 인터페이스를 사용한다. xtrace -x와 같다. 옵션-이름을 적지 않으면 현재 옵션값을 출력한다. -p privileged 모드를 켠다. 이 모드에서는 $ENV 파일을 처리하지 않으며, 쉘 함수를 환경으로부터 상속하지 않는다. 유효 사용자 (그룹) ID와 실제 사용자 (그룹) ID가 일치하지 않으면 시동할 때 자동으로 작동한다. 이 옵션을 끄면 유효 사용자, 그룹 ID를 실제 사용자, 그룹 ID로 설정한다. -t 명령 하나를 읽어 실행한 후 종료한다. -u 매개변수 확장 시 설정되어 있지 않은 변수를 오류로 간주한다. 미설정 변수에 대한 확장을 시도하면, 쉘은 에러 메시지를 출력하고 대화형 모드가 아니면 0 아닌 상태를 갖고 종료한다. -v 쉘에서 행 입력을 받을 때마다 그 입력행을 출력한다. -x 각각의 간단한-명령 을 확장한 후, bash PS4, 의 확장값을 표시하고 명령과 확장된 인수를 표시한다. -l for 이름 [in 단 복원한다. (앞서 나온 쉘 -d 실행하기 위해 참조하는 명령 해쉬를 사용하지 않는다. 보통 명령을 해쉬 테이블에 기억해 두고 일단 발견하면 다시는 참조할 필요 없다. -C 쉘 명령 noclobber=을 실행한 것과 같은 효력을 발휘한다. (앞서 나온 쉘 -H ! 스타일의 히스토리 치환을 사용한다. 쉘이 대화형 모드이면 기본으로 켜지는 플래그이다. -P 설정하면, 현재 디렉토리를 변경하는 cd 와 같은 명령 실행 중 심볼릭 링크를 따르지 않는다. 대신 물리적인 디렉토리를 사용한다. – 이 플래그 뒤에 아무런 인수도 나오지 않으면 위치 매개변수를 unset한다. 만약 나오면, - 로 시작하는 것이 있다 할 지라도 위치 매개변수를 인수로 설정한다. ``-`` 옵션의 끝을 나타내며, 그 뒤에 나오는 모든 인수들을 위치 매개변수로 설정한다. -x 와 -v 옵션이 꺼진다. 만약 아무런 인수도 없다면, 위치 매개변수는 그대로이다. 다른 식으로 언급하지 않는 한, 이 플래그는 기본적으로 꺼져 있다. - 대신 + 를 사용하면 플래그를 끈다. 쉘을 실행할 때 옵션으로 적을 수 있다. 현재 플래그 상태는 ``$-`` 를 보면 알 수 있다. 옵션 인수를 처리한 후, 나머지 n 개의 인수는 위 매개변수의 값으로 간주하고 차례대로 ``$1, $2, ... $n`` 에 할당한다. 아무런 옵션도 없고 인수도 없으면 모든 쉘 변수를 출력한다. 잘못된 옵션이 없는 한, 반환 상태값은 항상 참이다. shift [n] n+1 부터의 위치 매개변수 이름을 $1 .... 로 변경한다. $#부터 $#-n+1까지의 매개변수는 unset된다. n 이 0 이면, 매개변수의 변화는 없다. n 이 주어지지 않으면 1 로 간주한다. n 은 $#보다 작거나 같은 음수 아닌 숫자여야 한다. n 이 $#보다 크면, 위치 매개변수의 변화는 없다. n 이 $# 보다 크거나 0 보다 작으면 반환 상태값은 0 보다 크다; 그렇지 않으면 0 이다. suspend [-f] SIGCONT 시그널을 받을 때까지 쉘의 실행을 정지시킨다. -f 옵션은 로그인 쉘이라 할 지라도 불평 메시지를 출력하지 않도록 한다; 어찌 되었든 일시 정지한다. 쉘이 로그인 쉘이면서도 -f 이 없거나 또는 작업 제어 기능이 작동 중인 상태가 아니면 반환 상태값은 0 이 된다. test 표현식[ 표현식 ] 조건 표현식을 평가하여 0 (참) 또는 1 (거짓)을 상태값으로 반환한다. 표현식은 일항 또는 이항 표현식일 수 있다. 일항 표현식은 주로 파일의 상태를 점검할 때 사용한다. 문자열 연산자와 수치 비교 연산자도 있다. 각 연산자와 피연산자는 개별적인 인수 형태를 띠어야 한다. 파일이 /dev/fd/n의 형태일 때에는, 파일 기술자 n를 점검한다. -b 파일: 파일이 존재하고 블럭 특수 파일이면 참. -c 파일: 파일이 존재하고 문자 특수 파일이면 참. -d 파일: 파일이 존재하고 디렉토리이면 참. -e 파일: 파일이 존재하면 참. -f 파일: 파일이 존재하고 일반 파일이면 참. -g 파일: 파일이 존재하고 set-group-id이면 참. -k 파일: 파일에 스틱키(sticky)비트가 설정되어 있으면 참. -L f파일: 파일이 존재하고 심볼릭 링크이면 참. -p 파일: 파일이 존재하고 명명된(named) 파이프이면 참. -r 파일: 파일이 존재하고 읽을 수 있으면 참. -s 파일: 파일이 존재하고 그 크기가 0 보다 크면 참. -S 파일: 파일이 존재하고 소켓이면 참. -t fd fd (파일 기술자)가 열린 상태이고 터미널이면 참. -u 파일: 파일이 존재하고 set-user-id 비트가 설정되어 있으면 참. -w 파일: 파일이 존재하고 쓸 수 있으면 참. -x 파일: 파일이 존재하고 실행 가능하면 참. -O 파일: 파일이 존재하고 유효(effective) 사용자 ID의 소유이면 참. -G 파일: 파일이 존재하고 유효 그룹 ID의 소유이면 참. 파일1 -nt 파일2: 파일1이 (수정 일시에 의거하여) 파일2보다 새로운 파일이면 참. 파일1 -ot 파일2: 파일1이 파일2보다 오래 된 파일이면 참. 파일1 -ef 파일2: 파일1과 파일2가 같은 장치이며 아이노드 번호가 같으면 참. -z 문자열: 문자열의 길이가 0이면 참. -n 문자열: 문자열 문자열 의 길이가 0이 아니면 참. 문자열1 = 문자열2: 두 문자열이 같으면 참. 문자열1 != 문자열2: 두 문자열이 같지 않으면 참. ! 표현식: 표현식 이 거짓이면 참. 표현식1 -a 표현식2: 표현식1 과 표현식2 둘 다 참이면 참. 표현식1 -o 표현식2: 표현식1 또는 표현식2 둘 중 하나가 참이면 참. 인수1 연산자: 위와 같은 수치 이항 연산자는 각각 인수1이 인수2와 같거나, 같지 않거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때에 참이다. 인수1 과 인수2 는 양의 정수, 음의 정수 또는 -l 문자열과 같이 문자열 의 길이로 평가되는 특별한 표현식이 될 수 있다. times 쉘과 쉘로부터 실행한 프로세스들에 대하여 사용자 영역에서의 소모 시간, 시스템 영역에서의 소모 시간을 출력한다. 반환값은 0 이다. trap [-l] [인수] [시그널스펙] 쉘이 시그널스펙 이 가리키고 있는 시그널을 받으면 인수로 주어진 명령을 읽어 실행하도록 한다. 인수 가 없거나 - 이면, 제시한 모든 시그널에 대하여 원래의 값으로 돌아간다. (즉 쉘을 시작했을 때의 값) 인수가 널 문자열이면 쉘과 쉘이 실행한 명령이 그 시그널을 무시해 버린다. 시그널스펙은 에 정의되어 있으면 시그널 이름이거나, 시그널 번호이다. 시그널스펙 이 EXIT (0) 이면 인수로 주어진 명령을 쉘 종료시에 실행한다. 아무런 인수도 없으면, trap 은 각 시그널 번호와 연관된 명령 목록을 출력한다. -l 옵션을 주면 시그널 이름과 해당하는 번호 목록을 출력한다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. 쉘을 시작할 때 무시한 시그널에 대해서는 가로채거나 재설정할 수 없다. 가로 챈 시그널은 자식 프로세스가 새롭게 생성될 때 원래의 값으로 재설정된다. 가로채기 이름 또는 번호가 유효하지 않으면 거짓이고 그렇지 않으면 trap 은 참을 반환한다. type [-all] [-type | -path] 이름 [이름 ...] 옵션없이 사용하면, 이름 이 명령 이름으로 사용하였을 때 어떻게 해석할 것인지 알려 준다. -type 플래그를 사용하면, type 은 이름 이 각각 앨리어스, 쉘의 예약된 단어, 함수, 내부함수, 또는 디스크 파일일 때, alias, keyword, function, builtin, 그리고 file 중 하나를 출력한다. 이름을 찾을 수 없으면 아무 것도 출력하지 않고 반환값은 거짓이 된다. -path 플래그를 사용하면, type 은 이름 이 명령 이름으로 사용되었을 때 실행될 디스크 파일 이름을 반환하거나, -type 이 file 을 반환하지 않을 때에는 아무 것도 반환하지 않는다. 명령이 해쉬된 상태이면, -path 는 PATH 상에서 처음으로 나오는 파일이 아니라 해쉬 값을 반환할 것이다. -all 플래그를 사용하면, type 은 이름 이라는 이름을 포함하는 실행 파일이 포함된 모든 장소를 포함한다. -path 플래그를 함께 사용하지 않을 때에만, 앨리어스와 함수를 포함한다. -all 을 사용할 때에는 해쉬 명령 테이블을 참조하지 않는다. type 은 -all, -type, 과 -path 대신 각각 -a, -t, 과 -p 를 받아들인다. – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 하지 않도록 한다. type 은 인수를 발견했을 때에만 참을 반환하고 발견하지 못했을 때에는 거짓을 반환한다. ulimit [-SHacdfmstpnuv [제한]] Ulimit 은 제한 기능을 지원하는 시스템 상에서 쉘과 쉘이 실행한 프로세스에 대하여 사용 자원을 제한할 수 있도록 해 준다. 제한 값은 각 자원에 대한 단위 값이거나 unlimited 라는 값을 가질 수 있다. H와 S 옵션은 주어진 자원에 대한 하드(hard) 또는 소프트(soft) 설정을 명시한다. 하드 제한은 일단 설정되면 더 이상 늘릴 수 없다; 한편 소프트 제한은 하드 제한 값까지 늘릴 수도 있다. H 와 S 중 아무 것도 명시되어 있지 않으면 소프트 제한이라고 간주한다. 제한을 생략하면 H 옵션이 없는 한, 자원의 현재 소프트 제한 값을 출력한다. 여러 개의 자원을 명시했다면 값 앞에 제한 이름과 단위를 출력해 준다. 기타 다른 옵션은 다음과 같이 해석한다: -d 프로세스의 데이터 세그먼트의 최대 크기 -f 쉘이 만들 수 있는 파일의 최대 크기 -m 상주 설정(resident size) 최대 크기 -s 최대 스택 크기 -t 초 단위의 최대 CPU 시간 -p 512 바이트 블럭 단위로 파이프의 크기(설정 가능하지 않을 수 있음) -n 열 수 있는 파일 기술자의 최대 크기 (대부분의 시스템에서는 설정을 허용하지 않고 오로지 출력만 한다.) -u 단일 사용자에게 허용하는 프로세스 최대 갯수 -v 쉘에 허용하는 가상 메모리의 최대량 – 인수는 그 뒤에 나오는 인수에 대한 옵션 점검을 금지한다. 제한 이 주어지면, 명시한 자원에 대한 새로운 값이 된다.( -a 옵션은 표시할 때만 사용한다.) 아무런 옵션도 없으면 -f 로 간주한다. 값은 초 단위의 -t, 512 바이트의 블럭 단위인 -p, 그리고 단위가 없는 -n 과 -u 를 제외하고, 1024 바이트 단위로 생각한다. 잘못된 옵션이 있거나, 제한 값에 unlimited 이외의 수치 아닌 인수를 적거나 또는 새로운 제한을 설정하는데 오류가 발생한 경우를 제외하고 반환 상태값은 0 이다. umask [-S] [모드] 사용자 파일 생성 매스크를 모드로 설정한다. 모드가 숫자로 시작하면 8 진수로 해석한다. 그렇지 않으면 chmod(1) 와 비슷한 심볼릭 매스크로 해석한다. 모드 를 생략하거나, -S 옵션을 적으면, 현재의 매스크 값을 출력한다. -S 옵션은 매스크 값을 심볼릭 형태로 출력하도록 한다; 기본 출력 형태는 8 진수이다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. 모드를 성공적으로 변경하거나 아무런 모드 값도 적지 않으면 반환 상태값은 0 이고 그 나머지 경우에 대해서는 거짓이다. unalias [-a] [이름 ...] 정의된 앨리어스 목록에서 이름을 제거한다. -a 를 적으면 모든 앨리어스 정의를 제거한다. 적은 이름 이 정의되어 있는 앨리어스가 아닌 경우를 제외하고 반환값은 참이다. unset [-fv] [이름 ...] 각각의 이름 에 대하여, 해당하는 변수를 제거하거나, -f 옵션의 경우 함수를 제거한다. – 인수는 뒤에 나오는 인수에 대한 옵션 점검을 금지시킨다. PATH, IFS, PPID, PS1, PS2, UID, 그리고 EUID 는 unset할 수 없다. RANDOM, SECONDS, LINENO, 또는 HISTCMD 중 하나를 unset하면, 그 값은 나중에 다시 설정한다 할 지라도 고유의 특성을 잃게 된다. 이름 이 존재하지 않거나 unset할 수 없는 것이 아닌 한, 종료 상태값은 참이다. wait [n] 특정 프로세스를 기다리다가 종료값을 반환한다. n 은 프로세스 ID이거나 작업 스펙이다; 작업 스펙이면 그 작업의 파이프라인에 존재하는 모든 프로세스를 기다린다. n 을 적지 않으면, 현재 활성 중인 모든 프로세스를 기다리며 반환값은 0 이다. n 이 존재하지 않는 프로세스 또는 작업을 가리키는 경우 반환 상태값은 127 이다. 그렇지 않으면, 반환값은 기다렸던 마지막 프로세스 또는 작업의 종료 상태값이 된다.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"pwd, cd","slug":"pwd-cd","permalink":"http://korcow.github.io/tags/pwd-cd/"}]},{"title":"내부명령어와 외부명령어","slug":"내부명령어와-외부명령어","date":"2017-10-29T10:46:40.000Z","updated":"2017-10-30T11:06:18.191Z","comments":true,"path":"2017/10/29/내부명령어와-외부명령어/","link":"","permalink":"http://korcow.github.io/2017/10/29/내부명령어와-외부명령어/","excerpt":"","text":"내부명령어와 외부명령어리눅스의 명령은 내부명령과 외부명령으로 나뉘어 집니다. 내부명령은 별도의 파일이 존재 하지 않습니다.Shell이라고 하는 인터프리터(명령해석기)에 명령이 들어 있습니다.리눅스의 터미널을 실행하면 커서가 깜빡거립니다. 명령입력 대기를 하고있는 겁니다.사용자가 명령을 내리면 Shell이 해석해서 Kernel에 전달하고kernel은 cpu에 전달하고 cpu는 명령을 처리해서 다시Kernel로 전달해 최종적으로 Shell에 돌려줍니다. 외부명령은 OS가 갖추어야할 기본 프로그램이 존재하며 /bin 과 /usr/bin에 들어 있는 파일들이 외부명령 프로그램들입니다. 파일 및 디렉토리 관리 명령 프로세스 관리 명령 JOB 관리 명령 보안 및 권한관리 명령","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"명령어","slug":"명령어","permalink":"http://korcow.github.io/tags/명령어/"}]},{"title":"디렉토리","slug":"디렉토리","date":"2017-10-29T10:45:14.000Z","updated":"2017-10-29T12:29:22.377Z","comments":true,"path":"2017/10/29/디렉토리/","link":"","permalink":"http://korcow.github.io/2017/10/29/디렉토리/","excerpt":"","text":"/최상위 디렉토리(root directory). /bin리눅스의 외부명령 파일들이 있습니다. /boot리눅스 부팅에 관련된 파일들이 있습니다. /dev디바이스 파일들이 있습니다. /etc리눅스의 설정 파일들이 있습니다. /home일반 계정 사용자들의 홈 디렉토리가 있습니다. /lib라이브러리 파일들이 담겨 있습니다. /mnt다른 장치들을 마운트하는 디렉토리 /proc프로세스 정보를 담고 있는 파일들이 담겨 있습니다. /rootroot의 홈 디렉토리. /sbinroot가 시스템 운영을 위해 필요한 실행 파일이 있습니다. /tmp임시 디렉토리 /usr사용자들을 위한 대부분의 프로그램들과 설정 파일들이 있습니다. /var각종 로그 파일 등의 시스템 관리와 관련된 정보들이 저장되는 디렉토리. /runFHS 관련 데몬과 파일시스템 관련 파일들이 있습니다. 리눅스가 사용하는 디렉토리.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"directory, 디렉토리","slug":"directory-디렉토리","permalink":"http://korcow.github.io/tags/directory-디렉토리/"}]},{"title":"부팅 순서","slug":"부팅-순서","date":"2017-10-29T10:44:38.000Z","updated":"2017-10-29T11:54:27.193Z","comments":true,"path":"2017/10/29/부팅-순서/","link":"","permalink":"http://korcow.github.io/2017/10/29/부팅-순서/","excerpt":"","text":"부팅순서 1. 전원on컴퓨터에 전원이 공급되면 제일 먼저 ROM BIOS의 프로그램들이 자동으로 실행됩니다. 2. BIOS 실행BIOS가 실행되면, 컴퓨터가 구동되기 위한 최소한의 장치가 있는지, 이상은 없는지를 테스트하고, 이상이 있다면 Beep음으로 알려줍니다. 이상이 없다면 BIOS에 저장된 부팅장치로 부팅을 시작합니다. 3. 부팅장치 선택부팅장치(CD-ROM, HDD…)로 부터 부트섹터를 읽어 메모리에 적재합니다. 이때 GRUB가 적재되는 겁니다. 4. 부트로더 실행GRUB가 실행되면 부트 메뉴를 보여주고 부팅할 커널을 선택합니다. 5. 커널 이미지 적재선택된 커널 이미지를 MEMORY에 적재합니다. 6. 파일시스템 마운트루트 파일시스템을 적재 합니다. 7. init 프로세스 실행시스템을 초기화 하고 사용자가 시스템을 사용할 수 있도록 해줍니다.이때 설정된 각종 DEAMON도 같이 실행 되어집니다. DAEMON : 종료되지 않고 계속 실행되는 프로그램 8. 로그인 및 사용리눅스시스템은 부팅이 완료되면 각종 설정및 SERVER등이 자동으로 실행 되어 스스로 설정된 명령에 의해 동작됩니다. 시스템에 허가된 사용자는 로그인을 이용해 컴퓨터에접속해서 컴퓨터 사용이 가능합니다. 앞으로 위 [그림1]에서 NORTH BRIDGE 와 SOUTH BRIDGE, BIOS를 생략하고 아래 [그림2]로 시스템 설명을 설명할 겁니다. 메모리와 CPU사이에는 NB, SB가 있다는것을 잊으면 안됩니다. 입력장치: RAM, HDD(각종저장장치), 마이크, 키보드, 마우스, 스케너출력장치: RAM, HDD(각종저장장치), 모니터, 스피커, 프린터처리장치: CPU","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"리눅스의 특징","slug":"리눅스의-특징","date":"2017-10-29T07:29:52.000Z","updated":"2017-10-29T10:42:07.219Z","comments":true,"path":"2017/10/29/리눅스의-특징/","link":"","permalink":"http://korcow.github.io/2017/10/29/리눅스의-특징/","excerpt":"","text":"리눅스의 특징과 역할특징 멀티유저, 멀티태스킹, 멀티 프로세싱, 서버용 운영체제 GUI 와 CUI 를 지원 무료이며, 수많은 소스가 공개 되어 있다. 안정성, 적은 리소스 점유로 mobile, embeded에서도 사용 운영체제 역할리눅스는 많은 OS(Operating System) 운영체제중의 하나입니다. 위에 보는 그림과 같이 컴퓨터는 많은 장치로 구성되어 있습니다. 운영체제는 각각의 장치를 유기적으로 연결해서 컴퓨터를 사용할 수 있도록 해줍니다. SB는 각종 입출력 장치를 제어하고, NB는 PCI BUS 와 SB를 제어 합니다. OS가 없으면 컴퓨터는 동작 하지 않습니다. 기능 파일(디렉토리)관리 파일생성, 이동, 삭제, 복사 프로세스관리 프로그램의 실행및 종료, background, forground 메모리관리 프로그램의 메모리 적제, 사용, 삭제 스케줄관리(job management) 프로그램의 실행및 종료를 언제 할지 관리 보안관리 파일의 소유, 생성, 실행, 읽고쓰기 등..","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/tags/Centos/"}]},{"title":"터미널 단축키","slug":"터미널-단축키","date":"2017-10-29T03:58:17.000Z","updated":"2017-10-29T07:09:51.476Z","comments":true,"path":"2017/10/29/터미널-단축키/","link":"","permalink":"http://korcow.github.io/2017/10/29/터미널-단축키/","excerpt":"","text":"터미널 단축키xNIX 계열의 터미널에서 공통적으로 사용되는 단축키 입니다.터미널과 shell에 따라 조금씩 다르고, 더많은 단축키가 있지만 아래 키는 대부분 공통적으로 동작 됩니다. 단축키 설명 TAB 자동완성(파일및디렉토리, 명령을 자동완성) Ctrl+h 백스페이와 같습니다.(더 편합니다.) Ctrl+a 처음으로 이동 Ctrl+e 행 끝으로 이동 Ctrl+b 한 문자 뒤로 이동 Alt+b 한 단어 뒤로 이동 Ctrl+f 한 문자 앞으로 이동 Alt+f 한 단어 앞으로 이동 Ctrl+u 현재줄을 삭제합니다. Ctrl+k 커서 위치에서 행 끝까지 삭제합니다. Ctrl+w 커서앞 한단어를 삭제합니다. Esc+Backspace 이전 단어 삭제 Ctrl+y 클립보드에서 텍스트를 붙여넣습니다. Ctrl+l 화면 상단에 현재 줄을 남겨두고 화면을 지웁니다. Ctrl+r 증분 검색 기록 을 역순으로 추적 Alt+p 비 증분 검색 기록을 역순으로 추적 Ctrl+p 비 증분 검색 기록을 역순으로 추적 터미널 단축키는 man page, sed, edlin, vim, python, perl, rube 에서도 동일하게 사용됩니다. TAB, Ctrl+l, Ctrl+u, Ctrl+w, Ctrl+e, Ctrl+a, Ctrl+p, Ctrl+r위 키는 반드시 손에 익히세요.","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos, terminal","slug":"centos-terminal","permalink":"http://korcow.github.io/tags/centos-terminal/"}]},{"title":"Centos설치","slug":"Centos설치","date":"2017-10-28T04:54:29.000Z","updated":"2017-10-28T17:26:44.130Z","comments":true,"path":"2017/10/28/Centos설치/","link":"","permalink":"http://korcow.github.io/2017/10/28/Centos설치/","excerpt":"","text":"Centos설치실습의 편의를 위해 VirtualBox에 Centos를 설치하겠습니다. 1. virtualbox 다운로드http://virtualbox.org 사이트에서 자신의 운영체제에 맞는 최신 버전의 virtualbox를 다운로드 받습니다. 2. Centos 다운로드http://centos.org 에서 centos7 dvd iso 이미지를 다운로드 받습니다. 3. virtualbox 설치4. virtualbox 실행 및 centos설치","categories":[{"name":"Centos","slug":"Centos","permalink":"http://korcow.github.io/categories/Centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://korcow.github.io/tags/centos/"},{"name":"virtualbox","slug":"virtualbox","permalink":"http://korcow.github.io/tags/virtualbox/"},{"name":"리눅스설치","slug":"리눅스설치","permalink":"http://korcow.github.io/tags/리눅스설치/"}]},{"title":"post","slug":"post","date":"2017-10-28T04:27:35.000Z","updated":"2017-10-28T04:27:35.594Z","comments":true,"path":"2017/10/28/post/","link":"","permalink":"http://korcow.github.io/2017/10/28/post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"clang","slug":"clang","date":"2017-10-24T04:34:48.000Z","updated":"2017-10-28T04:01:26.820Z","comments":true,"path":"2017/10/24/clang/","link":"","permalink":"http://korcow.github.io/2017/10/24/clang/","excerpt":"","text":"포스트를 수정합니다. 설치1234#include &lt;stdio.h&gt;int main()&#123; printf(\"hi\");&#125;","categories":[],"tags":[]},{"title":"test new","slug":"test-new","date":"2017-10-07T06:42:13.000Z","updated":"2017-10-07T06:44:38.000Z","comments":true,"path":"2017/10/07/test-new/","link":"","permalink":"http://korcow.github.io/2017/10/07/test-new/","excerpt":"","text":"hexo","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-07T06:08:34.000Z","updated":"2017-10-07T06:08:34.000Z","comments":true,"path":"2017/10/07/hello-world/","link":"","permalink":"http://korcow.github.io/2017/10/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}